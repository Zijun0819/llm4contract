```python
import numpy as np
import pandas as pd
from scipy.optimize import minimize, linprog
from sklearn.mixture import GaussianMixture
from itertools import combinations

def agent_solver_v2(v: np.ndarray, content: list[dict]) -> np.ndarray:
    n_outcomes = len(v)
    logs = content
    
    # Extract contracts and actions
    contracts = np.array([log['Contract'] for log in logs])
    actions = np.array([log['Agent Action'] for log in logs])
    utilities = np.array([log['Principal Utility'] for log in logs])
    
    accepted_idx = np.where(actions == 1)[0]
    rejected_idx = np.where(actions == -1)[0]
    
    if len(accepted_idx) == 0:
        # No accepted contracts, create minimal agent
        p_uniform = np.ones(n_outcomes) / n_outcomes
        high_cost = np.max(contracts) * 2
        return np.array([[*p_uniform, high_cost]])
    
    # Generate diverse probability distributions using multiple methods
    candidate_ps = []
    
    # Method 1: Extreme point distributions
    for i in range(n_outcomes):
        p_extreme = np.zeros(n_outcomes)
        p_extreme[i] = 1.0
        candidate_ps.append(p_extreme)
    
    # Method 2: Uniform distribution
    candidate_ps.append(np.ones(n_outcomes) / n_outcomes)
    
    # Method 3: Value-weighted distributions
    v_normalized = v / np.sum(v)
    candidate_ps.append(v_normalized)
    
    # Method 4: Random Dirichlet samples
    for _ in range(5):
        alpha = np.ones(n_outcomes) * 0.5
        p_dirichlet = np.random.dirichlet(alpha)
        candidate_ps.append(p_dirichlet)
    
    # Method 5: Linear combinations of extreme points
    for i, j in combinations(range(n_outcomes), 2):
        for alpha in [0.3, 0.7]:
            p_mix = np.zeros(n_outcomes)
            p_mix[i] = alpha
            p_mix[j] = 1 - alpha
            candidate_ps.append(p_mix)
    
    # Method 6: Gradient-based optimization for accepted contracts
    for idx in accepted_idx[:5]:  # Limit to first 5 to avoid too many
        w = contracts[idx]
        
        def objective(p):
            return -np.dot(p, w)  # Maximize utility
        
        def constraint1(p):
            return np.sum(p) - 1.0  # Sum to 1
        
        constraints = [{'type': 'eq', 'fun': constraint1}]
        bounds = [(0, 1) for _ in range(n_outcomes)]
        
        x0 = np.random.dirichlet(np.ones(n_outcomes))
        result = minimize(objective, x0, method='SLSQP', bounds=bounds, constraints=constraints)
        
        if result.success:
            candidate_ps.append(result.x / np.sum(result.x))
    
    # Remove duplicates and ensure valid probabilities
    unique_ps = []
    for p in candidate_ps:
        p = np.maximum(p, 1e-10)
        p = p / np.sum(p)
        
        is_duplicate = False
        for existing_p in unique_ps:
            if np.allclose(p, existing_p, atol=1e-6):
                is_duplicate = True
                break
        
        if not is_duplicate:
            unique_ps.append(p)
    
    candidate_ps = unique_ps[:12]  # Limit number of actions
    n_actions = len(candidate_ps)
    
    # Compute costs using sophisticated method
    costs = np.zeros(n_actions)
    
    for a in range(n_actions):
        p = candidate_ps[a]
        
        # Find minimum cost that satisfies IR for accepted contracts
        min_cost_ir = 0
        for idx in accepted_idx:
            w = contracts[idx]
            utility = np.dot(p, w)
            min_cost_ir = max(min_cost_ir, utility)
        
        # Find maximum cost that satisfies IC for rejected contracts
        max_cost_ic = float('inf')
        for idx in rejected_idx:
            w = contracts[idx]
            utility = np.dot(p, w)
            max_cost_ic = min(max_cost_ic, utility)
        
        if max_cost_ic == float('inf'):
            max_cost_ic = min_cost_ir * 2
        
        # Set cost to satisfy both constraints with buffer
        if min_cost_ir <= max_cost_ic:
            costs[a] = (min_cost_ir + max_cost_ic) / 2
        else:
            costs[a] = min_cost_ir * 1.1
        
        # Ensure non-negative cost
        costs[a] = max(0, costs[a])
    
    # Validate and adjust if necessary
    for idx in accepted_idx:
        w = contracts[idx]
        max_util = max(np.dot(candidate_ps[a], w) - costs[a] for a in range(n_actions))
        if max_util < -1e-6:  # Should be non-negative
            # Adjust costs
            best_a = np.argmax([np.dot(candidate_ps[a], w) for a in range(n_actions)])
            costs[best_a] = np.dot(candidate_ps[best_a], w) - 1e-6
    
    for idx in rejected_idx:
        w = contracts[idx]
        max_util = max(np.dot(candidate_ps[a], w) - costs[a] for a in range(n_actions))
        if max_util > 1e-6:  # Should be negative
            # Increase all costs proportionally
            factor = (max_util + 1e-6) / max_util
            costs = costs * factor
    
    # Construct agent setting matrix
    agent_setting = np.column_stack([np.array(candidate_ps), costs])
    
    return agent_setting
```
