```python
import numpy as np
import pandas as pd
from scipy.optimize import minimize, linprog
from sklearn.cluster import KMeans
from sklearn.decomposition import PCA
from itertools import combinations

def agent_solver_v2(v: np.ndarray, content: list[dict]) -> np.ndarray:
    m_outcomes = len(v)
    L = len(content)
    
    accepted_logs = [log for log in content if log['Agent Action'] == 1]
    rejected_logs = [log for log in content if log['Agent Action'] == -1]
    
    if not accepted_logs:
        return np.array([[1/m_outcomes] * m_outcomes + [0.001]])
    
    def solve_dual_problem(w_list, u_list):
        n_contracts = len(w_list)
        w_matrix = np.array(w_list)
        u_array = np.array(u_list)
        
        def objective(x):
            return -np.sum(x * u_array)
        
        constraints = []
        constraints.append({'type': 'eq', 'fun': lambda x: np.sum(x) - 1})
        
        for j in range(m_outcomes):
            constraints.append({
                'type': 'ineq', 
                'fun': lambda x, j=j: np.sum(x * w_matrix[:, j]) - v[j]
            })
        
        bounds = [(0, None) for _ in range(n_contracts)]
        
        x0 = np.ones(n_contracts) / n_contracts
        result = minimize(objective, x0, method='SLSQP', bounds=bounds, constraints=constraints)
        
        if result.success:
            lambdas = result.x
            p = np.zeros(m_outcomes)
            for j in range(m_outcomes):
                shadow_price = np.sum(lambdas * w_matrix[:, j]) - v[j]
                if shadow_price <= 1e-8:
                    p[j] = np.sum(lambdas * w_matrix[:, j])
            p = p / np.sum(p) if np.sum(p) > 0 else np.ones(m_outcomes) / m_outcomes
            return p, np.sum(lambdas * u_array)
        return None, None
    
    candidate_actions = []
    
    for subset_size in range(1, min(len(accepted_logs) + 1, 8)):
        for subset_indices in combinations(range(len(accepted_logs)), subset_size):
            w_subset = [accepted_logs[i]['Contract'] for i in subset_indices]
            u_subset = [accepted_logs[i]['Principal Utility'] for i in subset_indices]
            
            p, cost = solve_dual_problem(w_subset, u_subset)
            if p is not None and cost is not None:
                candidate_actions.append((p, max(0, cost)))
    
    if not candidate_actions:
        uniform_p = np.ones(m_outcomes) / m_outcomes
        avg_util = np.mean([log['Principal Utility'] for log in accepted_logs])
        candidate_actions.append((uniform_p, max(0, avg_util)))
    
    ps, costs = zip(*candidate_actions)
    ps = np.array(ps)
    costs = np.array(costs)
    
    if len(ps) > 1:
        pca = PCA(n_components=min(3, len(ps)))
        ps_reduced = pca.fit_transform(ps)
        n_clusters = min(5, len(ps))
        kmeans = KMeans(n_clusters=n_clusters, random_state=42, n_init=10)
        cluster_labels = kmeans.fit_predict(ps_reduced)
        
        final_actions = []
        for cluster_id in range(n_clusters):
            cluster_mask = cluster_labels == cluster_id
            if np.any(cluster_mask):
                cluster_ps = ps[cluster_mask]
                cluster_costs = costs[cluster_mask]
                
                avg_p = np.mean(cluster_ps, axis=0)
                avg_p = avg_p / np.sum(avg_p)
                avg_cost = np.mean(cluster_costs)
                
                final_actions.append((avg_p, avg_cost))
    else:
        final_actions = candidate_actions
    
    if rejected_logs:
        rejected_wages = np.array([log['Contract'] for log in rejected_logs])
        for i, (p, c) in enumerate(final_actions):
            max_rejected_util = np.max(rejected_wages @ p)
            final_actions[i] = (p, max(c, max_rejected_util + 1e-6))
    
    for log in accepted_logs:
        w = np.array(log['Contract'])
        best_action_util = max(p @ w - c for p, c in final_actions)
        if best_action_util < -1e-6:
            uniform_p = np.ones(m_outcomes) / m_outcomes
            cost_needed = uniform_p @ w
            final_actions.append((uniform_p, cost_needed))
    
    final_ps, final_costs = zip(*final_actions)
    agent_setting = np.column_stack([np.array(final_ps), np.array(final_costs)])
    
    return agent_setting
```
