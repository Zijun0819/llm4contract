```python
import numpy as np
import pandas as pd
from scipy.optimize import linprog, minimize
from sklearn.cluster import KMeans
from sklearn.decomposition import PCA
from itertools import combinations

def agent_solver_v2(v: np.ndarray, content: list[dict]) -> np.ndarray:
    m_outcomes = len(v)
    L = len(content)
    
    def extract_contracts_and_actions():
        contracts = []
        actions = []
        utilities = []
        for log in content:
            contracts.append(np.array(log['Contract']))
            actions.append(log['Agent Action'])
            utilities.append(log['Principal Utility'])
        return np.array(contracts), np.array(actions), np.array(utilities)
    
    contracts, actions, utilities = extract_contracts_and_actions()
    accepted_idx = np.where(actions == 1)[0]
    rejected_idx = np.where(actions == -1)[0]
    
    if len(accepted_idx) == 0:
        return np.array([[1/m_outcomes] * m_outcomes + [0.001]])
    
    def solve_dual_lp(w, u):
        c = np.concatenate([w, [0]])
        A_ub = np.column_stack([np.eye(m_outcomes), -np.ones(m_outcomes)])
        b_ub = np.zeros(m_outcomes)
        A_eq = np.array([[*v, -1]])
        b_eq = np.array([u])
        bounds = [(0, None)] * (m_outcomes + 1)
        
        res = linprog(-c, A_ub=A_ub, b_ub=b_ub, A_eq=A_eq, b_eq=b_eq, bounds=bounds, method='highs')
        if res.success and res.x is not None:
            p = res.x[:m_outcomes]
            cost = res.x[m_outcomes]
            if np.sum(p) > 0:
                p = p / np.sum(p)
                return p, cost
        return None, None
    
    candidate_actions = []
    candidate_costs = []
    
    for idx in accepted_idx:
        w = contracts[idx]
        u = utilities[idx]
        p, cost = solve_dual_lp(w, u)
        if p is not None and cost is not None:
            candidate_actions.append(p)
            candidate_costs.append(max(0, cost))
    
    if not candidate_actions:
        uniform_p = np.ones(m_outcomes) / m_outcomes
        return np.array([np.concatenate([uniform_p, [0.001]])])
    
    candidate_actions = np.array(candidate_actions)
    candidate_costs = np.array(candidate_costs)
    
    n_clusters = min(8, len(candidate_actions))
    if len(candidate_actions) > 1:
        pca = PCA(n_components=min(3, m_outcomes-1))
        features = pca.fit_transform(candidate_actions)
        kmeans = KMeans(n_clusters=n_clusters, random_state=42, n_init=20)
        labels = kmeans.fit_predict(features)
        
        final_actions = []
        final_costs = []
        
        for k in range(n_clusters):
            cluster_mask = labels == k
            if np.sum(cluster_mask) > 0:
                cluster_actions = candidate_actions[cluster_mask]
                cluster_costs = candidate_costs[cluster_mask]
                
                weights = 1.0 / (1.0 + np.std(cluster_actions, axis=0))
                weights = weights / np.sum(weights)
                
                avg_action = np.average(cluster_actions, axis=0, weights=None)
                avg_action = avg_action / np.sum(avg_action)
                
                max_cost = np.max(cluster_costs)
                
                final_actions.append(avg_action)
                final_costs.append(max_cost)
    else:
        final_actions = [candidate_actions[0]]
        final_costs = [candidate_costs[0]]
    
    if len(rejected_idx) > 0:
        rejected_contracts = contracts[rejected_idx]
        for i, (action, cost) in enumerate(zip(final_actions, final_costs)):
            rejected_utilities = rejected_contracts @ action
            max_rejected_utility = np.max(rejected_utilities)
            final_costs[i] = max(cost, max_rejected_utility + 1e-6)
    
    def diversify_actions(actions, costs):
        if len(actions) < 3:
            return actions, costs
        
        diversified = [actions[0]]
        diversified_costs = [costs[0]]
        
        for i in range(1, len(actions)):
            is_diverse = True
            for existing in diversified:
                if np.linalg.norm(actions[i] - existing) < 0.1:
                    is_diverse = False
                    break
            if is_diverse:
                diversified.append(actions[i])
                diversified_costs.append(costs[i])
        
        return diversified, diversified_costs
    
    final_actions, final_costs = diversify_actions(final_actions, final_costs)
    
    agent_setting = []
    for action, cost in zip(final_actions, final_costs):
        row = np.concatenate([action, [cost]])
        agent_setting.append(row)
    
    return np.array(agent_setting)
```
