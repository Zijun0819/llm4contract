```python
import numpy as np
import pandas as pd
from scipy.optimize import linprog, minimize
from sklearn.cluster import KMeans
from sklearn.mixture import GaussianMixture
import itertools

def agent_solver_v2(v: np.ndarray, content: list[dict]) -> np.ndarray:
    n_outcomes = len(v)
    n_logs = len(content)
    
    accepted_logs = [log for log in content if log['Agent Action'] == 1]
    rejected_logs = [log for log in content if log['Agent Action'] == -1]
    
    if not accepted_logs:
        return np.array([[1/n_outcomes] * n_outcomes + [0.0]])
    
    def solve_dual_problem(contracts, utilities):
        n_contracts = len(contracts)
        contracts_matrix = np.array(contracts)
        utilities_vec = np.array(utilities)
        
        c = np.concatenate([np.zeros(n_outcomes), [1]])
        
        A_ub_list = []
        b_ub_list = []
        
        for i in range(n_contracts):
            row = np.concatenate([contracts_matrix[i], [-1]])
            A_ub_list.append(-row)
            b_ub_list.append(-utilities_vec[i])
        
        A_ub = np.array(A_ub_list) if A_ub_list else np.empty((0, n_outcomes + 1))
        b_ub = np.array(b_ub_list) if b_ub_list else np.empty(0)
        
        A_eq = np.array([[1] * n_outcomes + [0]])
        b_eq = np.array([1])
        
        bounds = [(0, 1) for _ in range(n_outcomes)] + [(0, None)]
        
        result = linprog(c, A_ub=A_ub, b_ub=b_ub, A_eq=A_eq, b_eq=b_eq, bounds=bounds, method='highs')
        
        if result.success:
            p = result.x[:n_outcomes]
            cost = result.x[n_outcomes]
            return p, max(0, cost)
        return None, None
    
    def generate_action_candidates():
        candidates = []
        
        accepted_contracts = [log['Contract'] for log in accepted_logs]
        accepted_utilities = [log['Principal Utility'] for log in accepted_logs]
        
        p_main, c_main = solve_dual_problem(accepted_contracts, accepted_utilities)
        if p_main is not None:
            candidates.append((p_main, c_main))
        
        for log in accepted_logs[:min(20, len(accepted_logs))]:
            contract = log['Contract']
            utility = log['Principal Utility']
            
            p_single, c_single = solve_dual_problem([contract], [utility])
            if p_single is not None:
                candidates.append((p_single, c_single))
        
        if len(accepted_logs) > 3:
            n_clusters = min(5, len(accepted_logs) // 2)
            contracts_array = np.array([log['Contract'] for log in accepted_logs])
            
            try:
                kmeans = KMeans(n_clusters=n_clusters, random_state=42, n_init=10)
                cluster_labels = kmeans.fit_predict(contracts_array)
                
                for cluster_id in range(n_clusters):
                    cluster_indices = np.where(cluster_labels == cluster_id)[0]
                    if len(cluster_indices) > 0:
                        cluster_contracts = [accepted_logs[i]['Contract'] for i in cluster_indices]
                        cluster_utilities = [accepted_logs[i]['Principal Utility'] for i in cluster_indices]
                        
                        p_cluster, c_cluster = solve_dual_problem(cluster_contracts, cluster_utilities)
                        if p_cluster is not None:
                            candidates.append((p_cluster, c_cluster))
            except:
                pass
        
        extreme_points = []
        for i in range(n_outcomes):
            p_extreme = np.zeros(n_outcomes)
            p_extreme[i] = 1.0
            
            max_cost = 0
            for log in accepted_logs:
                cost_needed = np.dot(p_extreme, log['Contract']) - log['Principal Utility']
                max_cost = max(max_cost, cost_needed)
            
            extreme_points.append((p_extreme, max_cost))
        
        candidates.extend(extreme_points)
        
        return candidates
    
    def validate_and_adjust_costs(candidates):
        valid_candidates = []
        
        for p, c in candidates:
            adjusted_cost = c
            
            for log in accepted_logs:
                contract = log['Contract']
                utility = log['Principal Utility']
                expected_payment = np.dot(p, contract)
                required_cost = expected_payment - utility
                adjusted_cost = max(adjusted_cost, required_cost)
            
            if rejected_logs:
                for log in rejected_logs:
                    contract = log['Contract']
                    expected_payment = np.dot(p, contract)
                    if expected_payment > adjusted_cost:
                        adjusted_cost = expected_payment + 1e-8
            
            valid_candidates.append((p, max(0, adjusted_cost)))
        
        return valid_candidates
    
    candidates = generate_action_candidates()
    candidates = validate_and_adjust_costs(candidates)
    
    if not candidates:
        uniform_p = np.ones(n_outcomes) / n_outcomes
        return np.array([list(uniform_p) + [0.0]])
    
    unique_candidates = []
    tolerance = 1e-6
    
    for p, c in candidates:
        is_unique = True
        for existing_p, existing_c in unique_candidates:
            if np.allclose(p, existing_p, atol=tolerance) and abs(c - existing_c) < tolerance:
                is_unique = False
                break
        if is_unique:
            unique_candidates.append((p, c))
    
    n_actions = min(8, len(unique_candidates))
    if len(unique_candidates) > n_actions:
        utilities_sum = []
        for p, c in unique_candidates:
            total_utility = sum(max(0, np.dot(p, log['Contract']) - c) for log in accepted_logs)
            utilities_sum.append(total_utility)
        
        top_indices = np.argsort(utilities_sum)[-n_actions:]
        unique_candidates = [unique_candidates[i] for i in top_indices]
    
    agent_setting = []
    for p, c in unique_candidates:
        agent_setting.append(list(p) + [c])
    
    return np.array(agent_setting)
```
