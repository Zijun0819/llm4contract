```python
import numpy as np
import pandas as pd
from scipy.optimize import linprog, minimize
from sklearn.cluster import KMeans
from sklearn.mixture import GaussianMixture
import itertools

def agent_solver_v2(v: np.ndarray, content: list[dict]) -> np.ndarray:
    n_outcomes = len(v)
    logs = content
    
    accepted_logs = [log for log in logs if log['Agent Action'] == 1]
    rejected_logs = [log for log in logs if log['Agent Action'] == -1]
    
    if not accepted_logs:
        return np.array([[1/n_outcomes] * n_outcomes + [0.0]])
    
    accepted_contracts = np.array([log['Contract'] for log in accepted_logs])
    accepted_utilities = np.array([log['Principal Utility'] for log in accepted_logs])
    
    rejected_contracts = np.array([log['Contract'] for log in rejected_logs]) if rejected_logs else np.array([]).reshape(0, n_outcomes)
    
    def solve_dual_problem(contracts, utilities):
        n_contracts = len(contracts)
        if n_contracts == 0:
            return None
            
        def objective(params):
            p = params[:n_outcomes]
            c = params[n_outcomes]
            
            penalty = 0
            if np.sum(p) != 1:
                penalty += 1000 * (np.sum(p) - 1)**2
            if np.any(p < 0):
                penalty += 1000 * np.sum(np.maximum(0, -p)**2)
            if c < 0:
                penalty += 1000 * c**2
                
            loss = 0
            for i in range(n_contracts):
                expected_utility = np.dot(p, contracts[i]) - c
                if expected_utility < 0:
                    loss += expected_utility**2
                    
            return loss + penalty
        
        constraints = [
            {'type': 'eq', 'fun': lambda x: np.sum(x[:n_outcomes]) - 1},
            {'type': 'ineq', 'fun': lambda x: x[:n_outcomes]},
            {'type': 'ineq', 'fun': lambda x: x[n_outcomes]}
        ]
        
        results = []
        for _ in range(10):
            x0 = np.random.dirichlet(np.ones(n_outcomes))
            x0 = np.append(x0, np.random.exponential(0.001))
            
            res = minimize(objective, x0, method='SLSQP', constraints=constraints)
            if res.success:
                results.append((res.fun, res.x))
        
        if results:
            best_result = min(results, key=lambda x: x[0])
            return best_result[1]
        
        return None
    
    candidate_actions = []
    
    if len(accepted_contracts) >= 3:
        gmm = GaussianMixture(n_components=min(5, len(accepted_contracts)//2), random_state=42)
        try:
            gmm.fit(accepted_contracts)
            cluster_labels = gmm.predict(accepted_contracts)
            
            for cluster_id in np.unique(cluster_labels):
                cluster_mask = cluster_labels == cluster_id
                cluster_contracts = accepted_contracts[cluster_mask]
                cluster_utilities = accepted_utilities[cluster_mask]
                
                action_params = solve_dual_problem(cluster_contracts, cluster_utilities)
                if action_params is not None:
                    candidate_actions.append(action_params)
        except:
            pass
    
    if len(candidate_actions) < 2:
        for i in range(min(7, len(accepted_contracts))):
            subset_size = min(5, len(accepted_contracts))
            indices = np.random.choice(len(accepted_contracts), subset_size, replace=False)
            subset_contracts = accepted_contracts[indices]
            subset_utilities = accepted_utilities[indices]
            
            action_params = solve_dual_problem(subset_contracts, subset_utilities)
            if action_params is not None:
                candidate_actions.append(action_params)
    
    if not candidate_actions:
        uniform_p = np.ones(n_outcomes) / n_outcomes
        min_cost = np.min(accepted_contracts @ uniform_p) if len(accepted_contracts) > 0 else 0.0
        candidate_actions.append(np.append(uniform_p, max(0, min_cost)))
    
    final_actions = []
    for action_params in candidate_actions:
        p = action_params[:n_outcomes]
        c = action_params[n_outcomes]
        
        p = np.maximum(p, 1e-6)
        p = p / np.sum(p)
        
        min_accepted_utility = float('inf')
        for contract in accepted_contracts:
            utility = np.dot(p, contract) - c
            if utility >= 0:
                min_accepted_utility = min(min_accepted_utility, utility)
        
        max_rejected_utility = -float('inf')
        for contract in rejected_contracts:
            utility = np.dot(p, contract) - c
            max_rejected_utility = max(max_rejected_utility, utility)
        
        if len(rejected_contracts) > 0 and max_rejected_utility >= 0:
            c = max(c, max_rejected_utility + 1e-6)
        
        final_actions.append(np.append(p, c))
    
    if len(final_actions) > 6:
        action_matrix = np.array(final_actions)
        kmeans = KMeans(n_clusters=6, random_state=42, n_init=10)
        try:
            kmeans.fit(action_matrix[:, :n_outcomes])
            centers = kmeans.cluster_centers_
            
            final_actions = []
            for center in centers:
                center = np.maximum(center, 1e-6)
                center = center / np.sum(center)
                
                cost = 0
                if len(accepted_contracts) > 0:
                    utilities = accepted_contracts @ center
                    cost = np.percentile(utilities, 10)
                
                if len(rejected_contracts) > 0:
                    rej_utilities = rejected_contracts @ center
                    cost = max(cost, np.max(rej_utilities) + 1e-6)
                
                final_actions.append(np.append(center, max(0, cost)))
        except:
            pass
    
    if len(final_actions) == 0:
        uniform_p = np.ones(n_outcomes) / n_outcomes
        cost = np.mean(accepted_contracts @ uniform_p) * 0.5 if len(accepted_contracts) > 0 else 0.0
        final_actions.append(np.append(uniform_p, cost))
    
    return np.array(final_actions)
```
