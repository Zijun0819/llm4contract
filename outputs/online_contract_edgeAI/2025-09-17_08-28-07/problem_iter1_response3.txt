```python
import numpy as np
import pandas as pd
from scipy.optimize import minimize, linprog
from sklearn.cluster import KMeans
from itertools import combinations

def agent_solver_v2(v: np.ndarray, content: list[dict]) -> np.ndarray:
    m_outcomes = len(v)
    L = len(content)
    
    accepted_logs = [log for log in content if log['Agent Action'] == 1]
    rejected_logs = [log for log in content if log['Agent Action'] == -1]
    
    if not accepted_logs:
        return np.hstack([np.eye(m_outcomes), np.zeros((m_outcomes, 1))])
    
    def solve_dual_lp(w, u):
        c = np.concatenate([w, [0]])
        A_ub = np.concatenate([np.eye(m_outcomes), -(v - w).reshape(-1, 1)], axis=1)
        b_ub = np.zeros(m_outcomes)
        A_eq = np.concatenate([np.ones(m_outcomes).reshape(1, -1), np.zeros((1, 1))], axis=1)
        b_eq = np.array([1.0])
        bounds = [(0, None)] * m_outcomes + [(None, None)]
        
        res = linprog(-c, A_ub=A_ub, b_ub=b_ub, A_eq=A_eq, b_eq=b_eq, bounds=bounds, method='highs')
        if res.success:
            p = res.x[:m_outcomes]
            return p / p.sum() if p.sum() > 1e-8 else None
        return None
    
    candidate_distributions = []
    for log in accepted_logs:
        w = np.array(log['Contract'])
        u = log['Principal Utility']
        p = solve_dual_lp(w, u)
        if p is not None:
            candidate_distributions.append(p)
    
    if not candidate_distributions:
        return np.hstack([np.eye(m_outcomes), np.zeros((m_outcomes, 1))])
    
    all_p = np.array(candidate_distributions)
    
    n_actions = min(len(candidate_distributions), 8)
    if len(candidate_distributions) > 1:
        kmeans = KMeans(n_clusters=n_actions, random_state=42, n_init=20)
        cluster_labels = kmeans.fit_predict(all_p)
        action_probs = kmeans.cluster_centers_
    else:
        action_probs = all_p
        cluster_labels = [0] * len(all_p)
    
    action_probs = np.maximum(action_probs, 1e-10)
    action_probs = action_probs / action_probs.sum(axis=1, keepdims=True)
    
    costs = np.zeros(n_actions)
    
    for a in range(n_actions):
        cluster_indices = [i for i, label in enumerate(cluster_labels) if label == a]
        if cluster_indices:
            min_utilities = []
            for idx in cluster_indices:
                log = accepted_logs[idx]
                w = np.array(log['Contract'])
                utility = np.dot(action_probs[a], w)
                min_utilities.append(utility)
            costs[a] = min(min_utilities) if min_utilities else 0.0
        
        if rejected_logs:
            max_rejected_utility = 0.0
            for log in rejected_logs:
                w = np.array(log['Contract'])
                utility = np.dot(action_probs[a], w)
                max_rejected_utility = max(max_rejected_utility, utility)
            costs[a] = max(costs[a], max_rejected_utility + 1e-6)
    
    agent_setting = np.hstack([action_probs, costs.reshape(-1, 1)])
    return agent_setting
```
