```python
import numpy as np
import pandas as pd
from scipy.optimize import minimize, linprog
from sklearn.cluster import KMeans
from sklearn.decomposition import PCA
from itertools import combinations

def agent_solver_v2(v: np.ndarray, content: list[dict]) -> np.ndarray:
    m_outcomes = len(v)
    L = len(content)
    
    accepted_logs = [log for log in content if log['Agent Action'] == 1]
    rejected_logs = [log for log in content if log['Agent Action'] == -1]
    
    if not accepted_logs:
        default_p = np.ones(m_outcomes) / m_outcomes
        return np.hstack([default_p.reshape(1, -1), np.array([[0.0]])])
    
    def extract_feasible_distributions():
        distributions = []
        utilities = []
        
        for log in accepted_logs:
            w = np.array(log['Contract'])
            u = log['Principal Utility']
            
            c_eq = np.vstack([np.ones(m_outcomes), v - w])
            b_eq = np.array([1.0, u])
            bounds = [(0, 1) for _ in range(m_outcomes)]
            
            result = linprog(-np.ones(m_outcomes), A_eq=c_eq, b_eq=b_eq, bounds=bounds, method='highs')
            
            if result.success:
                distributions.append(result.x)
                utilities.append(u)
        
        return np.array(distributions), np.array(utilities)
    
    feasible_p, feasible_u = extract_feasible_distributions()
    
    if len(feasible_p) == 0:
        default_p = np.ones(m_outcomes) / m_outcomes
        return np.hstack([default_p.reshape(1, -1), np.array([[0.0]])])
    
    def adaptive_clustering():
        n_samples = len(feasible_p)
        max_clusters = min(8, max(2, n_samples // 3))
        
        if n_samples <= 2:
            return feasible_p, np.arange(n_samples)
        
        pca = PCA(n_components=min(3, m_outcomes))
        p_reduced = pca.fit_transform(feasible_p)
        
        best_score = -np.inf
        best_centers = None
        best_labels = None
        
        for n_clusters in range(2, max_clusters + 1):
            kmeans = KMeans(n_clusters=n_clusters, random_state=42, n_init=20)
            labels = kmeans.fit_predict(p_reduced)
            
            if len(np.unique(labels)) < n_clusters:
                continue
                
            inertia = kmeans.inertia_
            score = -inertia / n_clusters
            
            if score > best_score:
                best_score = score
                best_centers = kmeans.cluster_centers_
                best_labels = labels
        
        if best_centers is None:
            return feasible_p[:2], np.array([0, 1])
        
        final_centers = []
        for i in range(len(best_centers)):
            cluster_points = feasible_p[best_labels == i]
            if len(cluster_points) > 0:
                center = np.mean(cluster_points, axis=0)
                center = np.maximum(center, 1e-8)
                center /= np.sum(center)
                final_centers.append(center)
        
        return np.array(final_centers), best_labels
    
    action_probs, cluster_labels = adaptive_clustering()
    n_actions = len(action_probs)
    
    def compute_costs():
        costs = np.zeros(n_actions)
        
        for a in range(n_actions):
            action_utilities = []
            
            if len(np.unique(cluster_labels)) > 1:
                cluster_indices = np.where(cluster_labels == a)[0]
                if len(cluster_indices) > 0:
                    for idx in cluster_indices:
                        log_idx = idx if idx < len(accepted_logs) else 0
                        w = np.array(accepted_logs[log_idx]['Contract'])
                        utility = np.dot(action_probs[a], w)
                        action_utilities.append(utility)
            else:
                for log in accepted_logs:
                    w = np.array(log['Contract'])
                    utility = np.dot(action_probs[a], w)
                    action_utilities.append(utility)
            
            if action_utilities:
                costs[a] = max(0, np.percentile(action_utilities, 25))
            else:
                costs[a] = 0.0
        
        if rejected_logs:
            rejection_threshold = 0
            for log in rejected_logs:
                w = np.array(log['Contract'])
                max_utility = max(np.dot(action_probs[a], w) for a in range(n_actions))
                rejection_threshold = max(rejection_threshold, max_utility)
            
            costs = np.maximum(costs, rejection_threshold + 1e-6)
        
        return costs
    
    costs = compute_costs()
    
    def refine_solution():
        refined_probs = action_probs.copy()
        refined_costs = costs.copy()
        
        for iteration in range(3):
            for a in range(n_actions):
                violations = []
                
                for i, log in enumerate(content):
                    w = np.array(log['Contract'])
                    expected_utility = np.dot(refined_probs[a], w) - refined_costs[a]
                    
                    if log['Agent Action'] == 1 and expected_utility < -1e-6:
                        violations.append(('accept', i, expected_utility))
                    elif log['Agent Action'] == -1 and expected_utility > 1e-6:
                        violations.append(('reject', i, expected_utility))
                
                if violations:
                    adjustment = 0.01 * (iteration + 1)
                    
                    for vtype, idx, util in violations[:3]:
                        if vtype == 'accept':
                            refined_costs[a] = max(0, refined_costs[a] + util - adjustment)
                        else:
                            refined_costs[a] = refined_costs[a] + adjustment
        
        return refined_probs, refined_costs
    
    final_probs, final_costs = refine_solution()
    
    agent_setting = np.hstack([final_probs, final_costs.reshape(-1, 1)])
    return agent_setting
```
