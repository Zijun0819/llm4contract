```python
import numpy as np
import pandas as pd
from scipy.optimize import minimize
from sklearn.cluster import KMeans
from sklearn.decomposition import PCA

def agent_solver_v2(v: np.ndarray, content: list[dict]) -> np.ndarray:
    n_outcomes = len(v)
    n_logs = len(content)
    
    accepted_contracts = []
    rejected_contracts = []
    accepted_utilities = []
    
    for log in content:
        contract = np.array(log['Contract'])
        if log['Agent Action'] == 1:
            accepted_contracts.append(contract)
            accepted_utilities.append(log['Principal Utility'])
        else:
            rejected_contracts.append(contract)
    
    accepted_contracts = np.array(accepted_contracts)
    rejected_contracts = np.array(rejected_contracts) if rejected_contracts else np.empty((0, n_outcomes))
    accepted_utilities = np.array(accepted_utilities)
    
    def infer_action_from_contract(contract, utility):
        def objective(params):
            p = params[:n_outcomes]
            c = params[n_outcomes]
            if np.sum(p) == 0:
                return 1e10
            p_normalized = p / np.sum(p)
            expected_payment = np.dot(p_normalized, contract)
            expected_value = np.dot(p_normalized, v)
            agent_utility = expected_payment - c
            principal_utility = expected_value - expected_payment
            return (principal_utility - utility)**2 + max(0, -agent_utility)**2
        
        constraints = [
            {'type': 'eq', 'fun': lambda x: np.sum(x[:n_outcomes]) - 1},
            {'type': 'ineq', 'fun': lambda x: x[n_outcomes]}
        ]
        bounds = [(0, 1) for _ in range(n_outcomes)] + [(0, None)]
        
        best_result = None
        best_obj = float('inf')
        
        for _ in range(5):
            x0 = np.random.dirichlet(np.ones(n_outcomes)).tolist() + [np.random.uniform(0, 0.001)]
            try:
                result = minimize(objective, x0, method='SLSQP', bounds=bounds, constraints=constraints)
                if result.success and result.fun < best_obj:
                    best_result = result
                    best_obj = result.fun
            except:
                continue
        
        if best_result is not None:
            p = best_result.x[:n_outcomes]
            c = best_result.x[n_outcomes]
            return p / np.sum(p), max(0, c)
        else:
            p = np.random.dirichlet(np.ones(n_outcomes))
            return p, 0.0001
    
    candidate_actions = []
    for i, contract in enumerate(accepted_contracts):
        p, c = infer_action_from_contract(contract, accepted_utilities[i])
        candidate_actions.append(np.concatenate([p, [c]]))
    
    if len(candidate_actions) == 0:
        n_actions = 3
        actions = []
        for i in range(n_actions):
            p = np.random.dirichlet(np.ones(n_outcomes))
            c = np.random.uniform(0, 0.001)
            actions.append(np.concatenate([p, [c]]))
        return np.array(actions)
    
    candidate_actions = np.array(candidate_actions)
    
    if len(candidate_actions) <= 3:
        n_actions = len(candidate_actions)
        unique_actions = candidate_actions
    else:
        n_actions = min(8, len(candidate_actions))
        
        features = candidate_actions[:, :-1]
        if features.shape[1] > 2:
            pca = PCA(n_components=min(3, features.shape[1]))
            features_reduced = pca.fit_transform(features)
        else:
            features_reduced = features
        
        kmeans = KMeans(n_clusters=n_actions, random_state=42, n_init=10)
        cluster_labels = kmeans.fit_predict(features_reduced)
        
        unique_actions = []
        for cluster_id in range(n_actions):
            cluster_mask = cluster_labels == cluster_id
            if np.any(cluster_mask):
                cluster_actions = candidate_actions[cluster_mask]
                centroid_p = np.mean(cluster_actions[:, :-1], axis=0)
                centroid_p = centroid_p / np.sum(centroid_p)
                centroid_c = np.mean(cluster_actions[:, -1])
                unique_actions.append(np.concatenate([centroid_p, [centroid_c]]))
        
        unique_actions = np.array(unique_actions)
    
    for i in range(len(unique_actions)):
        action = unique_actions[i]
        p = action[:-1]
        c = action[-1]
        
        min_required_cost = 0
        for contract in rejected_contracts:
            expected_payment = np.dot(p, contract)
            min_required_cost = max(min_required_cost, expected_payment + 1e-6)
        
        for j, acc_contract in enumerate(accepted_contracts):
            expected_payment = np.dot(p, acc_contract)
            if expected_payment < c:
                min_required_cost = max(min_required_cost, expected_payment - 1e-6)
        
        unique_actions[i, -1] = max(c, min_required_cost)
    
    return unique_actions
```
