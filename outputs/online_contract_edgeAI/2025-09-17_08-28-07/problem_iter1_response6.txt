```python
import numpy as np
import pandas as pd
from scipy.optimize import linprog, minimize
from sklearn.cluster import KMeans
from sklearn.mixture import GaussianMixture

def agent_solver_v2(v: np.ndarray, content: list[dict]) -> np.ndarray:
    n_outcomes = len(v)
    L = len(content)
    
    accepted_logs = [log for log in content if log['Agent Action'] == 1]
    rejected_logs = [log for log in content if log['Agent Action'] == -1]
    
    if not accepted_logs:
        return np.array([[1/n_outcomes] * n_outcomes + [0.001]])
    
    def solve_dual_lp(w, u):
        c = np.concatenate([w, [0]])
        A_ub = np.zeros((n_outcomes + 1, n_outcomes + 1))
        A_ub[:n_outcomes, :n_outcomes] = np.eye(n_outcomes)
        A_ub[:n_outcomes, -1] = -v
        A_ub[n_outcomes, :n_outcomes] = -1
        b_ub = np.concatenate([np.zeros(n_outcomes), [-1]])
        
        A_eq = np.zeros((1, n_outcomes + 1))
        A_eq[0, :n_outcomes] = w
        A_eq[0, -1] = -1
        b_eq = [u]
        
        bounds = [(0, None)] * (n_outcomes + 1)
        
        res = linprog(c, A_ub=A_ub, b_ub=b_ub, A_eq=A_eq, b_eq=b_eq, bounds=bounds, method='highs')
        if res.success:
            p = res.x[:n_outcomes]
            c_val = res.x[-1]
            return p / np.sum(p) if np.sum(p) > 0 else np.ones(n_outcomes) / n_outcomes, max(0, c_val)
        return None, None
    
    candidate_actions = []
    for log in accepted_logs:
        p, c = solve_dual_lp(log['Contract'], log['Principal Utility'])
        if p is not None:
            candidate_actions.append((p, c))
    
    if not candidate_actions:
        return np.array([[1/n_outcomes] * n_outcomes + [0.001]])
    
    ps = np.array([action[0] for action in candidate_actions])
    cs = np.array([action[1] for action in candidate_actions])
    
    n_clusters = min(8, len(ps))
    if len(ps) > 1:
        gmm = GaussianMixture(n_components=n_clusters, random_state=42)
        gmm.fit(ps)
        cluster_centers = gmm.means_
    else:
        cluster_centers = ps
    
    final_actions = []
    for i, p_center in enumerate(cluster_centers):
        p_center = np.abs(p_center)
        p_center = p_center / np.sum(p_center)
        
        max_cost = 0
        for log in accepted_logs:
            w = np.array(log['Contract'])
            expected_payment = np.dot(p_center, w)
            max_cost = max(max_cost, expected_payment)
        
        for log in rejected_logs:
            w = np.array(log['Contract'])
            expected_payment = np.dot(p_center, w)
            max_cost = max(max_cost, expected_payment + 0.0001)
        
        final_actions.append(np.concatenate([p_center, [max_cost]]))
    
    if len(final_actions) == 0:
        return np.array([[1/n_outcomes] * n_outcomes + [0.001]])
    
    result = np.array(final_actions)
    
    def verify_constraints(action_matrix):
        valid = True
        for log in content:
            w = np.array(log['Contract'])
            best_utility = -np.inf
            for row in action_matrix:
                p, c = row[:-1], row[-1]
                utility = np.dot(p, w) - c
                best_utility = max(best_utility, utility)
            
            if log['Agent Action'] == 1 and best_utility < -1e-6:
                valid = False
                break
            if log['Agent Action'] == -1 and best_utility > 1e-6:
                valid = False
                break
        return valid
    
    if not verify_constraints(result):
        uniform_p = np.ones(n_outcomes) / n_outcomes
        min_cost = 0
        for log in rejected_logs:
            w = np.array(log['Contract'])
            expected_payment = np.dot(uniform_p, w)
            min_cost = max(min_cost, expected_payment + 0.0001)
        result = np.array([np.concatenate([uniform_p, [min_cost]])])
    
    return result
```
