```python
import numpy as np
import pandas as pd
from scipy.optimize import linprog, minimize
from sklearn.cluster import KMeans
from sklearn.mixture import GaussianMixture
from itertools import combinations

def agent_solver_v2(v: np.ndarray, content: list[dict]) -> np.ndarray:
    n_outcomes = len(v)
    logs = content
    n_logs = len(logs)
    
    accepted_logs = [log for log in logs if log['Agent Action'] == 1]
    rejected_logs = [log for log in logs if log['Agent Action'] == -1]
    
    if not accepted_logs:
        return np.array([[1/n_outcomes] * n_outcomes + [0.0]] * 3)
    
    accepted_contracts = np.array([log['Contract'] for log in accepted_logs])
    accepted_utilities = np.array([log['Principal Utility'] for log in accepted_logs])
    
    candidate_actions = []
    
    for i, log in enumerate(accepted_logs):
        w = np.array(log['Contract'])
        u = log['Principal Utility']
        
        A_eq = np.array([np.ones(n_outcomes), v - w])
        b_eq = np.array([1.0, u])
        bounds = [(0, 1)] * n_outcomes
        
        res = linprog(-w, A_eq=A_eq, b_eq=b_eq, bounds=bounds, method='highs')
        if res.success:
            p = res.x
            p = np.maximum(p, 0)
            p = p / p.sum()
            candidate_actions.append(p)
    
    if not candidate_actions:
        return np.array([[1/n_outcomes] * n_outcomes + [0.0]] * 3)
    
    candidate_actions = np.array(candidate_actions)
    
    n_clusters = min(8, max(2, len(candidate_actions) // 3))
    
    if len(candidate_actions) >= n_clusters:
        gm = GaussianMixture(n_components=n_clusters, random_state=42)
        gm.fit(candidate_actions)
        cluster_centers = gm.means_
    else:
        cluster_centers = candidate_actions
    
    for center in cluster_centers:
        center = np.maximum(center, 1e-8)
        center = center / center.sum()
    
    n_actions = len(cluster_centers)
    
    assignment_matrix = np.zeros((len(accepted_logs), n_actions))
    for i, w in enumerate(accepted_contracts):
        utilities = cluster_centers @ w
        best_action = np.argmax(utilities)
        assignment_matrix[i, best_action] = 1
    
    costs = np.zeros(n_actions)
    for a in range(n_actions):
        assigned_indices = np.where(assignment_matrix[:, a] == 1)[0]
        if len(assigned_indices) > 0:
            assigned_wages = accepted_contracts[assigned_indices]
            min_utility = np.min(cluster_centers[a] @ assigned_wages.T)
            costs[a] = max(0, min_utility - 1e-6)
    
    if rejected_logs:
        rejected_contracts = np.array([log['Contract'] for log in rejected_logs])
        for a in range(n_actions):
            max_rejected_utility = np.max(cluster_centers[a] @ rejected_contracts.T)
            costs[a] = max(costs[a], max_rejected_utility + 1e-6)
    
    def objective(params):
        p_flat = params[:n_actions * n_outcomes].reshape(n_actions, n_outcomes)
        c = params[n_actions * n_outcomes:]
        
        penalty = 0
        
        for i, log in enumerate(logs):
            w = np.array(log['Contract'])
            action = log['Agent Action']
            
            utilities = p_flat @ w - c
            max_utility = np.max(utilities)
            
            if action == 1 and max_utility < -1e-6:
                penalty += (max_utility + 1e-6) ** 2
            elif action == -1 and max_utility > 1e-6:
                penalty += (max_utility - 1e-6) ** 2
        
        for p_row in p_flat:
            if np.abs(p_row.sum() - 1) > 1e-6:
                penalty += 100 * (p_row.sum() - 1) ** 2
            if np.any(p_row < 0):
                penalty += 100 * np.sum(np.maximum(-p_row, 0) ** 2)
        
        if np.any(c < 0):
            penalty += 100 * np.sum(np.maximum(-c, 0) ** 2)
        
        return penalty
    
    initial_params = np.concatenate([cluster_centers.flatten(), costs])
    
    constraints = []
    for a in range(n_actions):
        start_idx = a * n_outcomes
        end_idx = (a + 1) * n_outcomes
        constraints.append({'type': 'eq', 'fun': lambda x, s=start_idx, e=end_idx: x[s:e].sum() - 1})
    
    bounds = [(0, 1)] * (n_actions * n_outcomes) + [(0, None)] * n_actions
    
    try:
        result = minimize(objective, initial_params, bounds=bounds, constraints=constraints, method='SLSQP')
        if result.success:
            optimized_p = result.x[:n_actions * n_outcomes].reshape(n_actions, n_outcomes)
            optimized_c = result.x[n_actions * n_outcomes:]
        else:
            optimized_p = cluster_centers
            optimized_c = costs
    except:
        optimized_p = cluster_centers
        optimized_c = costs
    
    for i in range(n_actions):
        optimized_p[i] = np.maximum(optimized_p[i], 1e-8)
        optimized_p[i] = optimized_p[i] / optimized_p[i].sum()
    
    optimized_c = np.maximum(optimized_c, 0)
    
    agent_setting = np.hstack([optimized_p, optimized_c.reshape(-1, 1)])
    
    return agent_setting
```
