```python
import numpy as np
from sklearn.cluster import DBSCAN
from scipy.optimize import minimize

def agent_solver(v: np.ndarray, content: list[dict]) -> np.ndarray:
    accepted_logs = [log for log in content if log['Agent Action'] == 1]
    rejected_logs = [log for log in content if log['Agent Action'] == -1]
    
    if not accepted_logs:
        p0 = np.ones((1, len(v))) / len(v)
        c0 = np.zeros((1, 1))
        return np.hstack([p0, c0])
        
    contracts_accepted = np.array([log['Contract'] for log in accepted_logs])
    contracts_rejected = np.array([log['Contract'] for log in rejected_logs]) if rejected_logs else None
    
    def infer_p(w, u):
        m = len(w)
        A_eq = np.vstack([np.ones(m), v - w])
        b_eq = np.array([1.0, u])
        res = minimize(lambda p: np.dot(w, p), np.ones(m)/m, constraints=[{'type': 'eq', 'fun': lambda p: A_eq @ p - b_eq}], bounds=[(0,1)]*m, method='trust-constr')
        if res.success:
            return res.x
        return None
        
    candidate_p = []
    for log in accepted_logs:
        p_candidate = infer_p(np.array(log['Contract']), log['Principal Utility'])
        if p_candidate is not None:
            candidate_p.append(p_candidate)
            
    if not candidate_p:
        p0 = np.ones((1, len(v))) / len(v)
        c0 = np.zeros((1, 1))
        return np.hstack([p0, c0])
        
    candidate_p = np.array(candidate_p)
    
    clustering = DBSCAN(eps=0.05, min_samples=2).fit(candidate_p)
    labels = clustering.labels_
    unique_labels = set(labels)
    if -1 in unique_labels:
        unique_labels.remove(-1)
        
    if not unique_labels:
        p_centroids = [candidate_p.mean(axis=0)]
    else:
        p_centroids = []
        for label in sorted(unique_labels):
            cluster_points = candidate_p[labels == label]
            p_centroids.append(cluster_points.mean(axis=0))
        
    n_actions = len(p_centroids)
    p_matrix = np.array(p_centroids)
    
    def compute_utility(w, p, c):
        return np.dot(p, w) - c
        
    def objective(c_vec):
        penalty = 0.0
        for log in accepted_logs:
            w = np.array(log['Contract'])
            utils = [compute_utility(w, p_matrix[i], c_vec[i]) for i in range(n_actions)]
            max_util = max(utils)
            if max_util < 0:
                penalty += (max_util ** 2) * 1000
            best_action = np.argmax(utils)
            util_best = utils[best_action]
            for i, u in enumerate(utils):
                if i != best_action and u > util_best:
                    penalty += ((u - util_best) ** 2) * 1000
        
        if contracts_rejected is not None:
            for w in contracts_rejected:
                utils = [compute_utility(w, p_matrix[i], c_vec[i]) for i in range(n_actions)]
                max_util = max(utils)
                if max_util >= 0:
                    penalty += (max_util ** 2) * 1000
                    
        return penalty
        
    initial_c = np.zeros(n_actions)
    bounds = [(0, None)] * n_actions
    res = minimize(objective, initial_c, bounds=bounds, method='L-BFGS-B', options={'maxiter': 1000})
    c_optimized = res.x
    
    agent_setting = np.hstack([p_matrix, c_optimized.reshape(-1, 1)])
    return agent_setting
```
