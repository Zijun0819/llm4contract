```python
import numpy as np
import pandas as pd
from sklearn.mixture import BayesianGaussianMixture

def agent_solver(v: np.ndarray, content: list[dict]) -> np.ndarray:
    m_outcomes = 12
    logs_df = pd.DataFrame(content)
    accepted_logs = logs_df[logs_df['Agent Action'] == 1].copy()
    rejected_logs = logs_df[logs_df['Agent Action'] == -1].copy()
    
    if len(accepted_logs) == 0:
        p0 = np.ones(m_outcomes) / m_outcomes
        return np.hstack([p0, 0.0]).reshape(1, -1)
    
    accepted_contracts = np.array(accepted_logs['Contract'].tolist())
    rejected_contracts = np.array(rejected_logs['Contract'].tolist()) if len(rejected_logs) > 0 else np.array([]).reshape(0, m_outcomes)
    
    utility_gaps = []
    for _, row in accepted_logs.iterrows():
        contract = np.array(row['Contract'])
        if row['Principal Utility'] > 0:
            gap = np.max(contract) - np.min(contract)
            utility_gaps.append(gap)
        else:
            utility_gaps.append(0.0)
    
    eps = np.percentile(utility_gaps, 10) if len(utility_gaps) > 0 else 1e-5
    
    candidate_actions = []
    for _, row in accepted_logs.iterrows():
        contract = np.array(row['Contract'])
        agent_util = contract @ (np.ones(m_outcomes) / m_outcomes)
        cost_estimate = agent_util - eps
        if cost_estimate < 0:
            cost_estimate = 0
        for _ in range(100):
            p_grad = contract - cost_estimate
            p = np.maximum(p_grad, 0)
            if np.sum(p) > 0:
                p /= np.sum(p)
            else:
                p = np.ones(m_outcomes) / m_outcomes
            candidate_actions.append(p)
            new_agent_util = p @ contract
            if abs(new_agent_util - cost_estimate) < 1e-6:
                break
            cost_estimate = new_agent_util - eps
            if cost_estimate < 0:
                cost_estimate = 0
    
    candidate_actions = np.array(candidate_actions)
    if len(candidate_actions) == 0:
        p0 = np.ones(m_outcomes) / m_outcomes
        return np.hstack([p0, 0.0]).reshape(1, -1)
    
    n_candidates = min(max(int(np.sqrt(len(candidate_actions))), 3), 15)
    bgm = BayesianGaussianMixture(n_components=n_candidates, random_state=42, max_iter=1000, n_init=3).fit(candidate_actions)
    cluster_centers = bgm.means_
    n_clusters = cluster_centers.shape[0]
    
    costs = np.zeros(n_clusters)
    for a in range(n_clusters):
        p = cluster_centers[a]
        if rejected_contracts.size > 0:
            rej_utils = rejected_contracts @ p
            max_rej_util = np.max(rej_utils)
        else:
            max_rej_util = -np.inf
        
        if accepted_contracts.size > 0:
            acc_utils = accepted_contracts @ p
            min_acc_util = np.min(acc_utils)
        else:
            min_acc_util = np.inf
        
        if max_rej_util >= min_acc_util - eps:
            costs[a] = max_rej_util + eps
        else:
            costs[a] = min_acc_util - eps
        
        costs[a] = max(costs[a], 0.0)
    
    agent_setting = np.hstack([cluster_centers, costs.reshape(-1, 1)])
    return agent_setting
```
