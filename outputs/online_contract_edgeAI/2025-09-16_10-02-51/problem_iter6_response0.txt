```python
import numpy as np
import pandas as pd
from sklearn.mixture import BayesianGaussianMixture
from scipy.optimize import minimize, Bounds

def agent_solver(v: np.ndarray, content: list[dict]) -> np.ndarray:
    n_outcomes = 12
    logs_df = pd.DataFrame(content)
    accepted_logs = logs_df[logs_df['Agent Action'] == 1].copy()
    rejected_logs = logs_df[logs_df['Agent Action'] == -1].copy()
    
    if len(accepted_logs) == 0:
        p0 = np.ones(n_outcomes) / n_outcomes
        return np.hstack([p0, [0.0]]).reshape(1, -1)
    
    accepted_contracts = np.array(accepted_logs['Contract'].tolist())
    rejected_contracts = np.array(rejected_logs['Contract'].tolist()) if len(rejected_logs) > 0 else np.array([]).reshape(0, n_outcomes)
    
    utility_gaps = []
    for idx, row in accepted_logs.iterrows():
        contract = np.array(row['Contract'])
        if row['Principal Utility'] > 0:
            gap = np.max(contract) - np.min(contract)
            utility_gaps.append(gap)
        else:
            utility_gaps.append(0.0)
    
    eps = np.percentile(utility_gaps, 10) if len(utility_gaps) > 0 and np.percentile(utility_gaps, 10) > 0 else 1e-5
    
    candidate_actions = []
    for _, row in accepted_logs.iterrows():
        contract = np.array(row['Contract'])
        p = np.ones(n_outcomes) / n_outcomes
        for _ in range(100):
            agent_util = np.dot(p, contract)
            cost_estimate = max(agent_util - eps, 0)
            p_grad = contract - cost_estimate
            p = p + 0.01 * p_grad
            p = np.maximum(p, 0)
            p /= p.sum() + 1e-10
            if np.linalg.norm(p_grad) < 1e-6:
                break
        candidate_actions.append(p)
    
    X = np.array(candidate_actions)
    n_candidates = min(max(int(np.sqrt(len(accepted_logs))), 3), 15)
    bgm = BayesianGaussianMixture(n_components=n_candidates, random_state=42, max_iter=1000, n_init=3).fit(X)
    labels = bgm.predict(X)
    cluster_centers = bgm.means_
    
    unique_labels = np.unique(labels)
    cluster_centers = cluster_centers[unique_labels]
    n_clusters = len(unique_labels)
    
    costs = np.zeros(n_clusters)
    for a in range(n_clusters):
        cluster_mask = (labels == unique_labels[a])
        contracts_in_cluster = accepted_contracts[cluster_mask]
        if len(contracts_in_cluster) > 0:
            agent_utils = contracts_in_cluster @ cluster_centers[a]
            costs[a] = np.max(agent_utils) - eps
        else:
            costs[a] = 0.0
    
    if len(rejected_contracts) > 0:
        rej_utils = rejected_contracts @ cluster_centers.T
        for a in range(n_clusters):
            max_rej_util = np.max(rej_utils[:, a]) if rej_utils.size > 0 else -np.inf
            if max_rej_util + 2 * eps > costs[a]:
                costs[a] = max_rej_util + 2 * eps
    
    costs = np.maximum(costs, 0)
    
    agent_setting = np.hstack([cluster_centers, costs.reshape(-1, 1)])
    return agent_setting
```
