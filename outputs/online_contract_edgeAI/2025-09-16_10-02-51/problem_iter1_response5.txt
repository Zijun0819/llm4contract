```python
import numpy as np
import pandas as pd
from scipy.optimize import linprog, minimize, Bounds, LinearConstraint
from sklearn.cluster import KMeans, DBSCAN
from sklearn.mixture import GaussianMixture
from sklearn.metrics import pairwise_distances_argmin_min

def agent_solver(v: np.ndarray, content: list) -> np.ndarray:
    m = len(v)
    n_logs = len(content)
    accepted_logs = [log for log in content if log['Agent Action'] == 1]
    rejected_logs = [log for log in content if log['Agent Action'] == -1]
    
    if not accepted_logs:
        p0 = np.ones((1, m)) / m
        c0 = np.array([[0.0]])
        return np.hstack([p0, c0])
    
    def infer_p_strategy(w, u):
        A_eq = np.vstack([np.ones(m), v - w])
        b_eq = np.array([1.0, u])
        res = linprog(w, A_eq=A_eq, b_eq=b_eq, bounds=[(0,1)]*m, method='highs')
        return res.x if res.success else None
    
    p_candidates = []
    for log in accepted_logs:
        p_est = infer_p_strategy(log['Contract'], log['Principal Utility'])
        if p_est is not None:
            p_candidates.append(p_est)
    
    if not p_candidates:
        p0 = np.ones((1, m)) / m
        c0 = np.array([[0.0]])
        return np.hstack([p0, c0])
    
    X = np.array(p_candidates)
    
    def determine_n_clusters(X):
        n_range = range(1, min(11, len(X)+1))
        bics = []
        for n in n_range:
            gmm = GaussianMixture(n_components=n, random_state=0, n_init=3)
            gmm.fit(X)
            bics.append(gmm.bic(X))
        best_n = n_range[np.argmin(bics)]
        return min(best_n, 10)
    
    n_clusters = determine_n_clusters(X)
    gmm = GaussianMixture(n_components=n_clusters, random_state=0, n_init=10)
    gmm.fit(X)
    p_centers = gmm.means_
    
    assignments = {}
    for log in accepted_logs:
        w = np.array(log['Contract'])
        utilities = p_centers @ w
        best_action = np.argmax(utilities)
        if best_action not in assignments:
            assignments[best_action] = []
        assignments[best_action].append((w, log['Principal Utility']))
    
    c_values = np.zeros(n_clusters)
    for a in range(n_clusters):
        if a in assignments and assignments[a]:
            wages = np.array([w for w, _ in assignments[a]])
            min_wages = wages.min(axis=0)
            c_values[a] = max(0, p_centers[a] @ min_wages)
        else:
            c_values[a] = 0.0
    
    if rejected_logs:
        rej_wages = np.array([log['Contract'] for log in rejected_logs])
        rej_utils = rej_wages @ p_centers.T
        c_rej = rej_utils.max(axis=0)
        c_values = np.maximum(c_values, c_rej)
    
    active_actions = np.where(c_values > -np.inf)[0]
    p_final = p_centers[active_actions]
    c_final = c_values[active_actions].reshape(-1, 1)
    
    agent_setting = np.hstack([p_final, c_final])
    return agent_setting
```
