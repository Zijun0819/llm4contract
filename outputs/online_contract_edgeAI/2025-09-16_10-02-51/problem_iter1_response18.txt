```python
import numpy as np
from scipy.optimize import linprog, minimize, LinearConstraint
from sklearn.cluster import KMeans
from sklearn.preprocessing import normalize

def agent_solver(v, content):
    n_actions = 8
    outcomes = len(v)
    
    accepted_logs = [log for log in content if log['Agent Action'] == 1]
    rejected_logs = [log for log in content if log['Agent Action'] == -1]
    
    if not accepted_logs:
        return np.zeros((1, outcomes + 1))
    
    contract_mat = np.array([log['Contract'] for log in accepted_logs])
    principal_utils = np.array([log['Principal Utility'] for log in accepted_logs])
    
    inferred_probs = []
    for i, (w, u) in enumerate(zip(contract_mat, principal_utils)):
        def objective(p):
            return np.sum(p * w)
        constraints = [
            LinearConstraint([np.ones(outcomes), v - w], [1, u], [1, u]),
            LinearConstraint(np.eye(outcomes), np.zeros(outcomes), np.ones(outcomes))
        ]
        result = minimize(objective, np.ones(outcomes)/outcomes, constraints=constraints, method='trust-constr', options={'maxiter': 100})
        if result.success:
            inferred_probs.append(result.x)
    
    if not inferred_probs:
        inferred_probs = KMeans(n_clusters=n_actions, random_state=0, n_init=10).fit(contract_mat).cluster_centers_
        inferred_probs = normalize(inferred_probs, norm='l1', axis=1)
    else:
        inferred_probs = np.array(inferred_probs)
        kmeans = KMeans(n_clusters=n_actions, random_state=0, n_init=10).fit(inferred_probs)
        inferred_probs = kmeans.cluster_centers_
    
    action_assignments = []
    for log in accepted_logs:
        w = log['Contract']
        utilities = inferred_probs @ w
        action_assignments.append(np.argmax(utilities))
    
    costs = np.zeros(n_actions)
    for a in range(n_actions):
        indices = [i for i, act in enumerate(action_assignments) if act == a]
        if indices:
            relevant_wages = np.array([accepted_logs[i]['Contract'] for i in indices])
            min_utility = np.min(inferred_probs[a] @ relevant_wages.T)
            costs[a] = min_utility
        else:
            costs[a] = 0.0
    
    if rejected_logs:
        rejected_wages = np.array([log['Contract'] for log in rejected_logs]).T
        rejection_utilities = inferred_probs @ rejected_wages
        max_reject_utils = np.max(rejection_utilities, axis=1)
        costs = np.maximum(costs, max_reject_utils)
    
    agent_setting = np.hstack([inferred_probs, costs.reshape(-1, 1)])
    return agent_setting
```
