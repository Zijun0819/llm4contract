```python
import numpy as np
from scipy.optimize import linprog, minimize
from sklearn.cluster import DBSCAN

def agent_solver(v, content):
    accepted_logs = [log for log in content if log['Agent Action'] == 1]
    rejected_logs = [log for log in content if log['Agent Action'] == -1]
    
    if not accepted_logs:
        return np.zeros((1, 13))
        
    contracts_accepted = np.array([log['Contract'] for log in accepted_logs])
    contracts_rejected = np.array([log['Contract'] for log in rejected_logs]) if rejected_logs else None
    
    def infer_p(w, u):
        m = len(w)
        res = linprog(w, A_eq=[np.ones(m), v - w], b_eq=[1.0, u], bounds=[(0,1)]*m, method='highs')
        return res.x if res.success else None
        
    candidate_p = []
    for log in accepted_logs:
        p_candidate = infer_p(np.array(log['Contract']), log['Principal Utility'])
        if p_candidate is not None:
            candidate_p.append(p_candidate)
            
    if not candidate_p:
        return np.zeros((1, 13))
        
    candidate_p = np.array(candidate_p)
    
    clustering = DBSCAN(eps=0.05, min_samples=2).fit(candidate_p)
    labels = clustering.labels_
    unique_labels = set(labels)
    if -1 in unique_labels:
        unique_labels.remove(-1)
        
    if not unique_labels:
        p_centroids = [candidate_p.mean(axis=0)]
    else:
        p_centroids = []
        for label in unique_labels:
            cluster_points = candidate_p[labels == label]
            p_centroids.append(cluster_points.mean(axis=0))
        
    n_actions = len(p_centroids)
    p_matrix = np.array(p_centroids)
    
    def compute_utility(w, p, c):
        return np.dot(p, w) - c
        
    def objective(c_vec):
        penalty = 0
        for log in accepted_logs:
            w = np.array(log['Contract'])
            utils = [compute_utility(w, p_matrix[i], c_vec[i]) for i in range(n_actions)]
            max_util = max(utils)
            if max_util < 0:
                penalty += (max_util ** 2) * 100
            best_action = np.argmax(utils)
            util_best = utils[best_action]
            other_utils = [u for i, u in enumerate(utils) if i != best_action]
            for u_other in other_utils:
                if u_other > util_best:
                    penalty += ((u_other - util_best) ** 2) * 100
                    
        if contracts_rejected is not None:
            for w in contracts_rejected:
                utils = [compute_utility(w, p_matrix[i], c_vec[i]) for i in range(n_actions)]
                max_util = max(utils)
                if max_util >= 0:
                    penalty += (max_util ** 2) * 100
                    
        return penalty
        
    initial_c = np.zeros(n_actions)
    bounds = [(0, None)] * n_actions
    res = minimize(objective, initial_c, bounds=bounds, method='L-BFGS-B')
    c_optimized = res.x
    
    agent_setting = np.hstack((p_matrix, c_optimized.reshape(-1, 1)))
    return agent_setting
```
