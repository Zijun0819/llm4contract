```python
import numpy as np
from scipy.optimize import minimize, LinearConstraint, Bounds
from sklearn.cluster import KMeans
from sklearn.preprocessing import StandardScaler

def agent_solver(v: np.ndarray, content: list[dict]) -> np.ndarray:
    n_outcomes = len(v)
    
    accepted_logs = [log for log in content if log['Agent Action'] == 1]
    rejected_logs = [log for log in content if log['Agent Action'] == -1]
    
    if not content:
        p0 = np.ones(n_outcomes) / n_outcomes
        return np.hstack([p0, [0.0]]).reshape(1, -1)
    
    accepted_contracts = np.array([log['Contract'] for log in accepted_logs])
    accepted_putils = np.array([log['Principal Utility'] for log in accepted_logs])
    
    inferred_probs = []
    for i, w in enumerate(accepted_contracts):
        if accepted_putils[i] > 0:
            def neg_agent_util(p):
                return -np.dot(p, w)
            
            constraints = [
                LinearConstraint(np.ones((1, n_outcomes)), [1], [1]),
                LinearConstraint(v - w, [accepted_putils[i]], [accepted_putils[i]])
            ]
            bounds = Bounds(0, 1)
            res = minimize(neg_agent_util, np.ones(n_outcomes)/n_outcomes, 
                          constraints=constraints, bounds=bounds, method='trust-constr')
            if res.success:
                inferred_probs.append(res.x)
    
    if not inferred_probs:
        p0 = np.ones(n_outcomes) / n_outcomes
        inferred_probs = [p0]
    
    prob_array = np.array(inferred_probs)
    n_candidates = min(10, len(inferred_probs), 5)
    
    if n_candidates > 1:
        scaler = StandardScaler()
        scaled_probs = scaler.fit_transform(prob_array)
        kmeans = KMeans(n_clusters=n_candidates, random_state=42, n_init=10)
        labels = kmeans.fit_predict(scaled_probs)
        centroids = scaler.inverse_transform(kmeans.cluster_centers_)
        centroids = np.maximum(centroids, 0)
        centroids /= centroids.sum(axis=1, keepdims=True)
        n_actions = centroids.shape[0]
    else:
        centroids = np.mean(prob_array, axis=0, keepdims=True)
        n_actions = 1
    
    cost_lb = np.zeros(n_actions)
    for a in range(n_actions):
        p_a = centroids[a]
        min_util = np.inf
        for w in accepted_contracts:
            agent_util = p_a @ w
            if agent_util >= 0:
                min_util = min(min_util, agent_util)
        cost_lb[a] = max(0, min_util) if min_util != np.inf else 0.0
    
    for log in rejected_logs:
        w = np.array(log['Contract'])
        for a in range(n_actions):
            agent_util = centroids[a] @ w
            if agent_util >= cost_lb[a]:
                cost_lb[a] = agent_util + 1e-8
    
    def objective(costs):
        penalty = 0.0
        for log in content:
            w = np.array(log['Contract'])
            agent_utils = np.array([centroids[a] @ w - costs[a] for a in range(n_actions)])
            max_util = np.max(agent_utils)
            if log['Agent Action'] == 1:
                if max_util < -1e-8:
                    penalty += 1e6 * (-max_util)
                best_action = np.argmax(agent_utils)
                for a in range(n_actions):
                    if a != best_action and agent_utils[a] > max_util - 1e-6:
                        penalty += 1e4 * (max_util - agent_utils[a])
            else:
                if max_util >= -1e-8:
                    penalty += 1e6 * (max_util + 1e-8)
        return penalty
    
    bounds = Bounds(cost_lb, np.inf)
    constraints = [{'type': 'ineq', 'fun': lambda x: x - cost_lb}]
    res = minimize(objective, cost_lb, method='SLSQP', bounds=bounds, constraints=constraints, 
                  options={'maxiter': 1000, 'ftol': 1e-12})
    
    final_costs = res.x if res.success else cost_lb
    final_costs = np.maximum(final_costs, 0)
    
    return np.hstack([centroids, final_costs.reshape(-1, 1)])
```
