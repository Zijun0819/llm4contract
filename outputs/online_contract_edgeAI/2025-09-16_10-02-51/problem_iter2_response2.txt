```python
import numpy as np
from scipy.optimize import minimize
from sklearn.cluster import KMeans

def agent_solver(v: np.ndarray, content: list[dict]) -> np.ndarray:
    np.random.seed(42)
    contracts = np.array([log['Contract'] for log in content])
    actions = np.array([log['Agent Action'] for log in content])
    accepted_idx = np.where(actions == 1)[0]
    rejected_idx = np.where(actions == -1)[0]
    accepted_contracts = contracts[accepted_idx]
    
    def infer_probability(contract, principal_util):
        constraints = [
            {'type': 'eq', 'fun': lambda p: np.sum(p) - 1},
            {'type': 'eq', 'fun': lambda p: np.dot(p, v) - principal_util},
            {'type': 'ineq', 'fun': lambda p: p}
        ]
        result = minimize(
            lambda p: -np.dot(p, contract),
            x0=np.ones(12)/12,
            constraints=constraints,
            bounds=[(0, 1)] * 12,
            method='SLSQP',
            options={'maxiter': 100}
        )
        return result.x if result.success else None

    inferred_probs = []
    for i in accepted_idx:
        p = infer_probability(contracts[i], content[i]['Principal Utility'])
        if p is not None:
            inferred_probs.append(p)
    
    if not inferred_probs:
        kmeans = KMeans(n_clusters=min(5, len(accepted_contracts)), random_state=42, n_init=10)
        kmeans.fit(accepted_contracts)
        inferred_probs = kmeans.cluster_centers_
        inferred_probs = inferred_probs / inferred_probs.sum(axis=1, keepdims=True)
    else:
        inferred_probs = np.array(inferred_probs)
        kmeans = KMeans(n_clusters=min(5, len(inferred_probs)), random_state=42, n_init=10)
        kmeans.fit(inferred_probs)
        inferred_probs = kmeans.cluster_centers_
    
    n_actions = inferred_probs.shape[0]
    
    cost_lower_bounds = np.zeros(n_actions)
    for a in range(n_actions):
        assigned_utils = []
        for i in accepted_idx:
            util = np.dot(inferred_probs[a], contracts[i])
            if util >= 0:
                assigned_utils.append(util)
        cost_lower_bounds[a] = min(assigned_utils) if assigned_utils else 0
    
    cost_upper_bounds = np.full(n_actions, np.inf)
    for i in rejected_idx:
        for a in range(n_actions):
            util = np.dot(inferred_probs[a], contracts[i])
            if util < cost_upper_bounds[a]:
                cost_upper_bounds[a] = util
    
    final_costs = np.zeros(n_actions)
    for a in range(n_actions):
        if cost_lower_bounds[a] <= cost_upper_bounds[a]:
            final_costs[a] = cost_lower_bounds[a]
        else:
            final_costs[a] = (cost_lower_bounds[a] + cost_upper_bounds[a]) / 2
    
    agent_setting = np.hstack([inferred_probs, final_costs.reshape(-1, 1)])
    return agent_setting
```
