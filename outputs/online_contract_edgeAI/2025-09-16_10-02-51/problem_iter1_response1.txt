```python
import numpy as np
import pandas as pd
from scipy.optimize import linprog, minimize, Bounds
from sklearn.cluster import KMeans, MiniBatchKMeans
from sklearn.mixture import GaussianMixture
from sklearn.metrics import pairwise_distances_argmin_min

def agent_solver(v: np.ndarray, content: list) -> np.ndarray:
    n_actions = 5
    m_outcomes = len(v)
    
    accepted_logs = [log for log in content if log['Agent Action'] == 1]
    rejected_logs = [log for log in content if log['Agent Action'] == -1]
    
    def compute_strategy_potential(w, u_target):
        def obj(p):
            return -np.sum(p * w)
        cons = [{'type': 'eq', 'fun': lambda p: np.sum(p) - 1},
                {'type': 'eq', 'fun': lambda p: np.sum(p * v) - u_target}]
        bounds = Bounds(0, 1)
        res = minimize(obj, np.ones(m_outcomes)/m_outcomes, method='SLSQP', constraints=cons, bounds=bounds)
        return res.x if res.success else None
    
    candidate_ps = []
    for log in accepted_logs:
        p_candidate = compute_strategy_potential(log['Contract'], log['Principal Utility'])
        if p_candidate is not None:
            candidate_ps.append(p_candidate)
    
    if not candidate_ps:
        candidate_ps = [np.ones(m_outcomes)/m_outcomes]
    
    all_p = np.array(candidate_ps)
    
    if len(all_p) > n_actions:
        kmeans = KMeans(n_clusters=n_actions, random_state=42, n_init=10).fit(all_p)
        p_centers = kmeans.cluster_centers_
    else:
        p_centers = all_p
    
    action_cost = np.zeros(n_actions)
    for a in range(n_actions):
        action_contracts = []
        for log in accepted_logs:
            p_candidate = compute_strategy_potential(log['Contract'], log['Principal Utility'])
            if p_candidate is not None:
                dist = np.linalg.norm(p_candidate - p_centers[a])
                if dist < 0.1:
                    action_contracts.append(log['Contract'])
        if action_contracts:
            min_utility = min(np.dot(p_centers[a], w) for w in action_contracts)
            action_cost[a] = max(min_utility, 0)
    
    for log in rejected_logs:
        w_rej = log['Contract']
        for a in range(n_actions):
            if np.dot(p_centers[a], w_rej) >= action_cost[a]:
                action_cost[a] = np.dot(p_centers[a], w_rej) + 1e-6
    
    agent_matrix = np.hstack([p_centers, action_cost.reshape(-1, 1)])
    return agent_matrix
```
