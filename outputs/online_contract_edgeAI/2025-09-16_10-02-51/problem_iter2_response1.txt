```python
import numpy as np
from scipy.optimize import linprog
from sklearn.mixture import GaussianMixture
from scipy.spatial.distance import cdist

def agent_solver(v: np.ndarray, content: list) -> np.ndarray:
    n_outcomes = len(v)
    accepted_logs = [log for log in content if log['Agent Action'] == 1]
    rejected_logs = [log for log in content if log['Agent Action'] == -1]
    
    if not accepted_logs:
        uniform_p = np.ones(n_outcomes) / n_outcomes
        return np.hstack([uniform_p.reshape(1, -1), np.zeros((1, 1))])
    
    contracts = np.array([log['Contract'] for log in accepted_logs])
    principal_utils = np.array([log['Principal Utility'] for log in accepted_logs])
    
    def infer_probabilities(w, u_target):
        if u_target <= 0:
            return None
        res = linprog(-w, A_eq=[np.ones(n_outcomes), v - w],
                      b_eq=[1, u_target], bounds=[(0, 1)] * n_outcomes, method='highs')
        return res.x if res.success else None
    
    inferred_ps = []
    for i in range(len(accepted_logs)):
        p = infer_probabilities(contracts[i], principal_utils[i])
        if p is not None:
            inferred_ps.append(p)
    
    if not inferred_ps:
        uniform_p = np.ones(n_outcomes) / n_outcomes
        min_util = min(np.min(w) for w in contracts) if len(contracts) > 0 else 0.0
        return np.hstack([uniform_p.reshape(1, -1), np.array([[min_util]])])
    
    inferred_ps = np.array(inferred_ps)
    n_samples = len(inferred_ps)
    max_clusters = min(10, n_samples // 2)
    max_clusters = max(1, max_clusters)
    
    best_bic = np.inf
    best_gmm = None
    
    for n_components in range(1, max_clusters + 1):
        if n_samples < n_components:
            continue
        gmm = GaussianMixture(n_components=n_components, random_state=0, n_init=3)
        gmm.fit(inferred_ps)
        bic = gmm.bic(inferred_ps)
        if bic < best_bic:
            best_bic = bic
            best_gmm = gmm
    
    if best_gmm is None:
        best_gmm = GaussianMixture(n_components=1, random_state=0).fit(inferred_ps)
    
    centers = best_gmm.means_
    n_actions = centers.shape[0]
    
    action_assignments = []
    for w in contracts:
        utils = centers @ w
        action_assignments.append(np.argmax(utils))
    action_assignments = np.array(action_assignments)
    
    costs = np.zeros(n_actions)
    for a in range(n_actions):
        mask = (action_assignments == a)
        if np.any(mask):
            min_util = np.min(centers[a] @ contracts[mask].T)
            costs[a] = min_util
        else:
            costs[a] = 0.0
    
    if rejected_logs:
        rej_contracts = np.array([log['Contract'] for log in rejected_logs])
        for a in range(n_actions):
            rej_utils = centers[a] @ rej_contracts.T
            max_rej_util = np.max(rej_utils)
            if max_rej_util >= costs[a]:
                costs[a] = max_rej_util + 1e-8
    
    costs = np.maximum(costs, 0)
    return np.hstack([centers, costs.reshape(-1, 1)])
```
