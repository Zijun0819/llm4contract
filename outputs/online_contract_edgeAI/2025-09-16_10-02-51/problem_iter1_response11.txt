```python
import numpy as np
from scipy.optimize import linprog, minimize
from sklearn.cluster import KMeans
from scipy.spatial.distance import cdist

def agent_solver(v, content):
    def compute_agent_utility(w, p, c):
        return p @ w - c
    
    n_candidates = 12
    m_outcomes = len(v)
    L = len(content)
    accepted_logs = [log for log in content if log['Agent Action'] == 1]
    rejected_logs = [log for log in content if log['Agent Action'] == -1]
    
    if not accepted_logs:
        return np.zeros((1, m_outcomes + 1))
    
    accepted_contracts = np.array([log['Contract'] for log in accepted_logs])
    principal_utils = np.array([log['Principal Utility'] for log in accepted_logs])
    n_accepted = len(accepted_logs)
    
    candidate_p = []
    for i in range(n_accepted):
        w_i = accepted_contracts[i]
        u_i = principal_utils[i]
        c = linprog(-w_i, A_eq=[np.ones(m_outcomes), v - w_i], b_eq=[1, u_i], bounds=[(0, 1)]*m_outcomes, method='highs')
        if c.success:
            p_i = c.x
            candidate_p.append(p_i)
    
    candidate_p = np.array(candidate_p)
    kmeans = KMeans(n_clusters=n_candidates, random_state=0, n_init=10).fit(candidate_p)
    p_centers = kmeans.cluster_centers_
    
    assignments = []
    for log in accepted_logs:
        w = log['Contract']
        utils = [p @ w for p in p_centers]
        assignments.append(np.argmax(utils))
    assignments = np.array(assignments)
    
    c_values = np.zeros(n_candidates)
    for a in range(n_candidates):
        idxs = np.where(assignments == a)[0]
        if len(idxs) > 0:
            contracts = accepted_contracts[idxs]
            min_utils = np.min([p_centers[a] @ w for w in contracts])
            c_values[a] = min_utils
        else:
            c_values[a] = 0
    
    if rejected_logs:
        rejected_contracts = np.array([log['Contract'] for log in rejected_logs])
        for a in range(n_candidates):
            rej_utils = [p_centers[a] @ w for w in rejected_contracts]
            max_rej_util = np.max(rej_utils)
            c_values[a] = max(c_values[a], max_rej_util)
    
    for a in range(n_candidates):
        all_contracts = np.array([log['Contract'] for log in content])
        agent_utils = p_centers[a] @ all_contracts.T - c_values[a]
        for i, log in enumerate(content):
            if log['Agent Action'] == 1 and agent_utils[i] < 0:
                c_values[a] = min(c_values[a], p_centers[a] @ log['Contract'])
            if log['Agent Action'] == -1 and agent_utils[i] >= 0:
                c_values[a] = max(c_values[a], p_centers[a] @ log['Contract'])
    
    refined_p = np.copy(p_centers)
    refined_c = np.copy(c_values)
    for a in range(n_candidates):
        idxs = np.where(assignments == a)[0]
        if len(idxs) > 0:
            def loss(x):
                p, c = x[:-1], x[-1]
                total_loss = 0
                u_agent = p @ accepted_contracts[idxs].T - c
                total_loss += np.sum(np.maximum(0, -u_agent))
                if rejected_logs:
                    u_rej = p @ rejected_contracts.T - c
                    total_loss += np.sum(np.maximum(0, u_rej))
                return total_loss
            
            x0 = np.concatenate([p_centers[a], [c_values[a]]])
            bounds = [(0, 1)] * m_outcomes + [(0, None)]
            cons = [{'type': 'eq', 'fun': lambda x: np.sum(x[:m_outcomes]) - 1}]
            res = minimize(loss, x0, bounds=bounds, constraints=cons, method='SLSQP')
            if res.success:
                refined_p[a] = res.x[:m_outcomes]
                refined_c[a] = res.x[-1]
    
    agent_setting = np.hstack([refined_p, refined_c.reshape(-1, 1)])
    return agent_setting
```
