```python
import numpy as np
from scipy.optimize import minimize, Bounds, LinearConstraint, NonlinearConstraint
from scipy.optimize import linprog
from sklearn.mixture import GaussianMixture
from sklearn.cluster import KMeans
from scipy.spatial.distance import cdist
import warnings
warnings.filterwarnings('ignore')

def agent_solver_v2(v: np.ndarray, content: list[dict]) -> np.ndarray:
    m_outcomes = len(v)
    accepted_logs = [log for log in content if log['Agent Action'] == 1]
    rejected_logs = [log for log in content if log['Agent Action'] == -1]
    
    if not accepted_logs and not rejected_logs:
        return np.zeros((1, m_outcomes + 1))
    
    accepted_contracts = np.array([log['Contract'] for log in accepted_logs])
    accepted_utils = np.array([log['Principal Utility'] for log in accepted_logs])
    
    p_list = []
    for i, w in enumerate(accepted_contracts):
        u_p = accepted_utils[i]
        c = -w
        A_eq = np.vstack([np.ones(m_outcomes), v])
        b_eq = np.array([1, u_p])
        bounds = [(0, 1)] * m_outcomes
        res = linprog(c, A_eq=A_eq, b_eq=b_eq, bounds=bounds, method='highs')
        if res.success:
            p_list.append(res.x)
    
    if not p_list:
        p_list = [np.ones(m_outcomes) / m_outcomes]
    
    p_array = np.array(p_list)
    n_candidates = min(12, len(p_list))
    if n_candidates > 0:
        kmeans = KMeans(n_clusters=n_candidates, random_state=42, n_init=10)
        kmeans.fit(p_array)
        p_centroids = kmeans.cluster_centers_
        p_centroids = np.clip(p_centroids, 0, 1)
        p_centroids /= p_centroids.sum(axis=1, keepdims=True)
    else:
        p_centroids = np.ones((1, m_outcomes)) / m_outcomes
    
    n_actions = len(p_centroids)
    
    cost_lb = np.zeros(n_actions)
    cost_ub = np.full(n_actions, np.inf)
    epsilon = 1e-6
    
    for a in range(n_actions):
        p_a = p_centroids[a]
        min_accept_util = np.inf
        for log in accepted_logs:
            w = np.array(log['Contract'])
            agent_util = np.dot(p_a, w)
            if agent_util >= 0:
                min_accept_util = min(min_accept_util, agent_util)
        if min_accept_util != np.inf:
            cost_lb[a] = max(0, min_accept_util - epsilon)
        
        max_reject_util = -np.inf
        for log in rejected_logs:
            w = np.array(log['Contract'])
            agent_util = np.dot(p_a, w)
            if agent_util < 0:
                max_reject_util = max(max_reject_util, agent_util)
        if max_reject_util != -np.inf:
            cost_ub[a] = max(0, max_reject_util + epsilon)
    
    bounds = Bounds(cost_lb, cost_ub)
    
    def objective(costs):
        total_violation = 0.0
        penalty_weight = 100.0
        for log in content:
            w = np.array(log['Contract'])
            agent_utils = np.array([np.dot(p_centroids[a], w) - costs[a] for a in range(n_actions)])
            max_util = np.max(agent_utils)
            best_action = np.argmax(agent_utils)
            if log['Agent Action'] == 1:
                if max_util < -epsilon:
                    total_violation += penalty_weight * (-max_util)
                for a in range(n_actions):
                    if a != best_action and agent_utils[a] > agent_utils[best_action] + epsilon:
                        total_violation += penalty_weight * (agent_utils[a] - agent_utils[best_action])
            else:
                if max_util >= -epsilon:
                    total_violation += penalty_weight * (max_util + epsilon)
        return total_violation
    
    constraints = []
    for a in range(n_actions):
        for b in range(n_actions):
            if a != b:
                def ic_constraint(costs, a=a, b=b):
                    w_diff = np.array([np.dot(p_centroids[a], w) - np.dot(p_centroids[b], w) for w in accepted_contracts])
                    return np.min(w_diff) - (costs[a] - costs[b])
                constraints.append(NonlinearConstraint(ic_constraint, -np.inf, 0))
    
    initial_costs = (cost_lb + cost_ub) / 2
    initial_costs = np.clip(initial_costs, cost_lb, cost_ub)
    
    res = minimize(objective, initial_costs, method='trust-constr', bounds=bounds, constraints=constraints, options={'maxiter': 1000, 'verbose': 0})
    if not res.success:
        res = minimize(objective, cost_lb, method='SLSQP', bounds=bounds, constraints=constraints, options={'maxiter': 1000})
    
    final_costs = res.x if res.success else cost_lb
    
    agent_setting = np.hstack([p_centroids, final_costs.reshape(-1, 1)])
    return agent_setting
```
