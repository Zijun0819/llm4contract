```python
import numpy as np
from scipy.optimize import minimize, Bounds
from sklearn.mixture import GaussianMixture
from scipy.spatial.distance import pdist, squareform

def agent_solver_v2(v: np.ndarray, content: list[dict]) -> np.ndarray:
    # Extract information from logs
    m_outcomes = len(v)
    accepted_contracts = []
    accepted_utils = []
    rejected_contracts = []
    
    for log in content:
        contract = np.array(log['Contract'])
        if log['Agent Action'] == 1:
            accepted_contracts.append(contract)
            accepted_utils.append(log['Principal Utility'])
        else:
            rejected_contracts.append(contract)
    
    # If no data, return default
    if not content:
        default_p = np.ones(m_outcomes) / m_outcomes
        return np.hstack([default_p.reshape(1, -1), np.zeros((1, 1))])
    
    # Step 1: Infer probability distributions from accepted contracts
    p_list = []
    for contract, u_p in zip(accepted_contracts, accepted_utils):
        # Solve for probability distribution that explains principal utility
        A_eq = np.vstack([np.ones(m_outcomes), v])
        b_eq = np.array([1, u_p])
        bounds = [(0, 1)] * m_outcomes
        # Use linear programming to find feasible distribution
        c = -contract  # We want to maximize agent utility subject to constraints
        try:
            from scipy.optimize import linprog
            res = linprog(c, A_eq=A_eq, b_eq=b_eq, bounds=bounds, method='highs')
            if res.success:
                p_list.append(res.x)
        except:
            continue
    
    # Add uniform distribution as fallback
    if not p_list:
        p_list = [np.ones(m_outcomes) / m_outcomes]
    
    p_array = np.array(p_list)
    
    # Adaptive clustering: Determine number of components based on data diversity
    if len(p_array) > 1:
        # Use distance matrix to estimate number of clusters
        distances = pdist(p_array)
        if len(distances) > 0:
            mean_dist = np.mean(distances)
            # Simple heuristic: number of clusters based on data spread
            n_candidates = min(12, max(1, int(np.sqrt(len(p_array)))))
        else:
            n_candidates = 1
    else:
        n_candidates = 1
    
    # Fit GMM with diagonal covariances to reduce overfitting
    gmm = GaussianMixture(n_components=n_candidates, covariance_type='diag', random_state=42)
    gmm.fit(p_array)
    p_centroids = gmm.means_
    n_actions = len(p_centroids)
    
    # Step 2: Compute tight cost bounds using all logs
    cost_lb = np.zeros(n_actions)  # Lower bounds from acceptances
    cost_ub = np.full(n_actions, np.inf)  # Upper bounds from rejections
    
    # Process accepted contracts to get lower bounds
    for contract in accepted_contracts:
        for a in range(n_actions):
            agent_util = np.dot(p_centroids[a], contract)
            if agent_util >= 0:  # Action could have been chosen
                cost_lb[a] = max(cost_lb[a], agent_util)  # Cost must be <= agent_util
    
    # Process rejected contracts to get upper bounds
    for contract in rejected_contracts:
        agent_utils = np.array([np.dot(p_centroids[a], contract) for a in range(n_actions)])
        max_util = np.max(agent_utils)
        if max_util >= 0:  # If any action gives non-negative utility, must be below cost
            for a in range(n_actions):
                if agent_utils[a] == max_util:
                    cost_ub[a] = min(cost_ub[a], agent_utils[a])
    
    # Ensure feasibility: cost_lb <= cost_ub
    feasible = np.all(cost_lb <= cost_ub)
    if not feasible:
        # Adjust bounds to ensure feasibility: prioritize lower bounds from acceptances
        cost_ub = np.maximum(cost_lb, cost_ub)
    
    # Set initial costs to midpoint of bounds where possible, else lower bound
    initial_costs = np.where(cost_ub < np.inf, (cost_lb + cost_ub) / 2, cost_lb)
    
    # Step 3: Optimize costs to minimize constraint violations with tight bounds
    def objective(costs):
        violation = 0.0
        penalty_weight = 1000.0  # Strong penalty for violations
        
        # IR and IC constraints for all logs
        for contract, action in [(np.array(log['Contract']), log['Agent Action']) for log in content]:
            agent_utils = np.array([np.dot(p_centroids[a], contract) - costs[a] for a in range(n_actions)])
            best_util = np.max(agent_utils)
            best_action = np.argmax(agent_utils)
            
            if action == 1:  # Accepted: best action must have utility >= 0 and be optimal
                if best_util < 0:
                    violation += penalty_weight * (-best_util)
                # IC: for all other actions, utility <= best_util
                for a in range(n_actions):
                    if a != best_action:
                        violation += penalty_weight * max(0, agent_utils[a] - best_util)
            else:  # Rejected: all actions must have utility < 0
                if best_util >= 0:
                    violation += penalty_weight * best_util
        
        return violation
    
    # Constraints: costs within bounds
    bounds = Bounds(cost_lb, cost_ub)
    constraints = [{'type': 'ineq', 'fun': lambda x: x - cost_lb},
                   {'type': 'ineq', 'fun': lambda x: cost_ub - x}]
    
    # Optimize with SLSQP
    res = minimize(objective, initial_costs, method='SLSQP', bounds=bounds, constraints=constraints, options={'maxiter': 1000, 'ftol': 1e-8})
    
    if res.success:
        final_costs = res.x
    else:
        final_costs = initial_costs  # Fallback to initial if optimization fails
    
    # Construct output matrix
    agent_setting = np.hstack([p_centroids, final_costs.reshape(-1, 1)])
    return agent_setting
```
