```python
import numpy as np
import pandas as pd
from scipy.optimize import linprog, minimize
from sklearn.cluster import KMeans, DBSCAN
from sklearn.mixture import GaussianMixture
from scipy.spatial.distance import cdist

def agent_solver(v, content):
    accepted_logs = [log for log in content if log['Agent Action'] == 1]
    rejected_logs = [log for log in content if log['Agent Action'] == -1]
    if not accepted_logs:
        return np.array([]).reshape(0, 13)
    
    contracts_accepted = np.array([log['Contract'] for log in accepted_logs])
    utilities_accepted = np.array([log['Principal Utility'] for log in accepted_logs])
    contracts_rejected = np.array([log['Contract'] for log in rejected_logs]) if rejected_logs else np.array([]).reshape(0, 12)
    
    def compute_p_tilde(w, u):
        c = w
        A_eq = np.vstack([np.ones(12), v - w])
        b_eq = np.array([1.0, u])
        bounds = [(0, 1) for _ in range(12)]
        res = linprog(c, A_eq=A_eq, b_eq=b_eq, bounds=bounds, method='highs')
        return res.x if res.success else None
    
    p_hat_list = []
    for i in range(len(accepted_logs)):
        p_hat = compute_p_tilde(contracts_accepted[i], utilities_accepted[i])
        if p_hat is not None:
            p_hat_list.append(p_hat)
    
    if not p_hat_list:
        return np.array([]).reshape(0, 13)
    
    p_hat_array = np.array(p_hat_list)
    n_candidates = min(10, len(p_hat_array))
    if n_candidates < 3:
        n_candidates = 3
    
    kmeans = KMeans(n_clusters=n_candidates, random_state=42, n_init=10).fit(p_hat_array)
    centers = kmeans.cluster_centers_
    
    class_labels = kmeans.labels_
    cluster_sizes = np.bincount(class_labels, minlength=n_candidates)
    valid_clusters = np.where(cluster_sizes > 0)[0]
    centers = centers[valid_clusters]
    n_candidates = len(valid_clusters)
    
    c_min = np.zeros(n_candidates)
    for a in range(n_candidates):
        cluster_indices = np.where(class_labels == valid_clusters[a])[0]
        min_utility = np.inf
        for idx in cluster_indices:
            w = contracts_accepted[idx]
            utility = centers[a] @ w
            if utility < min_utility:
                min_utility = utility
        c_min[a] = min_utility
    
    if len(contracts_rejected) > 0:
        rejection_utils = centers @ contracts_rejected.T
        max_rej_utils = np.max(rejection_utils, axis=1)
        c_min = np.maximum(c_min, max_rej_utils)
    
    for a in range(n_candidates):
        if c_min[a] < 0:
            c_min[a] = 0.0
    
    agent_setting = np.hstack([centers, c_min.reshape(-1, 1)])
    return agent_setting
```
