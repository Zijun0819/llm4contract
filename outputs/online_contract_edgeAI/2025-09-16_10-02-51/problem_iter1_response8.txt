```python
import numpy as np
import pandas as pd
from scipy.optimize import linprog
from sklearn.cluster import KMeans
from sklearn.mixture import BayesianGaussianMixture
from scipy.spatial.distance import cdist

def agent_solver(v, content):
    m_outcomes = 12
    logs_df = pd.DataFrame(content)
    accepted_logs = logs_df[logs_df['Agent Action'] == 1].copy()
    rejected_logs = logs_df[logs_df['Agent Action'] == -1].copy()
    
    if len(accepted_logs) < 1:
        return np.array([[1.0/m_outcomes] * m_outcomes + [0.0]])
    
    accepted_contracts = np.array(accepted_logs['Contract'].tolist())
    rejected_contracts = np.array(rejected_logs['Contract'].tolist()) if len(rejected_logs) > 0 else np.array([])
    
    utility_gap = np.zeros(len(accepted_logs))
    for idx, (_, row) in enumerate(accepted_logs.iterrows()):
        contract = np.array(row['Contract'])
        if row['Principal Utility'] > 0:
            utility_gap[idx] = max(np.max(contract) - np.min(contract), 0)
        else:
            utility_gap[idx] = 0
    
    eps = np.percentile(utility_gap, 10) if len(utility_gap) > 0 else 1e-5
    n_candidates = min(max(int(np.sqrt(len(accepted_logs))), 5), 20)
    
    candidate_actions = []
    candidate_costs = []
    for i in range(len(accepted_logs)):
        contract = accepted_logs.iloc[i]['Contract']
        p = np.full(m_outcomes, 1.0/m_outcomes)
        q = np.full(m_outcomes, 1.0/m_outcomes)
        for _ in range(10):
            utility = np.dot(p, v) - accepted_logs.iloc[i]['Principal Utility']
            cost = max(np.dot(p, contract) - eps, 0)
            if abs(utility) < 1e-6 and cost >= 0:
                candidate_actions.append(p)
                candidate_costs.append(cost)
                break
            p = p + 0.01 * (contract - cost * np.ones(m_outcomes))
            p = np.maximum(p, 0)
            p = p / np.sum(p)
        
        if len(candidate_actions) <= i:
            candidate_actions.append(p)
            candidate_costs.append(max(np.dot(p, contract), 0))
    
    if len(candidate_actions) == 0:
        p0 = np.full((1, m_outcomes), 1.0/m_outcomes)
        return np.hstack([p0, np.zeros((1, 1))])
    
    X = np.array(candidate_actions)
    bgm = BayesianGaussianMixture(n_components=n_candidates, random_state=0, max_iter=1000).fit(X)
    labels = bgm.predict(X)
    p0 = bgm.means_
    
    unique_labels = np.unique(labels)
    if len(unique_labels) < n_candidates:
        p0 = p0[unique_labels]
        n_candidates = len(unique_labels)
    
    cluster_contracts = [[] for _ in range(n_candidates)]
    for i, label in enumerate(labels):
        cluster_contracts[label].append(accepted_contracts[i])
    
    min_costs = np.zeros(n_candidates)
    cluster_costs = [[] for _ in range(n_candidates)]
    for a in range(n_candidates):
        if cluster_contracts[a]:
            contracts = np.array(cluster_contracts[a])
            min_wages = contracts.min(axis=0)
            max_costs = [np.dot(p0[a], contract) for contract in contracts]
            cluster_costs[a] = max_costs
            min_costs[a] = np.max(max_costs) - eps if len(max_costs) > 0 else 0
        else:
            min_costs[a] = 0
    
    if len(rejected_contracts) > 0:
        rej_scores = p0 @ rejected_contracts.T
        for a in range(n_candidates):
            if reject_mask := (rej_scores[a] >= min_costs[a]):
                max_rej = np.max(rej_scores[a][reject_mask])
                min_costs[a] = max(max_rej + eps, min_costs[a])
    
    agent_setting = np.hstack([p0, min_costs.reshape(-1, 1)])
    return agent_setting
```
