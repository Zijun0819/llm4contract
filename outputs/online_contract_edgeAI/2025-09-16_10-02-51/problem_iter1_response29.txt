```python
import numpy as np
import pandas as pd
from scipy.optimize import linprog, minimize
from sklearn.cluster import KMeans
from itertools import combinations

def agent_solver(v, content):
    def solve_p_min(w, u):
        m = len(w)
        A_eq = [np.ones(m), v - w]
        b_eq = [1.0, u]
        bounds = [(0, 1) for _ in range(m)]
        res = linprog(w, A_eq=A_eq, b_eq=b_eq, bounds=bounds, method='highs')
        return res.x if res.success else None

    def solve_p_max(w, u):
        m = len(w)
        A_eq = [np.ones(m), v - w]
        b_eq = [1.0, u]
        bounds = [(0, 1) for _ in range(m)]
        res = linprog(-w, A_eq=A_eq, b_eq=b_eq, bounds=bounds, method='highs')
        return res.x if res.success else None

    n_actions = 15
    n_outcomes = len(v)
    accepted_logs = [log for log in content if log['Agent Action'] == 1]
    rejected_logs = [log for log in content if log['Agent Action'] == -1]
    accepted_wages = np.array([log['Contract'] for log in accepted_logs])
    accepted_utils = np.array([log['Principal Utility'] for log in accepted_logs])
    
    candidate_ps = []
    for i in range(len(accepted_logs)):
        p_min = solve_p_min(accepted_wages[i], accepted_utils[i])
        p_max = solve_p_max(accepted_wages[i], accepted_utils[i])
        if p_min is not None:
            candidate_ps.append(p_min)
        if p_max is not None:
            candidate_ps.append(p_max)
    
    if len(candidate_ps) == 0:
        candidate_ps = np.random.dirichlet(np.ones(n_outcomes), size=n_actions)
    else:
        candidate_ps = np.array(candidate_ps)
        if candidate_ps.shape[0] > n_actions:
            kmeans = KMeans(n_clusters=n_actions, random_state=0, n_init=10).fit(candidate_ps)
            candidate_ps = kmeans.cluster_centers_
    
    action_ps = candidate_ps
    n_actions_final = action_ps.shape[0]
    
    def objective(c):
        total_violation = 0.0
        for log in accepted_logs:
            w = np.array(log['Contract'])
            u = log['Principal Utility']
            max_util = max(np.dot(action_ps, w) - c)
            if max_util < 0:
                total_violation += (max_util) ** 2
            best_action = np.argmax(np.dot(action_ps, w) - c)
            if not np.isclose(np.dot(action_ps[best_action], v - w), u, atol=1e-8):
                total_violation += (np.dot(action_ps[best_action], v - w) - u) ** 2
        for log in rejected_logs:
            w = np.array(log['Contract'])
            max_util = max(np.dot(action_ps, w) - c)
            if max_util >= 0:
                total_violation += (max_util) ** 2
        return total_violation
    
    c_init = np.zeros(n_actions_final)
    bounds = [(0, None)] * n_actions_final
    res = minimize(objective, c_init, bounds=bounds, method='L-BFGS-B', options={'maxiter': 1000})
    c_opt = res.x
    
    agent_setting = np.hstack([action_ps, c_opt.reshape(-1, 1)])
    return agent_setting
```
