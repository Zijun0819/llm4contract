```python
import numpy as np
import pandas as pd
from scipy.optimize import linprog, minimize
from sklearn.cluster import KMeans
from sklearn.mixture import GaussianMixture
import cvxpy as cp

def agent_solver_v2(v: np.ndarray, content: list[dict]) -> np.ndarray:
    n_outcomes = len(v)
    accepted_logs = [log for log in content if log['Agent Action'] == 1]
    rejected_logs = [log for log in content if log['Agent Action'] == -1]
    
    def solve_p_from_contract(w, u_principal):
        try:
            p = cp.Variable(n_outcomes)
            constraints = [
                p >= 0,
                cp.sum(p) == 1,
                p @ (v - w) == u_principal
            ]
            prob = cp.Problem(cp.Minimize(cp.sum_squares(p)), constraints)
            prob.solve()
            if prob.status == 'optimal':
                return p.value
        except:
            pass
        return None

    candidate_ps = []
    for log in accepted_logs:
        p_candidate = solve_p_from_contract(np.array(log['Contract']), log['Principal Utility'])
        if p_candidate is not None:
            candidate_ps.append(p_candidate)
    
    if len(candidate_ps) == 0:
        return np.hstack([np.eye(n_outcomes), np.zeros((n_outcomes, 1))])
    
    X = np.array(candidate_ps)
    
    n_components = min(10, len(candidate_ps))
    gmm = GaussianMixture(n_components=n_components, covariance_type='diag', random_state=0)
    gmm.fit(X)
    p0 = gmm.means_
    
    accepted_contracts = np.array([log['Contract'] for log in accepted_logs])
    action_assignments = np.argmax(p0 @ accepted_contracts.T, axis=0)
    
    n_actions = p0.shape[0]
    rejection_constraints = np.array([log['Contract'] for log in rejected_logs]) if rejected_logs else np.zeros((0, n_outcomes))
    
    def objective(c):
        total_violation = 0.0
        for a in range(n_actions):
            for w in accepted_contracts[action_assignments == a]:
                if p0[a] @ w - c[a] < -1e-6:
                    total_violation += (p0[a] @ w - c[a])**2
            for w_rej in rejection_constraints:
                if p0[a] @ w_rej - c[a] > 1e-6:
                    total_violation += (p0[a] @ w_rej - c[a])**2
        return total_violation
    
    c_init = np.zeros(n_actions)
    for a in range(n_actions):
        if np.sum(action_assignments == a) > 0:
            accepted_wages = accepted_contracts[action_assignments == a]
            c_init[a] = np.min(p0[a] @ accepted_wages.T)
        else:
            c_init[a] = 0.0
    
    res = minimize(objective, c_init, method='L-BFGS-B', bounds=[(0, None)] * n_actions)
    c_opt = res.x if res.success else c_init
    
    return np.hstack([p0, c_opt.reshape(-1, 1)])
```
