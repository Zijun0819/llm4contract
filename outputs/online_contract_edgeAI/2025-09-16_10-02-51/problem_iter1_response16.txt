```python
import numpy as np
import pandas as pd
from scipy.optimize import linprog, milp, Bounds, LinearConstraint
from sklearn.cluster import KMeans
from sklearn.mixture import GaussianMixture
from sklearn.preprocessing import normalize

def agent_solver_v2(v: np.ndarray, content: list[dict]) -> np.ndarray:
    n_actions = 15
    n_outcomes = len(v)
    accepted_logs = [log for log in content if log['Agent Action'] == 1]
    rejected_logs = [log for log in content if log['Agent Action'] == -1]
    
    # Step 1: Infer equation system with regularization
    def infer_p_distributions(logs):
        ps = []
        for log in logs:
            w = np.array(log['Contract'])
            u_principal = log['Principal Utility']
            if u_principal == 0.0:
                continue
            try:
                A_eq = np.array([np.ones(n_outcomes), v - w])
                b_eq = np.array([1, u_principal])
                res = linprog(c=-w, A_eq=A_eq, b_eq=b_eq, bounds=(0, 1), method='highs')
                if res.success and np.all(res.x >= 0):
                    ps.append(res.x)
            except:
                continue
        return np.array(ps)
    
    inferred_ps = infer_p_distributions(accepted_logs)
    
    # Step 2: Gaussian Mixture Model for clustering with density-based selection
    if len(inferred_ps) > 0:
        gmm = GaussianMixture(n_components=n_actions, covariance_type='diag', random_state=0)
        gmm.fit(inferred_ps)
        action_centers = gmm.means_
        action_weights = gmm.weights_
        keep_indices = np.argsort(action_weights)[–ù-5:]
        action_centers = action_centers[keep_indices]
        n_actions = len(action_centers)
        # Renormalize centers to sum to 1
        action_centers = normalize(action_centers, norm='l1', axis=1)
    else:
        uniform_center = np.ones(n_outcomes) / n_outcomes
        action_centers = np.tile(uniform_center, (n_actions, 1))
    
    # Step 3: Cluster assignment with max likelihood under principal utility constraint
    assignments = np.full(len(content), -1)
    for idx, log in enumerate(content):
        if log['Agent Action'] == 1:
            w = np.array(log['Contract'])
            principal_util = log['Principal Utility']
            feasible_actions = []
            for a_idx in range(n_actions):
                p = action_centers[a_idx]
                if np.isclose(p @ (v - w), principal_util, atol=1e-6):
                    feasible_actions.append(a_idx)
            if feasible_actions:
                util_gains = [p @ w for p in action_centers[feasible_actions]]
                assignments[idx] = feasible_actions[np.argmin(util_gains)]
    
    # Step 4: Determine costs from accepted contracts and rejection constraints
    costs = np.zeros(n_actions)
    for a in range(n_actions):
        assign_mask = (assignments == a)
        if np.any(assign_mask):
            accepted_wages = [np.array(content[i]['Contract']) for i in np.where(assign_mask)[0]]
            util_values = [w @ action_centers[a] for w in accepted_wages]
            costs[a] = np.max(util_values) if util_values else 0.0
    # Adjust costs from rejection logs
    for a in range(n_actions):
        if rejected_logs:
            rej_utils = [action_centers[a] @ np.array(log['Contract']) for log in rejected_logs]
            max_rej_util = np.max(rej_utils) if rej_utils else -np.inf
            costs[a] = max(costs[a], max_rej_util + 1e-8)
    
    # Step 5: Ensure IR and consistency via iterative refinement
    violation_threshold = 1e-6
    max_iter = 50
    for it in range(max_iter):
        any_violation = False
        for idx, log in enumerate(content):
            act = log['Agent Action']
            w = np.array(log['Contract'])
            current_assignment = assignments[idx] if idx < len(assignments) else -1
            if act == 1:
                assigned_util = action_centers[current_assignment] @ w - costs[current_assignment]
                other_utils = [p @ w - c for p, c in zip(action_centers, costs)]
                if not (assigned_util >= -violation_threshold and assigned_util >= max(other_utils) - violation_threshold):
                    any_violation = True
                    new_assign = np.argmax([p @ w - c for p, c in zip(action_centers, costs)])
                    assignments[idx] = new_assign
                    # Update cost for new assignment
                    costs[new_assign] = max(costs[new_assign], w @ action_centers[new_assign])
            else:
                max_util = max([p @ w - c for p, c in zip(action_centers, costs)])
                if max_util > violation_threshold:
                    any_violation = True
                    costs += (max_util - costs.min()) * 0.1
        if not any_violation:
            break
    
    # Construct final agent setting
    agent_setting = np.hstack([action_centers, costs.reshape(-1, 1)])
    return agent_setting
```
