```python
import numpy as np
from scipy.optimize import linprog
from sklearn.cluster import KMeans
from sklearn.mixture import GaussianMixture
from scipy.spatial.distance import cdist

def agent_solver(v: np.ndarray, content: list[dict]) -> np.ndarray:
    n_outcomes = len(v)
    accepted_logs = [log for log in content if log['Agent Action'] == 1]
    rejected_logs = [log for log in content if log['Agent Action'] == -1]
    
    if not accepted_logs:
        default_p = np.ones(n_outcomes) / n_outcomes
        if rejected_logs:
            rej_contracts = np.array([log['Contract'] for log in rejected_logs])
            max_rej_util = np.max(default_p @ rej_contracts.T)
            cost = max_rej_util
        else:
            cost = 0.0
        return np.hstack([default_p.reshape(1, -1), np.array([[cost]])])
    
    contracts = np.array([log['Contract'] for log in accepted_logs])
    principal_utils = np.array([log['Principal Utility'] for log in accepted_logs])
    
    ps_list = []
    for i in range(len(accepted_logs)):
        w = contracts[i]
        u_target = principal_utils[i]
        res = linprog(w, A_eq=np.vstack([np.ones(n_outcomes), v - w]), 
                      b_eq=np.array([1, u_target]), bounds=[(0, 1)] * n_outcomes, method='highs')
        if res.success:
            ps_list.append(res.x)
    
    if not ps_list:
        ps_list = [np.ones(n_outcomes) / n_outcomes]
    
    ps = np.array(ps_list)
    
    max_clusters = min(20, len(ps))
    best_bic = np.inf
    best_gmm = None
    
    for n_components in range(1, max_clusters + 1):
        gmm = GaussianMixture(n_components=n_components, random_state=0, n_init=5)
        gmm.fit(ps)
        bic = gmm.bic(ps)
        if bic < best_bic:
            best_bic = bic
            best_gmm = gmm
    
    n_actions = best_gmm.n_components
    p_centers = best_gmm.means_
    
    action_assignment = np.argmax(p_centers @ contracts.T, axis=0)
    
    costs = np.zeros(n_actions)
    for a in range(n_actions):
        mask = (action_assignment == a)
        if np.any(mask):
            min_util = np.min((p_centers[a] @ contracts[mask].T))
            costs[a] = min_util
        else:
            costs[a] = 0.0
    
    if rejected_logs:
        rej_contracts = np.array([log['Contract'] for log in rejected_logs])
        rej_utils = p_centers @ rej_contracts.T
        max_rej_per_contract = np.max(rej_utils, axis=0)
        rej_threshold = np.max(max_rej_per_contract)
        costs = np.maximum(costs, rej_threshold)
    
    agent_setting = np.hstack([p_centers, costs.reshape(-1, 1)])
    return agent_setting
```
