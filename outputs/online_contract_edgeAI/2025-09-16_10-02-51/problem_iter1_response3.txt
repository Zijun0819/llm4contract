```python
import numpy as np
from scipy.optimize import linprog, minimize
from sklearn.cluster import KMeans
from sklearn.mixture import GaussianMixture

def agent_solver_v2(v: np.ndarray, content: list[dict]) -> np.ndarray:
    ACCEPTED = 1
    REJECTED = -1
    N_OUTCOMES = len(v)
    N_COMPONENTS = min(12, len(content))
    
    accepted_logs = [log for log in content if log['Agent Action'] == ACCEPTED]
    rejected_logs = [log for log in content if log['Agent Action'] == REJECTED]
    
    if not accepted_logs:
        return np.array([[0.0833]*12 + [0.0] for _ in range(1)]).astype(float)
    
    A = np.array([log['Contract'] for log in accepted_logs])
    p_estimates = []
    
    for i, log in enumerate(accepted_logs):
        w = log['Contract']
        u = log['Principal Utility']
        prob = np.zeros(N_OUTCOMES)
        if u > 0:
            try:
                res = linprog(-w, A_eq=[np.ones(N_OUTCOMES), v - w], b_eq=[1, u], bounds=[(0, 1)]*N_OUTCOMES)
                if res.success:
                    prob = res.x
                else:
                    prob = np.ones(N_OUTCOMES) / N_OUTCOMES
            except:
                prob = np.ones(N_OUTCOMES) / N_OUTCOMES
        else:
            prob = np.ones(N_OUTCOMES) / N_OUTCOMES
        p_estimates.append(prob)
    
    p_matrix = np.array(p_estimates)
    
    if len(accepted_logs) <= 1:
        p_clustered = p_matrix.reshape(1, -1)
        n_actions = 1
    else:
        n_actions = min(max(1, len(accepted_logs)//10), 5)
        gmm = GaussianMixture(n_components=n_actions, random_state=42, n_init=3)
        gmm.fit(p_matrix)
        p_clustered = gmm.means_
        n_actions = len(p_clustered)
    
    c_values = np.zeros(n_actions)
    for a in range(n_actions):
        indices = []
        for i, log in enumerate(accepted_logs):
            w = log['Contract']
            utilities = p_clustered @ w - c_values
            if np.argmax(utilities) == a:
                indices.append(i)
        
        if indices:
            min_utils = []
            for idx in indices:
                w = accepted_logs[idx]['Contract']
                agent_utility = p_clustered[a] @ w - c_values[a]
                min_utils.append(agent_utility)
            c_values[a] = p_clustered[a] @ A[indices].mean(axis=0) - min(min_utils) if min_utils else 0.0
        else:
            c_values[a] = 0.0
    
    if rejected_logs:
        rejection_wages = np.array([log['Contract'] for log in rejected_logs])
        for a in range(n_actions):
            util_at_rejections = p_clustered[a] @ rejection_wages.T - c_values[a]
            max_rejection_util = util_at_rejections.max()
            if max_rejection_util > 0:
                c_values[a] += max_rejection_util + 1e-8
    
    for a in range(n_actions):
        c_values[a] = max(0.0, c_values[a])
    
    agent_setting = np.hstack([p_clustered, c_values.reshape(-1, 1)])
    return agent_setting
```
