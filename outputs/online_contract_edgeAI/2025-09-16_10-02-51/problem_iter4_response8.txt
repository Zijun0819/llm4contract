```python
import numpy as np
from scipy.optimize import linprog, minimize, Bounds, LinearConstraint
from sklearn.mixture import GaussianMixture

def agent_solver(v, content):
    n_outcomes = len(v)
    accepted_logs = [log for log in content if log['Agent Action'] == 1]
    rejected_logs = [log for log in content if log['Agent Action'] == -1]
    
    if not accepted_logs:
        uniform_p = np.ones(n_outcomes) / n_outcomes
        return np.hstack([uniform_p.reshape(1, -1), np.zeros((1, 1))])
    
    contracts = np.array([log['Contract'] for log in accepted_logs])
    principal_utils = np.array([log['Principal Utility'] for log in accepted_logs])
    
    inferred_ps = []
    for i in range(len(accepted_logs)):
        w = contracts[i]
        u_p = principal_utils[i]
        c = -w
        A_eq = np.vstack([np.ones(n_outcomes), v - w])
        b_eq = np.array([1, u_p])
        bounds = [(0, 1)] * n_outcomes
        res = linprog(c, A_eq=A_eq, b_eq=b_eq, bounds=bounds, method='highs')
        if res.success:
            inferred_ps.append(res.x)
    
    if not inferred_ps:
        uniform_p = np.ones(n_outcomes) / n_outcomes
        return np.hstack([uniform_p.reshape(1, -1), np.zeros((1, 1))])
    
    inferred_ps = np.array(inferred_ps)
    n_samples = len(inferred_ps)
    max_clusters = min(10, n_samples // 2)
    max_clusters = max(1, max_clusters)
    
    best_bic = np.inf
    best_gmm = None
    
    for n_components in range(1, max_clusters + 1):
        if n_samples < n_components:
            continue
        gmm = GaussianMixture(n_components=n_components, random_state=0, n_init=3)
        gmm.fit(inferred_ps)
        bic = gmm.bic(inferred_ps)
        if bic < best_bic:
            best_bic = bic
            best_gmm = gmm
    
    if best_gmm is None:
        best_gmm = GaussianMixture(n_components=1, random_state=0).fit(inferred_ps)
    
    centers = best_gmm.means_
    n_actions = centers.shape[0]
    
    cost_lb = np.zeros(n_actions)
    for a in range(n_actions):
        p_a = centers[a]
        min_util = np.inf
        for w in contracts:
            util = p_a @ w
            if util < min_util:
                min_util = util
        if min_util != np.inf:
            cost_lb[a] = min_util
    
    if rejected_logs:
        rej_contracts = np.array([log['Contract'] for log in rejected_logs])
        for a in range(n_actions):
            p_a = centers[a]
            max_rej_util = -np.inf
            for w in rej_contracts:
                util = p_a @ w
                if util > max_rej_util:
                    max_rej_util = util
            if max_rej_util != -np.inf and max_rej_util >= cost_lb[a]:
                cost_lb[a] = max_rej_util + 1e-8
    
    def constraint_violation(costs):
        total_violation = 0.0
        for log in content:
            w = np.array(log['Contract'])
            action = log['Agent Action']
            max_util = -np.inf
            for a in range(n_actions):
                util = centers[a] @ w - costs[a]
                if util > max_util:
                    max_util = util
            if action == 1 and max_util < 0:
                total_violation += -max_util
            elif action == -1 and max_util >= 0:
                total_violation += max_util
        return total_violation
    
    bounds = Bounds(cost_lb, np.full(n_actions, np.inf))
    constraints = LinearConstraint(np.eye(n_actions), cost_lb, np.inf)
    res = minimize(constraint_violation, cost_lb, method='SLSQP', bounds=bounds, constraints=constraints, options={'maxiter': 1000})
    final_costs = res.x if res.success else cost_lb
    
    return np.hstack([centers, final_costs.reshape(-1, 1)])
```
