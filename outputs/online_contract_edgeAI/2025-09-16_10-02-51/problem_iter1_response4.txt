```python
import numpy as np
from scipy.optimize import linprog, minimize
from sklearn.cluster import KMeans
import pandas as pd

def agent_solver(v, content):
    content = pd.DataFrame(content)
    m_outcomes = len(v)
    accepted_logs = content[content['Agent Action'] == 1]
    if accepted_logs.empty:
        raise ValueError("No accepted contracts in logs")
    
    def mini_lp_p(w, u):
        res = linprog(w, A_eq=np.vstack([np.ones_like(w), v - w]), b_eq=[1.0, u], bounds=[(0, 1)] * len(w), method='highs')
        return res.x if res.success else None
    
    inferred_ps = []
    for _, log in accepted_logs.iterrows():
        w_i = np.array(log['Contract'])
        u_i = log['Principal Utility']
        p_i = mini_lp_p(w_i, u_i)
        if p_i is not None:
            inferred_ps.append(p_i)
    
    if not inferred_ps:
        raise ValueError("Could not infer any valid distributions from accepted logs")
    
    candidates = np.array(inferred_ps)
    
    max_clusters = min(20, len(inferred_ps))
    inertia = []
    for n in range(1, max_clusters + 1):
        kmeans = KMeans(n_clusters=n, random_state=0, n_init=10).fit(candidates)
        inertia.append(kmeans.inertia_)
    
    diffs = np.diff(inertia)
    ratio_diffs = diffs[:-1] / diffs[1:] if len(diffs) > 1 else np.array([1])
    n_clusters = 1 + np.argmax(ratio_diffs) if len(ratio_diffs) > 0 else 1
    n_clusters = min(n_clusters + 1, max_clusters)
    
    kmeans = KMeans(n_clusters=n_clusters, random_state=0, n_init=10).fit(candidates)
    cluster_centers = kmeans.cluster_centers_
    
    assignments = {}
    for i, log in content.iterrows():
        w = np.array(log['Contract'])
        if log['Agent Action'] == 1:
            action = np.argmax(cluster_centers @ w)
            assignments[i] = action
    
    costs = np.zeros(n_clusters)
    for a in range(n_clusters):
        indices = [idx for idx, act in assignments.items() if act == a]
        if indices:
            utilities = []
            for idx in indices:
                w = np.array(content.iloc[idx]['Contract'])
                utilities.append(cluster_centers[a] @ w)
            costs[a] = min(utilities)
        else:
            costs[a] = 0.0
    
    rej_logs = content[content['Agent Action'] == -1]
    for _, log in rej_logs.iterrows():
        w = np.array(log['Contract'])
        for a in range(n_clusters):
            if cluster_centers[a] @ w > costs[a]:
                costs[a] = cluster_centers[a] @ w
    
    agent_setting = np.hstack([cluster_centers, costs.reshape(-1, 1)])
    def refine_cost(agent_setting, content):
        p_mat = agent_setting[:, :-1]
        c_vec = agent_setting[:, -1]
        def penalty(params):
            new_c = params
            total = 0.0
            for _, log in content.iterrows():
                w = np.array(log['Contract'])
                if log['Agent Action'] == 1:
                    utils = p_mat @ w - new_c
                    if max(utils) < 0:
                        total += (max(utils) - 0) ** 2
                    chosen = np.argmax(utils)
                    if utils[chosen] < 0:
                        total += (utils[chosen] - 0) ** 2
                    for a in range(len(new_c)):
                        if a != chosen and utils[a] > utils[chosen]:
                            total += (utils[a] - utils[chosen]) ** 2
                else:
                    utils = p_mat @ w - new_c
                    if max(utils) >= 0:
                        total += (max(utils) - (-1e-6)) ** 2
            return total
        res = minimize(penalty, c_vec, method='L-BFGS-B', bounds=[(0, None)] * len(c_vec))
        if res.success:
            agent_setting[:, -1] = res.x
        return agent_setting
    
    agent_setting = refine_cost(agent_setting, content)
    return agent_setting
```
