```python
import numpy as np
import pandas as pd
from scipy.optimize import linprog, minimize
from sklearn.cluster import KMeans

def agent_solver(v: np.ndarray, content: pd.DataFrame) -> np.ndarray:
    accepted_logs = content[content['Agent Action'] == 1]
    if accepted_logs.empty:
        return np.zeros((1, 13))
    
    rejected_logs = content[content['Agent Action'] == -1]
    accepted_contracts = np.array(accepted_logs['Contract'].tolist())
    accepted_utils = accepted_logs['Principal Utility'].values
    m_outcomes = len(v)
    
    optimal_clusters = []
    max_clusters = min(20, len(accepted_logs))
    for n_clusters in range(1, max_clusters + 1):
        kmeans = KMeans(n_clusters=n_clusters, random_state=42, n_init=10).fit(accepted_contracts)
        labels = kmeans.labels_
        cluster_centers = kmeans.cluster_centers_
        valid = True
        for i in range(n_clusters):
            cluster_indices = np.where(labels == i)[0]
            if len(cluster_indices) == 0:
                continue
            cluster_contracts = accepted_contracts[cluster_indices]
            cluster_utils = accepted_utils[cluster_indices]
            A_eq = np.vstack([np.ones(m_outcomes), v])
            for j, contract in enumerate(cluster_contracts):
                b_eq = [1, cluster_utils[j]]
                res = linprog(-contract, A_eq=A_eq, b_eq=b_eq, bounds=[(0, 1)]*m_outcomes, method='highs')
                if not res.success:
                    valid = False
                    break
            if not valid:
                break
        if valid:
            optimal_clusters.append(n_clusters)
    
    n_clusters = optimal_clusters[-1] if optimal_clusters else 1
    kmeans = KMeans(n_clusters=n_clusters, random_state=42, n_init=10).fit(accepted_contracts)
    labels = kmeans.labels_
    cluster_centers = kmeans.cluster_centers_
    
    p_estimates = np.zeros((n_clusters, m_outcomes))
    cost_estimates = np.zeros(n_clusters)
    for i in range(n_clusters):
        cluster_indices = np.where(labels == i)[0]
        if len(cluster_indices) == 0:
            p_estimates[i] = np.ones(m_outcomes) / m_outcomes
            cost_estimates[i] = 0.0
            continue
        cluster_contracts = accepted_contracts[cluster_indices]
        cluster_utils = accepted_utils[cluster_indices]
        A_eq = np.vstack([np.ones(m_outcomes), v])
        b_eq = [1, np.mean(cluster_utils)]
        res = linprog(-np.mean(cluster_contracts, axis=0), A_eq=A_eq, b_eq=b_eq, bounds=[(0, 1)]*m_outcomes, method='highs')
        if res.success:
            p_estimates[i] = res.x
            cost_estimates[i] = np.dot(p_estimates[i], np.mean(cluster_contracts, axis=0))
        else:
            p_estimates[i] = np.ones(m_outcomes) / m_outcomes
            cost_estimates[i] = 0.0
    
    if not rejected_logs.empty:
        rejected_contracts = np.array(rejected_logs['Contract'].tolist())
        for contract in rejected_contracts:
            utils = p_estimates @ contract - cost_estimates
            max_util = np.max(utils)
            if max_util >= 0:
                for i in range(n_clusters):
                    if utils[i] >= 0:
                        cost_estimates[i] = max(cost_estimates[i], np.dot(p_estimates[i], contract))
    
    def refine_costs(costs):
        total_penalty = 0.0
        for _, log in content.iterrows():
            contract = np.array(log['Contract'])
            action = log['Agent Action']
            utils = p_estimates @ contract - costs
            max_util = np.max(utils)
            best_action = np.argmax(utils)
            if action == 1:
                if max_util < 0:
                    total_penalty += (max_util)**2
                for i in range(n_clusters):
                    if i != best_action and utils[i] > utils[best_action]:
                        total_penalty += (utils[i] - utils[best_action])**2
            else:
                if max_util >= 0:
                    total_penalty += (max_util + 1e-6)**2
        return total_penalty
    
    res = minimize(refine_costs, cost_estimates, method='L-BFGS-B', bounds=[(0, None)]*n_clusters)
    if res.success:
        cost_estimates = res.x
    
    agent_setting = np.hstack([p_estimates, cost_estimates.reshape(-1, 1)])
    return agent_setting
```
