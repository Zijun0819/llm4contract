```python
import numpy as np
import pandas as pd
from scipy.optimize import linprog, LinearConstraint, minimize, Bounds
from sklearn.cluster import KMeans
from itertools import product

def agent_solver(v: np.ndarray, content) -> np.ndarray:
    accepted = [log for log in content if log['Agent Action'] == 1]
    rejected = [log for log in content if log['Agent Action'] == -1]
    
    if not accepted:
        p0 = np.full((1, 12), 1/12)
        c0 = np.array([0.0])
        return np.hstack([p0, c0[:, np.newaxis]])
    
    def solve_p(w, u):
        m = len(w)
        A_eq = np.vstack([np.ones(m), v - w])
        b_eq = np.array([1.0, u])
        bounds = Bounds(0, 1)
        res = linprog(w, A_eq=A_eq, b_eq=b_eq, bounds=bounds, method='highs')
        return res.x if res.success else None
    
    p_candidates = []
    for log in accepted:
        p_candidate = solve_p(log['Contract'], log['Principal Utility'])
        if p_candidate is not None:
            p_candidates.append(p_candidate)
    
    if not p_candidates:
        p0 = np.full((1, 12), 1/12)
        c0 = np.array([0.0])
        return np.hstack([p0, c0[:, np.newaxis]])
    
    all_p = np.array(p_candidates)
    max_clusters = min(20, len(p_candidates))
    best_score = -np.inf
    best_labels = None
    best_centers = None
    
    for n in range(1, max_clusters + 1):
        kmeans = KMeans(n_clusters=n, random_state=42, n_init=5).fit(all_p)
        centers = kmeans.cluster_centers_
        labels = kmeans.labels_
        if n == 1:
            score = -np.inf
        else:
            intra_cluster = np.sum([np.linalg.norm(all_p[labels == i] - centers[i], axis=1).sum() for i in range(n)])
            score = -intra_cluster
        if score > best_score:
            best_score = score
            best_labels = labels
            best_centers = centers
            best_n = n
    
    p0 = best_centers
    n_candidates = best_n
    
    def compute_best_response(w, ps, cs):
        utils = ps @ w - cs
        best_util = np.max(utils)
        if best_util >= 0:
            return np.argmax(utils)
        else:
            return -1
    
    def objective(x):
        ps = x[:-n_candidates].reshape(n_candidates, 12)
        cs = x[-n_candidates:]
        err = 0.0
        for log in accepted:
            w = log['Contract']
            pred_action = compute_best_response(w, ps, cs)
            if pred_action == -1:
                err += 1000.0
            else:
                err += np.linalg.norm(ps[pred_action] - solve_p(w, log['Principal Utility']), 1)
        for log in rejected:
            w = log['Contract']
            pred_action = compute_best_response(w, ps, cs)
            if pred_action != -1:
                err += 1000.0
        return err
    
    x0 = np.hstack([p0.flatten(), np.zeros(n_candidates)])
    bounds = []
    for _ in range(n_candidates * 12):
        bounds.append((0, 1))
    for _ in range(n_candidates):
        bounds.append((0, None))
    
    cons = []
    for i in range(n_candidates):
        cons.append(LinearConstraint(np.eye(n_candidates * 12 + n_candidates)[i*12:(i+1)*12].sum(axis=0), 1, 1))
    
    res = minimize(objective, x0, method='SLSQP', bounds=bounds, constraints=cons, options={'maxiter': 1000})
    if res.success:
        x_opt = res.x
        ps_opt = x_opt[:-n_candidates].reshape(n_candidates, 12)
        cs_opt = x_opt[-n_candidates:]
    else:
        ps_opt = p0
        cs_opt = np.zeros(n_candidates)
        for i in range(n_candidates):
            indices = np.where(best_labels == i)[0]
            if indices.size > 0:
                ws = np.array([accepted[j]['Contract'] for j in indices])
                cs_opt[i] = np.min(ps_opt[i] @ ws.T)
    
    agent_setting = np.hstack([ps_opt, cs_opt[:, np.newaxis]])
    return agent_setting
```
