```python
import numpy as np
from sklearn.cluster import KMeans
from scipy.optimize import linprog

def agent_solver_v2(v: np.ndarray, content: list) -> np.ndarray:
    accepted_logs = [log for log in content if log['Agent Action'] == 1]
    if not accepted_logs:
        return np.hstack([np.eye(len(v)), np.zeros((len(v), 1))])
    
    contracts = np.array([log['Contract'] for log in accepted_logs])
    n_clusters = min(50, len(contracts))
    kmeans = KMeans(n_clusters=n_clusters, random_state=42, n_init=10).fit(contracts)
    cluster_centers = kmeans.cluster_centers_
    cluster_labels = kmeans.labels_
    
    def solve_lp_for_cluster(cluster_id):
        cluster_contracts = contracts[cluster_labels == cluster_id]
        if cluster_contracts.size == 0:
            return None
        n_contracts, m = cluster_contracts.shape
        c = -np.mean(cluster_contracts, axis=0)
        A_eq = np.vstack([np.ones(m), v])
        b_eq = np.array([1.0, np.mean([log['Principal Utility'] for log, label in zip(accepted_logs, cluster_labels) if label == cluster_id])])
        bounds = [(0.0, 1.0)] * m
        res = linprog(c, A_eq=A_eq, b_eq=b_eq, bounds=bounds, method='highs')
        return res.x if res.success else None
    
    cluster_probs = []
    for i in range(n_clusters):
        p = solve_lp_for_cluster(i)
        if p is not None:
            cluster_probs.append(p)
        else:
            cluster_probs.append(cluster_centers[i])
    cluster_probs = np.array(cluster_probs)
    
    action_costs = np.zeros(n_clusters)
    for i in range(n_clusters):
        cluster_contracts = contracts[cluster_labels == i]
        if cluster_contracts.size > 0:
            utilities = np.sum(cluster_contracts * cluster_probs[i], axis=1)
            action_costs[i] = np.min(utilities)
    
    rejected_logs = [log for log in content if log['Agent Action'] == -1]
    if rejected_logs:
        rejected_contracts = np.array([log['Contract'] for log in rejected_logs])
        rejected_utilities = rejected_contracts @ cluster_probs.T
        max_rejected = np.max(rejected_utilities, axis=0)
        action_costs = np.maximum(action_costs, max_rejected + 1e-8)
    
    action_costs = np.maximum(action_costs, 0.0)
    
    return np.hstack([cluster_probs, action_costs.reshape(-1, 1)])
```
