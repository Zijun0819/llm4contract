```python
import numpy as np
import pandas as pd
from scipy.optimize import linprog, minimize, Bounds, LinearConstraint
from sklearn.cluster import KMeans
from sklearn.mixture import GaussianMixture
from sklearn.preprocessing import normalize
import cvxpy as cp

def agent_solver(v, content):
    n_outcomes = len(v)
    accepted_logs = [log for log in content if log['Agent Action'] == 1]
    rejected_logs = [log for log in content if log['Agent Action'] == -1]
    n_accepted = len(accepted_logs)
    n_rejected = len(rejected_logs)
    
    if n_accepted == 0:
        raise ValueError("No accepted contracts to infer agent types")
    
    W_acc = np.array([log['Contract'] for log in accepted_logs])
    U_acc = np.array([log['Principal Utility'] for log in accepted_logs])
    W_rej = np.array([log['Contract'] for log in rejected_logs]) if n_rejected > 0 else None
    
    def infer_p_from_log(w, u):
        m = n_outcomes
        c = -w
        A_eq = np.vstack([np.ones(m), v - w])
        b_eq = np.array([1, u])
        bounds = Bounds(0, 1)
        res = minimize(lambda p: p @ w, np.ones(m)/m, bounds=bounds, constraints=[LinearConstraint(A_eq, b_eq, b_eq)])
        if res.success:
            p_est = res.x
            p_est = np.clip(p_est, 0, 1)
            p_est /= p_est.sum()
            return p_est
        return None

    candidate_ps = []
    for w, u in zip(W_acc, U_acc):
        p_est = infer_p_from_log(w, u)
        if p_est is not None:
            candidate_ps.append(p_est)
    
    if not candidate_ps:
        raise ValueError("No valid probability distributions inferred from accepted contracts")
    
    candidate_ps = np.array(candidate_ps)
    
    max_clusters = min(10, len(candidate_ps))
    best_bic = np.inf
    best_gmm = None
    for n_components in range(1, max_clusters+1):
        gmm = GaussianMixture(n_components=n_components, covariance_type='diag', random_state=0)
        gmm.fit(candidate_ps)
        bic = gmm.bic(candidate_ps)
        if bic < best_bic:
            best_bic = bic
            best_gmm = gmm
    
    n_actions = best_gmm.n_components
    p_means = best_gmm.means_
    p_means = normalize(p_means, norm='l1', axis=1)
    
    cluster_assignments = best_gmm.predict(candidate_ps)
    action_assignments = np.full(n_accepted, -1)
    for idx, log in enumerate(accepted_logs):
        w = log['Contract']
        utilities = p_means @ w
        best_action = np.argmax(utilities)
        action_assignments[idx] = best_action
    
    c_est = np.zeros(n_actions)
    for a in range(n_actions):
        mask = (action_assignments == a)
        if np.any(mask):
            wages_a = W_acc[mask]
            min_wage_per_outcome = np.min(wages_a, axis=0)
            c_est[a] = p_means[a] @ min_wage_per_outcome
        else:
            c_est[a] = 0.0
    
    if n_rejected > 0:
        rej_utils = p_means @ W_rej.T
        max_rej_util = np.max(rej_utils, axis=1)
        c_est = np.maximum(c_est, max_rej_util)
    
    c_est = np.clip(c_est, 0, None)
    
    agent_setting = np.hstack([p_means, c_est.reshape(-1, 1)])
    return agent_setting
```
