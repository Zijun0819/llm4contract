```python
import numpy as np
from scipy.optimize import linprog
from sklearn.mixture import GaussianMixture
from sklearn.cluster import KMeans

def agent_solver_v2(v: np.ndarray, content: list) -> np.ndarray:
    # Extract accepted and rejected logs
    accepted_logs = [log for log in content if log['Agent Action'] == 1]
    rejected_logs = [log for log in content if log['Agent Action'] == -1]
    
    if not accepted_logs:
        return np.hstack([np.eye(len(v)), np.zeros((len(v), 1))])
    
    # Use GMM for belief clustering with BIC for model selection
    all_p = []
    for log in accepted_logs:
        contract = np.array(log['Contract'])
        u_principal = log['Principal Utility']
        # Solve mini-LP to find feasible belief
        m = len(contract)
        A_eq = np.vstack([np.ones(m), v - contract])
        b_eq = np.array([1, u_principal])
        res = linprog(-contract, A_eq=A_eq, b_eq=b_eq, bounds=[(0, 1)] * m, method='highs')
        if res.success:
            all_p.append(res.x)
    
    if not all_p:
        return np.hstack([np.eye(len(v)), np.zeros((len(v), 1))])
    
    all_p = np.array(all_p)
    
    # Determine optimal number of components using BIC
    max_components = min(50, len(all_p))
    bic_scores = []
    models = []
    for n in range(1, max_components + 1):
        gmm = GaussianMixture(n_components=n, random_state=42, max_iter=100)
        gmm.fit(all_p)
        bic_scores.append(gmm.bic(all_p))
        models.append(gmm)
    
    best_n = np.argmin(bic_scores) + 1
    best_gmm = models[best_n - 1]
    cluster_centers = best_gmm.means_
    n_clusters = best_n
    
    # Initialize costs from accepted contracts
    action_costs = np.zeros(n_clusters)
    cluster_assignments = best_gmm.predict(all_p)
    for i in range(n_clusters):
        cluster_indices = np.where(cluster_assignments == i)[0]
        if cluster_indices.size > 0:
            utilities = []
            for idx in cluster_indices:
                contract = np.array(accepted_logs[idx]['Contract'])
                utility = np.dot(cluster_centers[i], contract)
                utilities.append(utility)
            action_costs[i] = np.min(utilities) if utilities else 0.0
        else:
            action_costs[i] = 0.0
    
    # Adjust costs using rejected contracts to enforce IR constraints
    if rejected_logs:
        rejected_contracts = np.array([log['Contract'] for log in rejected_logs])
        for i in range(n_clusters):
            for contract in rejected_contracts:
                utility = np.dot(cluster_centers[i], contract)
                if utility >= action_costs[i]:
                    action_costs[i] = utility + 1e-6  # Slightly above to ensure rejection
    
    # Enforce non-negative costs
    action_costs = np.maximum(action_costs, 0)
    
    # Refine with IC constraints using LP for cost adjustments
    for i in range(n_clusters):
        for j in range(n_clusters):
            if i != j:
                # Check if action i is dominated by j for any accepted contract
                for log in accepted_logs:
                    contract = np.array(log['Contract'])
                    utility_i = np.dot(cluster_centers[i], contract) - action_costs[i]
                    utility_j = np.dot(cluster_centers[j], contract) - action_costs[j]
                    if utility_i < utility_j:
                        # Adjust cost to make i at least as good as j
                        action_costs[i] = max(action_costs[i], np.dot(cluster_centers[i], contract) - utility_j)
    
    # Final non-negative enforcement
    action_costs = np.maximum(action_costs, 0)
    
    agent_setting = np.hstack([cluster_centers, action_costs.reshape(-1, 1)])
    return agent_setting
```
