```python
import numpy as np
import pandas as pd
from scipy.optimize import linprog, minimize, LinearConstraint
from sklearn.cluster import DBSCAN, KMeans
from sklearn.preprocessing import StandardScaler
from sklearn.mixture import GaussianMixture

def agent_solver(v: np.ndarray, content: list[dict]) -> np.ndarray:
    m_outcomes = v.shape[0]
    logs = pd.DataFrame(content)
    accepted = logs[logs['Agent Action'] == 1]
    rejected = logs[logs['Agent Action'] == -1]
    
    def solve_dual(w, u):
        c = -v
        A_eq = np.vstack([np.ones(m_outcomes), w])
        b_eq = np.array([1, u])
        bounds = [(0, None)] * m_outcomes
        res = linprog(c, A_eq=A_eq, b_eq=b_eq, bounds=bounds, method='highs')
        return res.x if res.success else None
    
    candidate_ps = []
    utilities = []
    for _, row in accepted.iterrows():
        p_candidate = solve_dual(row['Contract'], row['Principal Utility'])
        if p_candidate is not None:
            candidate_ps.append(p_candidate)
            utilities.append(row['Principal Utility'])
    
    if not candidate_ps:
        return np.hstack([np.eye(m_outcomes), np.zeros((m_outcomes, 1))])
    
    X = np.array(candidate_ps)
    scaler = StandardScaler()
    X_scaled = scaler.fit_transform(X)
    
    n_components_range = range(1, min(11, len(X) + 1))
    best_gmm = None
    best_bic = np.inf
    for n_components in n_components_range:
        gmm = GaussianMixture(n_components=n_components, random_state=0, n_init=3)
        gmm.fit(X_scaled)
        bic = gmm.bic(X_scaled)
        if bic < best_bic:
            best_bic = bic
            best_gmm = gmm
    
    n_actions = best_gmm.n_components
    action_probs = best_gmm.predict_proba(X_scaled)
    p0 = np.zeros((n_actions, m_outcomes))
    for a in range(n_actions):
        weights = action_probs[:, a]
        if weights.sum() > 0:
            p0[a] = np.average(X, axis=0, weights=weights)
        else:
            p0[a] = np.ones(m_outcomes) / m_outcomes
        p0[a] /= p0[a].sum()
    
    def infer_costs(p_matrix, accepted_logs):
        n_acts = p_matrix.shape[0]
        costs = np.zeros(n_acts)
        for a in range(n_acts):
            relevant_logs = []
            for _, row in accepted_logs.iterrows():
                w = row['Contract']
                eu = p_matrix[a] @ w
                if eu >= 0:
                    relevant_logs.append(row)
            
            if relevant_logs:
                min_eu = min(p_matrix[a] @ row['Contract'] for _, row in accepted_logs.iterrows())
                costs[a] = max(0, min_eu)
            else:
                costs[a] = 0.0
        return costs
    
    c_init = infer_costs(p0, accepted)
    
    if not rejected.empty:
        rej_wages = np.array([row['Contract'] for _, row in rejected.iterrows()]).T
        rej_utils = p0 @ rej_wages
        min_rej_utils = rej_utils.min(axis=1)
        c_init = np.maximum(c_init, min_rej_utils)
    
    for a in range(n_actions):
        if c_init[a] < 0:
            c_init[a] = 0.0
    
    def refine_ic(p_matrix, costs, logs):
        n_acts = p_matrix.shape[0]
        
        def objective(params):
            flat_p = params[:n_acts * m_outcomes].reshape(n_acts, m_outcomes)
            new_costs = params[n_acts * m_outcomes:]
            total_violation = 0
            for _, row in logs.iterrows():
                w = row['Contract']
                action_utils = flat_p @ w - new_costs
                if row['Agent Action'] == 1:
                    best_util = np.max(action_utils)
                    if best_util < 0:
                        total_violation += abs(best_util)
                    chosen_a = np.argmax(action_utils)
                    if action_utils[chosen_a] < 0:
                        total_violation += abs(action_utils[chosen_a])
                else:
                    best_util = np.max(action_utils)
                    if best_util >= 0:
                        total_violation += best_util
            return total_violation
        
        initial_params = np.hstack([p_matrix.flatten(), costs])
        bounds = []
        for _ in range(n_acts * m_outcomes):
            bounds.append((0, 1))
        for _ in range(n_acts):
            bounds.append((0, None))
        
        cons = []
        for a in range(n_acts):
            cons.append(LinearConstraint(np.eye(n_acts * m_outcomes + n_acts)[a * m_outcomes:(a+1)*m_outcomes], 0, 1))
            cons.append({'type': 'eq', 'fun': lambda x: np.sum(x[a * m_outcomes:(a+1)*m_outcomes]) - 1})
        
        res = minimize(objective, initial_params, bounds=bounds, constraints=cons, method='SLSQP', options={'maxiter': 100})
        if res.success:
            refined_p = res.x[:n_acts * m_outcomes].reshape(n_acts, m_outcomes)
            refined_c = res.x[n_acts * m_outcomes:]
            return refined_p, refined_c
        return p_matrix, costs
    
    p_refined, c_refined = refine_ic(p0, c_init, logs)
    
    final_setting = np.hstack([p_refined, c_refined[:, np.newaxis]])
    return final_setting
```
