```python
import numpy as np
from scipy.optimize import linprog
from sklearn.cluster import KMeans
from sklearn.mixture import GaussianMixture
from scipy.optimize import minimize, Bounds
from sklearn.preprocessing import StandardScaler
import pandas as pd

def agent_solver_v2(v: np.ndarray, content: list[dict]) -> np.ndarray:
    def solve_mini_lp(w, u_principal):
        m = len(w)
        A_eq = np.vstack([np.ones(m), v - w])
        b_eq = np.array([1, u_principal])
        res = linprog(-w, A_eq=A_eq, b_eq=b_eq, bounds=[(0, 1)] * m, method='highs')
        return res.x if res.success else None

    accepted_logs = [log for log in content if log['Agent Action'] == 1]
    ps_candidates = []
    for log in accepted_logs:
        p_candidate = solve_mini_lp(log['Contract'], log['Principal Utility'])
        if p_candidate is not None:
            ps_candidates.append(p_candidate)
    
    if not ps_candidates:
        return np.hstack([np.eye(len(v)), np.zeros((len(v), 1))])
    
    all_p = np.array(ps_candidates)
    
    bic_scores = []
    n_components_range = range(1, min(20, len(all_p) + 1))
    for n_components in n_components_range:
        gmm = GaussianMixture(n_components=n_components, random_state=42, n_init=3)
        gmm.fit(all_p)
        bic_scores.append(gmm.bic(all_p))
    
    optimal_components = n_components_range[np.argmin(bic_scores)]
    gmm = GaussianMixture(n_components=optimal_components, random_state=42, n_init=10)
    gmm.fit(all_p)
    cluster_probs = gmm.predict_proba(all_p)
    cluster_centers = gmm.means_
    n_clusters = optimal_components
    
    action_costs = np.zeros(n_clusters)
    for i in range(n_clusters):
        cluster_weights = cluster_probs[:, i]
        if np.sum(cluster_weights) > 0:
            utilities = np.einsum('ij,ij->i', all_p, np.array([log['Contract'] for log in accepted_logs]))
            weighted_utils = utilities * cluster_weights
            action_costs[i] = np.min(weighted_utils[cluster_weights > 0]) if np.any(cluster_weights > 0) else 0.0
        else:
            action_costs[i] = 0.0
    
    rejected_logs = [log for log in content if log['Agent Action'] == -1]
    if rejected_logs:
        rejected_wages = np.array([log['Contract'] for log in rejected_logs])
        rejected_utilities = rejected_wages @ cluster_centers.T
        max_rejected = np.max(rejected_utilities, axis=0)
        action_costs = np.maximum(action_costs, max_rejected + 1e-8)
    
    action_costs = np.maximum(action_costs, 0)
    
    def constraint_violation(params):
        p_flat = params[:n_clusters * len(v)].reshape(n_clusters, len(v))
        c = params[n_clusters * len(v):]
        total_viol = 0.0
        for log in content:
            w = np.array(log['Contract'])
            utils = p_flat @ w - c
            max_util = np.max(utils)
            if log['Agent Action'] == 1:
                if max_util < 0:
                    total_viol += -max_util
            else:
                if max_util >= 0:
                    total_viol += max_util
        return total_viol

    def prob_constraint(params):
        p_flat = params[:n_clusters * len(v)].reshape(n_clusters, len(v))
        return np.array([np.sum(p_flat[i]) - 1 for i in range(n_clusters)])

    initial_params = np.concatenate([cluster_centers.flatten(), action_costs])
    bounds = Bounds([0]*(n_clusters*len(v)) + [0]*n_clusters, 
                    [1]*(n_clusters*len(v)) + [np.inf]*n_clusters)
    constraints = [{'type': 'eq', 'fun': prob_constraint}]
    
    res = minimize(constraint_violation, initial_params, method='SLSQP', 
                   bounds=bounds, constraints=constraints, 
                   options={'maxiter': 200, 'ftol': 1e-8})
    
    if res.success:
        p_opt = res.x[:n_clusters * len(v)].reshape(n_clusters, len(v))
        c_opt = res.x[n_clusters * len(v):]
        return np.hstack([p_opt, c_opt[:, np.newaxis]])
    else:
        return np.hstack([cluster_centers, action_costs[:, np.newaxis]])
```
