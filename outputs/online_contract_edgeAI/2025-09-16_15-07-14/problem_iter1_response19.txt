```python
import numpy as np
import pandas as pd
from scipy.optimize import linprog, minimize
from sklearn.cluster import KMeans
from scipy.linalg import LinAlgWarning
import warnings
warnings.filterwarnings('ignore', category=LinAlgWarning)

def agent_solver(v: np.ndarray, content: list[dict]) -> np.ndarray:
    def robust_mini_lp(w, u, v):
        m = len(w)
        A_eq = np.vstack([np.ones(m), v - w])
        b_eq = np.array([1.0, u])
        bounds = [(0, 1)] * m
        try:
            res = linprog(w, A_eq=A_eq, b_eq=b_eq, bounds=bounds, method='highs')
            if res.success:
                return res.x
            else:
                result = minimize(lambda p: np.sum((w - v) * p) - u, 
                                 x0=np.ones(m)/m, 
                                 constraints=[{'type': 'eq', 'fun': lambda p: np.sum(p) - 1}],
                                 bounds=bounds,
                                 method='SLSQP')
                return result.x if result.success else None
        except:
            return None

    accepted_logs = [log for log in content if log['Agent Action'] == 1]
    if not accepted_logs:
        return np.column_stack([np.eye(len(v)), np.zeros(len(v))])
    
    candidate_ps = []
    for log in accepted_logs:
        w_i = np.array(log['Contract'])
        u_i = log['Principal Utility']
        p_i = robust_mini_lp(w_i, u_i, v)
        if p_i is not None:
            candidate_ps.append(p_i)
    
    if not candidate_ps:
        return np.column_stack([np.eye(len(v)), np.zeros(len(v))])
    
    all_p = np.array(candidate_ps)
    if len(all_p) <= 1:
        n_candidates = min(5, len(v))
    else:
        silhouette_scores = []
        max_n = min(10, len(all_p))
        for k in range(2, max_n + 1):
            kmeans = KMeans(n_clusters=k, random_state=0, n_init=10).fit(all_p)
            score = (kmeans.inertia_ + 1e-8) ** -1
            silhouette_scores.append(score)
        n_candidates = np.argmax(silhouette_scores) + 2 if silhouette_scores else min(3, len(all_p))
    
    kmeans = KMeans(n_clusters=n_candidates, random_state=0, n_init=10).fit(all_p)
    p0 = kmeans.cluster_centers_
    
    def infer_costs(actions, contract_logs, p_mat):
        n_actions = p_mat.shape[0]
        costs = np.zeros(n_actions)
        for a in range(n_actions):
            accepted_w = []
            for i, log in enumerate(contract_logs):
                w = np.array(log['Contract'])
                if actions[i] == a and log['Agent Action'] == 1:
                    accepted_w.append(w)
            if accepted_w:
                accepted_w = np.array(accepted_w).T
                min_util = np.min(p_mat[a] @ accepted_w)
                costs[a] = max(0, min_util)
        return costs

    assignments = np.argmax([p0 @ np.array(log['Contract']) for log in content], axis=1)
    costs_ir = infer_costs(assignments, content, p0)
    
    rej_logs = [log for log in content if log['Agent Action'] == -1]
    if rej_logs:
        rej_w = np.array([log['Contract'] for log in rej_logs]).T
        rej_utils = p0 @ rej_w
        max_rej_util = np.max(rej_utils, axis=1)
    else:
        max_rej_util = np.zeros(len(p0))
    
    final_costs = np.maximum(costs_ir, max_rej_util)
    
    return np.column_stack([p0, final_costs.reshape(-1, 1)])
```
