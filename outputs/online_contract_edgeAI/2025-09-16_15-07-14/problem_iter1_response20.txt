```python
import numpy as np
import pandas as pd
from scipy.optimize import linprog, minimize
from sklearn.cluster import KMeans
from sklearn.mixture import GaussianMixture
from scipy.linalg import null_space

def agent_solver(v: np.ndarray, content: list) -> np.ndarray:
    n_actions = 9
    n_outcomes = len(v)
    logs = pd.DataFrame(content)
    accepted = logs[logs['Agent Action'] == 1]
    
    def solve_dual_lp(w, u):
        m = len(w)
        A = np.vstack([np.ones(m), w - v])
        b = np.array([1, u])
        bounds = [(0, None)] * m
        res = linprog(-w, A_ub=A, b_ub=b, bounds=bounds, method='highs')
        return res.x if res.success else None

    candidate_p = []
    for _, row in accepted.iterrows():
        p_hat = solve_dual_lp(row['Contract'], row['Principal Utility'])
        if p_hat is not None:
            candidate_p.append(p_hat)
    if not candidate_p:
        return np.hstack([np.eye(n_outcomes), np.zeros((n_outcomes, 1))])
    P = np.array(candidate_p)
    
    gmm = GaussianMixture(n_components=n_actions, covariance_type='diag', random_state=0)
    gmm.fit(P)
    p_centers = gmm.means_
    
    assignment = []
    for _, row in accepted.iterrows():
        w_vec = np.array(row['Contract'])
        utils = p_centers @ w_vec
        assignment.append(np.argmax(utils))
    assignment = np.array(assignment)
    
    c_lb = np.zeros(n_actions)
    for a in range(n_actions):
        mask = (assignment == a)
        if np.any(mask):
            w_mat = np.array([accepted.iloc[i]['Contract'] for i in np.where(mask)[0]]).T
            c_lb[a] = np.min(p_centers[a] @ w_mat)
    
    rejected = logs[logs['Agent Action'] == -1]
    if not rejected.empty:
        w_rej = np.array(rejected['Contract'].tolist()).T
        rej_utils = p_centers @ w_rej
        c_rej = np.max(rej_utils, axis=1)
        c_lb = np.maximum(c_lb, c_rej)
    
    def refine_cost(candidate_c):
        total_violation = 0
        for _, row in logs.iterrows():
            w = np.array(row['Contract'])
            action_utils = p_centers @ w - candidate_c
            max_util = np.max(action_utils)
            if row['Agent Action'] == 1 and max_util < 0:
                total_violation += abs(max_util)
            elif row['Agent Action'] == -1 and max_util >= 0:
                total_violation += max_util
        return total_violation

    res = minimize(refine_cost, c_lb, bounds=[(0, None)] * n_actions, method='L-BFGS-B')
    c_opt = res.x
    
    return np.hstack([p_centers, c_opt.reshape(-1, 1)])
```
