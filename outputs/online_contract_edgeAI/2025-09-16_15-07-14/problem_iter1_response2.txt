```python
import numpy as np
import pandas as pd
from scipy.optimize import linprog, minimize
from sklearn.cluster import KMeans
from sklearn.neighbors import KDTree

def agent_solver_v2(v: np.ndarray, content: list[dict]) -> np.ndarray:
    n_actions = min(10, len(content) // 5 + 2)
    m = len(v)
    L = len(content)
    
    accepted_logs = [log for log in content if log['Agent Action'] == 1]
    rejected_logs = [log for log in content if log['Agent Action'] == -1]
    
    def estimate_p(w, u):
        try:
            res = linprog(w, A_eq=[np.ones(m), v - w], b_eq=[1.0, u], bounds=[(0, 1)] * m, method='highs')
            return res.x if res.success else None
        except:
            return None
    
    candidate_ps = []
    for log in accepted_logs:
        p_est = estimate_p(log['Contract'], log['Principal Utility'])
        if p_est is not None:
            candidate_ps.append(p_est)
    
    if not candidate_ps:
        return np.hstack([np.ones((1, m)) / m, [[0.0]]])
    
    candidate_ps = np.array(candidate_ps)
    
    kmeans = KMeans(n_clusters=n_actions, random_state=42, n_init=20).fit(candidate_ps)
    p_centers = kmeans.cluster_centers_
    
    if rejected_logs:
        rej_wages = np.array([log['Contract'] for log in rejected_logs]).T
        rej_utils = p_centers @ rej_wages
        c_rej = rej_utils.max(axis=1)
    else:
        c_rej = np.zeros(n_actions)
    
    assignments = []
    utility_bounds = []
    for log in accepted_logs:
        w = log['Contract']
        utilities = p_centers @ w
        best_action = np.argmax(utilities)
        assignments.append(best_action)
        utility_bounds.append(utilities[best_action])
    
    c_estimates = np.zeros(n_actions)
    for a in range(n_actions):
        action_indices = [i for i, act in enumerate(assignments) if act == a]
        if action_indices:
            action_wages = np.array([accepted_logs[i]['Contract'] for i in action_indices]).T
            min_utils = (p_centers[a] @ action_wages).min()
            c_estimates[a] = min_utils
        else:
            c_estimates[a] = 0.0
    
    c_final = np.maximum(c_estimates, c_rej)
    
    if rejected_logs:
        tree = KDTree(p_centers[:, :-1] if p_centers.shape[1] > m else p_centers)
        for log in rejected_logs:
            w_rej = log['Contract']
            p_approx = estimate_p(w_rej, 0)
            if p_approx is not None:
                dist, idx = tree.query(p_approx.reshape(1, -1), k=1)
                c_final[idx[0]] = max(c_final[idx[0]], p_centers[idx[0]] @ w_rej)
    
    for a in range(n_actions):
        if c_final[a] < 0:
            c_final[a] = 0.0
    
    action_utils = []
    for log in content:
        w = log['Contract']
        utils = p_centers @ w - c_final
        max_util = utils.max()
        if log['Agent Action'] == 1 and max_util < 0:
            c_final[np.argmax(p_centers @ w)] = (p_centers[np.argmax(p_centers @ w)] @ w) - 1e-8
        elif log['Agent Action'] == -1 and max_util >= 0:
            c_final[np.argmax(utils)] = (p_centers[np.argmax(utils)] @ w) + 1e-8
    
    p_normalized = p_centers / p_centers.sum(axis=1, keepdims=True)
    
    return np.hstack([p_normalized, c_final.reshape(-1, 1)])
```
