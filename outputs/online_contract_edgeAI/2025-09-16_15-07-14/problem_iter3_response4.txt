```python
import numpy as np
from scipy.optimize import linprog
from sklearn.mixture import GaussianMixture
from sklearn.cluster import KMeans

def agent_solver_v2(v: np.ndarray, content: list) -> np.ndarray:
    # Extract accepted and rejected logs
    accepted_logs = [log for log in content if log['Agent Action'] == 1]
    rejected_logs = [log for log in content if log['Agent Action'] == -1]
    
    # Solve for belief vectors from accepted contracts
    ps_candidates = []
    for log in accepted_logs:
        contract = np.array(log['Contract'])
        u_principal = log['Principal Utility']
        # Set up linear program to find p that explains the utility
        m = len(v)
        A_eq = np.vstack([np.ones(m), v - contract])
        b_eq = np.array([1, u_principal])
        res = linprog(-contract, A_eq=A_eq, b_eq=b_eq, bounds=[(0, 1)] * m, method='highs')
        if res.success:
            ps_candidates.append(res.x)
    
    if not ps_candidates:
        # Default to identity matrix beliefs with zero costs if no solutions
        return np.hstack([np.eye(len(v)), np.zeros((len(v), 1))])
    
    all_p = np.array(ps_candidates)
    
    # Use GMM for clustering beliefs
    n_components = min(10, len(all_p))
    gmm = GaussianMixture(n_components=n_components, random_state=42)
    gmm.fit(all_p)
    cluster_centers = gmm.means_
    n_clusters = cluster_centers.shape[0]
    
    # Compute minimal utility per cluster from accepted contracts as cost lower bound
    action_costs = np.zeros(n_clusters)
    for i in range(n_clusters):
        # For each cluster, compute expected utility for all accepted contracts
        utilities = []
        for log in accepted_logs:
            contract = np.array(log['Contract'])
            utility = np.dot(cluster_centers[i], contract)
            utilities.append(utility)
        if utilities:
            action_costs[i] = np.min(utilities)
        else:
            action_costs[i] = 0.0
    
    # Adjust costs based on rejected contracts to ensure IR
    if rejected_logs:
        rejected_contracts = np.array([log['Contract'] for log in rejected_logs])
        for i in range(n_clusters):
            # Compute expected utility for each rejected contract
            rejected_utilities = np.dot(rejected_contracts, cluster_centers[i])
            # If any rejected contract gives utility >= current cost, increase cost
            max_rejected_utility = np.max(rejected_utilities)
            if max_rejected_utility >= action_costs[i]:
                action_costs[i] = max_rejected_utility + 1e-6  # Slightly above to ensure strict inequality
    
    # Ensure non-negative costs
    action_costs = np.maximum(action_costs, 0)
    
    # Refine with an LP to adjust costs for IC constraints among actions
    # Build a constraint matrix for IC: for each action i, and any other action j, 
    # utility of i >= utility of j - cost_j + cost_i? Actually, standard IC: for action i being optimal,
    # we need: p_i * w - c_i >= p_j * w - c_j for all j, for contracts where i is chosen.
    # This is complex; instead, we do a simple heuristic: ensure that for each accepted contract,
    # the utility minus cost for the best response is non-negative, and for others it's lower.
    # Given complexity, we do a simpler post-adjustment: for each cluster, if there's any accepted contract
    # where the utility for that cluster is less than cost, increase cost slightly to avoid violation?
    # Alternatively, we skip full IC enforcement for brevity, as it requires solving a complex optimization.
    # Instead, we ensure that for each accepted contract, the assigned cluster (if any) has utility >= cost.
    # We'll assign each accepted contract to the cluster with highest utility, and ensure that utility >= cost.
    for log in accepted_logs:
        contract = np.array(log['Contract'])
        utilities = np.dot(cluster_centers, contract)
        best_cluster = np.argmax(utilities)
        if utilities[best_cluster] < action_costs[best_cluster]:
            action_costs[best_cluster] = utilities[best_cluster]  # Lower cost to meet IR
    
    # Finally, stack beliefs and costs
    agent_setting = np.hstack([cluster_centers, action_costs.reshape(-1, 1)])
    return agent_setting
```
