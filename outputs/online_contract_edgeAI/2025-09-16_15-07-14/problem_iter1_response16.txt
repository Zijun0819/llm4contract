```python
import numpy as np
import pandas as pd
from scipy.optimize import linprog
from sklearn.cluster import KMeans
from sklearn.mixture import GaussianMixture

def agent_solver(v: np.ndarray, content: list[dict]) -> np.ndarray:
    m_outcomes = v.shape[0]
    L = len(content)
    
    def compute_potential_p(w, u):
        m = len(w)
        c_ub = np.ones(m)
        A_eq = np.vstack([np.ones(m), v - w])
        b_eq = np.array([1.0, u])
        bounds = [(0, 1)] * m
        res = linprog(w, A_eq=A_eq, b_eq=b_eq, bounds=bounds, method='highs')
        if res.success:
            p = res.x
            if abs(np.sum(p) - 1.0) < 1e-6 and all(p >= -1e-6):
                return p
        return None
    
    accepted_logs = [log for log in content if log['Agent Action'] == 1]
    if not accepted_logs:
        base_p = np.full(m_outcomes, 1/m_outcomes)
        base_c = 0.0
        agent_setting = np.hstack([base_p.reshape(1, -1), np.array([[base_c]])])
        return agent_setting
    
    candidate_ps = []
    for log in accepted_logs:
        w = log['Contract']
        u = log['Principal Utility']
        p_candidate = compute_potential_p(w, u)
        if p_candidate is not None:
            candidate_ps.append(p_candidate)
    
    if not candidate_ps:
        base_p = np.full(m_outcomes, 1/m_outcomes)
        base_c = 0.0
        agent_setting = np.hstack([base_p.reshape(1, -1), np.array([[base_c]])])
        return agent_setting
    
    candidate_ps = np.array(candidate_ps)
    candidate_ps = candidate_ps[np.all(candidate_ps >= -1e-6, axis=1)]
    if candidate_ps.size == 0:
        base_p = np.full(m_outcomes, 1/m_outcomes)
        base_c = 0.0
        agent_setting = np.hstack([base_p.reshape(1, -1), np.array([[base_c]])])
        return agent_setting
    
    n_components_range = range(1, min(11, len(candidate_ps) + 1))
    best_bic = np.inf
    best_gmm = None
    for n_components in n_components_range:
        try:
            gmm = GaussianMixture(n_components=n_components, random_state=0, covariance_type='diag')
            gmm.fit(candidate_ps)
            bic = gmm.bic(candidate_ps)
            if bic < best_bic:
                best_bic = bic
                best_gmm = gmm
        except:
            continue
    
    if best_gmm is None:
        n_candidates = 1
        p0 = np.mean(candidate_ps, axis=0).reshape(1, -1)
    else:
        n_candidates = best_gmm.n_components
        p0 = best_gmm.means_
    
    action_probs = best_gmm.predict_proba(candidate_ps) if best_gmm is not None else np.ones((len(candidate_ps), 1))
    assignments = np.argmax(action_probs, axis=1) if best_gmm is not None else np.zeros(len(candidate_ps), dtype=int)
    
    c_estimates = []
    for a in range(n_candidates):
        assigned_w = []
        for idx, p_idx in enumerate(range(len(candidate_ps))):
            if assignments[p_idx] == a:
                log = accepted_logs[p_idx]
                w = log['Contract']
                assigned_w.append(w)
        if assigned_w:
            assigned_w = np.array(assigned_w)
            min_w = np.min(assigned_w, axis=0)
            c_hat = np.dot(p0[a], min_w)
        else:
            c_hat = 0.0
        c_estimates.append(c_hat)
    
    rejected_logs = [log for log in content if log['Agent Action'] == -1]
    if rejected_logs:
        rej_wages = np.array([log['Contract'] for log in rejected_logs])
        rej_expected = np.dot(p0, rej_wages.T)
        rej_thresholds = np.max(rej_expected, axis=1)
        c_estimates = np.maximum(c_estimates, rej_thresholds)
    
    c_estimates = np.clip(c_estimates, 0, None)
    agent_setting = np.hstack([p0, np.array(c_estimates).reshape(-1, 1)])
    return agent_setting
```
