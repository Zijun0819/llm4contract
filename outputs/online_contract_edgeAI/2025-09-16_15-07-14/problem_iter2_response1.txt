```python
import numpy as np
from sklearn.cluster import KMeans
from scipy.optimize import minimize, Bounds

def agent_solver(v, content):
    if not content:
        return np.array([[1/12] * 12 + [0]])
    
    contracts = np.array([log['Contract'] for log in content])
    actions = np.array([log['Agent Action'] for log in content])
    accepted_mask = (actions == 1)
    rejected_mask = (actions == -1)
    
    if not np.any(accepted_mask):
        return np.array([[1/12] * 12 + [0]])
    
    accepted_contracts = contracts[accepted_mask]
    accepted_utilities = np.array([log['Principal Utility'] for log in content])[accepted_mask]
    
    inferred_ps = []
    for contract, util in zip(accepted_contracts, accepted_utilities):
        def constraint_eq(x):
            return [np.sum(x) - 1, np.dot(v - contract, x) - util]
        
        res = minimize(
            lambda x: -np.dot(contract, x),
            x0=np.ones(12)/12,
            bounds=Bounds(0, 1),
            constraints={'type': 'eq', 'fun': constraint_eq},
            method='SLSQP'
        )
        if res.success:
            inferred_ps.append(res.x)
    
    if not inferred_ps:
        inferred_ps = [np.ones(12)/12 for _ in range(min(10, len(accepted_contracts)))]
    
    inferred_ps = np.array(inferred_ps)
    n_candidates = min(10, len(inferred_ps))
    if len(inferred_ps) > n_candidates:
        kmeans = KMeans(n_clusters=n_candidates, n_init=10, random_state=0).fit(inferred_ps)
        action_distributions = kmeans.cluster_centers_
    else:
        action_distributions = inferred_ps
        n_candidates = len(inferred_ps)
    
    all_contracts_utils = action_distributions @ contracts.T
    best_action_per_contract = np.argmax(all_contracts_utils, axis=0)
    
    action_costs = np.zeros(n_candidates)
    for j in range(n_candidates):
        accepted_for_j = accepted_mask & (best_action_per_contract == j)
        if np.any(accepted_for_j):
            min_pay = np.min((action_distributions[j] @ contracts[accepted_for_j].T))
            action_costs[j] = min_pay
        
        rejected_for_j = rejected_mask & (best_action_per_contract == j)
        if np.any(rejected_for_j):
            max_rej_pay = np.max((action_distributions[j] @ contracts[rejected_for_j].T))
            action_costs[j] = max(action_costs[j], max_rej_pay)
    
    return np.hstack([action_distributions, action_costs.reshape(-1, 1)])
```
