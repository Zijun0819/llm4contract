```python
import numpy as np
from scipy.optimize import linprog, minimize
from sklearn.cluster import KMeans
from sklearn.mixture import GaussianMixture

def agent_solver(v, content):
    accepted_logs = [log for log in content if log['Agent Action'] == 1]
    
    m_outcomes = len(v)
    L = len(content)
    
    if not accepted_logs:
        raise ValueError("No valid accepted logs to infer agent strategies.")
    
    if L <= 0:
        raise ValueError("No logs provided.")
    
    def compute_utility(p, w):
        return np.sum(p * w)
    
    def solve_lp_for_p(w, u):
        m = len(w)
        A_eq = [np.ones(m), v - w]
        b_eq = [1.0, u]
        bounds = [(0, 1)] * m
        try:
            result = linprog(w, A_eq=A_eq, b_eq=b_eq, bounds=bounds, method='highs')
            return result.x if result.success else None
        except:
            return None
    
    candidate_ps_raw = []
    for log in accepted_logs:
        w = np.array(log['Contract'])
        u = log['Principal Utility']
        p_candidate = solve_lp_for_p(w, u)
        if p_candidate is not None:
            candidate_ps_raw.append(p_candidate)
    
    if not candidate_ps_raw:
        raise ValueError("No valid LP solutions from accepted logs.")
    
    all_p_raw = np.array(candidate_ps_raw)
    
    n_components_init = min(10, len(all_p_raw))
    gmm = GaussianMixture(n_components=n_components_init, random_state=42, max_iter=1000)
    gmm.fit(all_p_raw)
    
    best_n = gmm.means_.shape[0]
    candidate_ps = gmm.means_
    
    w_accepted = np.array([log['Contract'] for log in accepted_logs])
    
    cluster_labels = gmm.predict(all_p_raw)
    cluster_sizes = np.bincount(cluster_labels)
    
    valid_clusters = [i for i, count in enumerate(cluster_sizes) if count > 0]
    n_actions = len(valid_clusters)
    candidate_ps = candidate_ps[valid_clusters]
    
    lowest_payout = np.zeros(n_actions)
    for i, cluster_idx in enumerate(valid_clusters):
        cluster_points = np.where(cluster_labels == cluster_idx)[0]
        wage_min = w_accepted[cluster_points].min(axis=0)
        lowest_payout[i] = candidate_ps[i].dot(wage_min)
    
    def compute_satisfaction_full(params):
        c_vec = params
        total_violation = 0.0
        
        for log in content:
            w_t = np.array(log['Contract'])
            if log['Agent Action'] == 1:
                action_utils = np.sum((candidate_ps * w_t[np.newaxis, :]), axis=1) - c_vec
                best_util = action_utils.max()
                if best_util < 0:
                    total_violation += abs(best_util)
                elif best_util > 0:
                    chosen_action = action_utils.argmax()
                    others = [j for j in range(n_actions) if j != chosen_action]
                    for j in others:
                        util_j = np.sum(candidate_ps[j] * w_t) - c_vec[j]
                        if util_j > best_util:
                            total_violation += (util_j - best_util)
            else:
                action_utils = np.sum((candidate_ps * w_t[np.newaxis, :]), axis=1) - c_vec
                best_util = action_utils.max()
                if best_util >= 0:
                    total_violation += (best_util + 1e-6)
        
        neg_reward = np.sum(np.maximum(-c_vec, 0))
        return total_violation + neg_reward
    
    initial_c = np.maximum(lowest_payout, 0)
    bounds = [(0, None)] * n_actions
    res = minimize(compute_satisfaction_full, initial_c, bounds=bounds, method='L-BFGS-B')
    
    if not res.success:
        final_c = initial_c
    else:
        final_c = np.maximum(res.x, 0)
    
    agent_setting = np.hstack((candidate_ps, final_c.reshape(-1, 1)))
    return agent_setting
```
