```python
import numpy as np
import pandas as pd
from scipy.optimize import minimize, Bounds, LinearConstraint
from sklearn.mixture import GaussianMixture
from sklearn.preprocessing import StandardScaler

def agent_solver_v2(v: np.ndarray, content: list[dict]) -> np.ndarray:
    logs = pd.DataFrame(content)
    n_outcomes = len(v)
    accepted = logs[logs['Agent Action'] == 1]
    rejected = logs[logs['Agent Action'] == -1]
    
    if accepted.empty:
        return np.hstack([np.eye(n_outcomes), np.zeros((n_outcomes, 1))])
    
    accepted_contracts = np.vstack(accepted['Contract'].values)
    
    scaler = StandardScaler()
    scaled_contracts = scaler.fit_transform(accepted_contracts)
    
    n_components_range = range(1, min(11, len(accepted) + 1))
    best_gmm = None
    best_bic = np.inf
    for n_components in n_components_range:
        gmm = GaussianMixture(n_components=n_components, random_state=42, n_init=3)
        gmm.fit(scaled_contracts)
        bic = gmm.bic(scaled_contracts)
        if bic < best_bic:
            best_bic = bic
            best_gmm = gmm
    
    n_actions = best_gmm.n_components
    cluster_probs = best_gmm.predict_proba(scaled_contracts)
    p_matrix = np.zeros((n_actions, n_outcomes))
    for a in range(n_actions):
        weights = cluster_probs[:, a]
        if weights.sum() > 0:
            p_matrix[a] = np.average(accepted_contracts, axis=0, weights=weights)
        else:
            p_matrix[a] = np.ones(n_outcomes) / n_outcomes
        p_matrix[a] /= p_matrix[a].sum()
    
    costs = np.zeros(n_actions)
    for a in range(n_actions):
        action_utils = accepted_contracts @ p_matrix[a]
        if len(action_utils) > 0:
            costs[a] = max(0, np.min(action_utils))
        else:
            costs[a] = 0.0
    
    if not rejected.empty:
        rejected_contracts = np.vstack(rejected['Contract'].values)
        for a in range(n_actions):
            rej_utils = rejected_contracts @ p_matrix[a]
            if np.any(rej_utils >= costs[a]):
                costs[a] = np.max(rej_utils[rej_utils >= costs[a]]) + 1e-8
    
    def objective(params):
        p_flat = params[:n_actions * n_outcomes].reshape(n_actions, n_outcomes)
        c = params[n_actions * n_outcomes:]
        total_violation = 0.0
        
        for _, row in logs.iterrows():
            w = np.array(row['Contract'])
            utils = p_flat @ w - c
            max_util = np.max(utils)
            if row['Agent Action'] == 1:
                if max_util < 0:
                    total_violation += -max_util
                chosen_util = utils[np.argmax(utils)]
                if chosen_util < 0:
                    total_violation += -chosen_util
            else:
                if max_util >= 0:
                    total_violation += max_util
        
        return total_violation
    
    def constraint_sum_to_one(params):
        p_flat = params[:n_actions * n_outcomes].reshape(n_actions, n_outcomes)
        return np.array([np.sum(p_flat[a]) - 1 for a in range(n_actions)])
    
    initial_params = np.concatenate([p_matrix.flatten(), costs])
    bounds = Bounds([0] * (n_actions * n_outcomes) + [0] * n_actions, 
                    [1] * (n_actions * n_outcomes) + [np.inf] * n_actions)
    
    constraints = [{'type': 'eq', 'fun': constraint_sum_to_one}]
    
    res = minimize(objective, initial_params, method='SLSQP', 
                   bounds=bounds, constraints=constraints, 
                   options={'maxiter': 100, 'ftol': 1e-6})
    
    if res.success:
        p_opt = res.x[:n_actions * n_outcomes].reshape(n_actions, n_outcomes)
        c_opt = res.x[n_actions * n_outcomes:]
        return np.hstack([p_opt, c_opt[:, np.newaxis]])
    else:
        return np.hstack([p_matrix, costs[:, np.newaxis]])
```
