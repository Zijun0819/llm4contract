```python
import numpy as np
import pandas as pd
from scipy.optimize import linprog
from sklearn.cluster import KMeans
from sklearn.metrics.pairwise import euclidean_distances

def agent_solver(v, content):
    n_candidates = max(min(len(content) // 5, 12), 3)
    m_outcomes = len(v)
    
    accepted_logs = [log for log in content if log['Agent Action'] == 1]
    rejected_logs = [log for log in content if log['Agent Action'] == -1]
    
    w_accepted = np.array([log['Contract'] for log in accepted_logs])
    u_accepted = np.array([log['Principal Utility'] for log in accepted_logs])
    
    def solve_distribution(w, u, v):
        try:
            c = -w
            A_eq = np.vstack([np.ones(len(w)), v - w])
            b_eq = np.array([1, u])
            bounds = [(0, 1) for _ in range(len(w))]
            res = linprog(c, A_eq=A_eq, b_eq=b_eq, bounds=bounds, method='highs')
            return res.x if res.success else None
        except:
            return None
    
    distributions = []
    for i in range(len(w_accepted)):
        p = solve_distribution(w_accepted[i], u_accepted[i], v)
        if p is not None:
            distributions.append(p)
    
    if not distributions:
        return np.column_stack([np.eye(len(v)), np.zeros(len(v))])
    
    distributions = np.array(distributions)
    
    if len(distributions) > n_candidates:
        kmeans = KMeans(n_clusters=n_candidates, n_init=10, random_state=0).fit(distributions)
        p_clusters = kmeans.cluster_centers_
    else:
        p_clusters = distributions.copy()
        n_candidates = len(distributions)
    
    p_clusters = np.maximum(p_clusters, 0)
    p_clusters /= np.sum(p_clusters, axis=1, keepdims=True)
    
    w_rejected = np.array([log['Contract'] for log in rejected_logs]) if rejected_logs else None
    
    costs = np.zeros(n_candidates)
    for a in range(n_candidates):
        relevant_utils = []
        for i, log in enumerate(accepted_logs):
            if euclidean_distances([distributions[i]], [p_clusters[a]])[0][0] < 0.1:
                relevant_utils.append(np.dot(p_clusters[a], log['Contract']))
        
        if relevant_utils:
            costs[a] = min(relevant_utils)
        else:
            if w_rejected is not None:
                rejection_utils = np.dot(p_clusters[a], w_rejected.T)
                costs[a] = np.max(rejection_utils) + 1e-8
            else:
                costs[a] = 0.0
    
    if w_rejected is not None and len(w_rejected) > 0:
        valid_rejection = np.zeros(n_candidates, dtype=bool)
        for a in range(n_candidates):
            rejection_utils = np.dot(p_clusters[a], w_rejected.T)
            valid_rejection[a] = np.all(rejection_utils < costs[a] - 1e-6)
        
        while not np.all(valid_rejection):
            for a in np.where(~valid_rejection)[0]:
                rejection_utils = np.dot(p_clusters[a], w_rejected.T)
                costs[a] = np.max(rejection_utils) + 1e-8
            
            valid_rejection = np.zeros(n_candidates, dtype=bool)
            for a in range(n_candidates):
                rejection_utils = np.dot(p_clusters[a], w_rejected.T)
                valid_rejection[a] = np.all(rejection_utils < costs[a] - 1e-6)
    
    for a in range(n_candidates):
        acceptance_check = np.array([np.dot(p_clusters[a], log['Contract']) for log in accepted_logs])
        if not np.any(acceptance_check >= costs[a] - 1e-6):
            costs[a] = np.min(acceptance_check) if len(acceptance_check) > 0 else 0.0
    
    result = np.hstack([p_clusters, costs.reshape(-1, 1)])
    return result
```
