```python
import numpy as np
from scipy.optimize import linprog
from sklearn.mixture import GaussianMixture
from sklearn.cluster import KMeans
from sklearn.metrics import pairwise_distances_argmin_min

def agent_solver(v: np.ndarray, content: list[dict]) -> np.ndarray:
    accepted_logs = [log for log in content if log['Agent Action'] == 1]
    rejected_logs = [log for log in content if log['Agent Action'] == -1]
    n_outcomes = len(v)
    
    if not accepted_logs:
        return np.hstack([np.eye(n_outcomes), np.zeros((n_outcomes, 1))])
    
    def solve_lp(w, u_principal):
        A_eq = np.vstack([np.ones(n_outcomes), v - w])
        b_eq = np.array([1.0, u_principal])
        res = linprog(-w, A_eq=A_eq, b_eq=b_eq, bounds=[(0, 1)] * n_outcomes, method='highs')
        return res.x if res.success else None
    
    candidate_ps = []
    for log in accepted_logs:
        p_candidate = solve_lp(np.array(log['Contract']), log['Principal Utility'])
        if p_candidate is not None:
            candidate_ps.append(p_candidate)
    
    if not candidate_ps:
        return np.hstack([np.eye(n_outcomes), np.zeros((n_outcomes, 1))])
    
    candidate_ps = np.array(candidate_ps)
    n_clusters = min(50, max(2, len(candidate_ps) // 3))
    kmeans = KMeans(n_clusters=n_clusters, random_state=42, n_init=20).fit(candidate_ps)
    kmeans_centers = kmeans.cluster_centers_
    kmeans_centers = np.clip(kmeans_centers, 0, None)
    kmeans_centers /= kmeans_centers.sum(axis=1, keepdims=True)
    
    gmm = GaussianMixture(n_components=n_clusters, random_state=42, n_init=10)
    gmm.fit(candidate_ps)
    gmm_centers = gmm.means_
    gmm_centers = np.clip(gmm_centers, 0, None)
    gmm_centers /= gmm_centers.sum(axis=1, keepdims=True)
    
    accepted_contracts = np.array([log['Contract'] for log in accepted_logs])
    kmeans_utilities = accepted_contracts @ kmeans_centers.T
    kmeans_costs = np.zeros(n_clusters)
    for i in range(n_clusters):
        if np.any(kmeans_utilities[:, i] > -np.inf):
            kmeans_costs[i] = np.min(kmeans_utilities[:, i]) - 1e-10
        else:
            kmeans_costs[i] = 0.0
    
    gmm_utilities = accepted_contracts @ gmm_centers.T
    gmm_costs = np.zeros(n_clusters)
    for i in range(n_clusters):
        if np.any(gmm_utilities[:, i] > -np.inf):
            gmm_costs[i] = np.min(gmm_utilities[:, i]) - 1e-10
        else:
            gmm_costs[i] = 0.0
    
    if rejected_logs:
        rejected_contracts = np.array([log['Contract'] for log in rejected_logs])
        rejected_kmeans = rejected_contracts @ kmeans_centers.T
        max_rejected_kmeans = np.max(rejected_kmeans, axis=0)
        kmeans_costs = np.maximum(kmeans_costs, max_rejected_kmeans + 1e-10)
        
        rejected_gmm = rejected_contracts @ gmm_centers.T
        max_rejected_gmm = np.max(rejected_gmm, axis=0)
        gmm_costs = np.maximum(gmm_costs, max_rejected_gmm + 1e-10)
    
    kmeans_costs = np.maximum(kmeans_costs, 0)
    gmm_costs = np.maximum(gmm_costs, 0)
    
    combined_centers = np.vstack([kmeans_centers, gmm_centers])
    combined_costs = np.hstack([kmeans_costs, gmm_costs])
    
    unique_centers, inverse = np.unique(combined_centers, axis=0, return_inverse=True)
    unique_costs = np.array([np.min(combined_costs[inverse == i]) for i in range(len(unique_centers))])
    
    final_kmeans = KMeans(n_clusters=n_clusters, random_state=42, n_init=20).fit(unique_centers)
    final_centers = final_kmeans.cluster_centers_
    final_centers = np.clip(final_centers, 0, None)
    final_centers /= final_centers.sum(axis=1, keepdims=True)
    
    final_costs = np.zeros(n_clusters)
    for i in range(n_clusters):
        member_indices = np.where(final_kmeans.labels_ == i)[0]
        if member_indices.size > 0:
            final_costs[i] = np.min(unique_costs[member_indices])
        else:
            final_costs[i] = 0.0
    
    return np.hstack([final_centers, final_costs.reshape(-1, 1)])
```
