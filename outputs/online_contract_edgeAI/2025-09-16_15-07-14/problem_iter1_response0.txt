```python
import numpy as np
import pandas as pd
from scipy.optimize import linprog
from sklearn.cluster import KMeans
from functools import lru_cache

def agent_solver(v, content):
    n_outcomes = len(v)
    accepted_logs = [log for log in content if log['Agent Action'] == 1]
    rejected_logs = [log for log in content if log['Agent Action'] == -1]
    
    @lru_cache(maxsize=None)
    def compute_minimal_cost(wage_vector):
        c_vec = np.zeros(n_outcomes)
        for outcome in range(n_outcomes):
            mask = np.ones(n_outcomes, dtype=bool)
            mask[outcome] = False
            constraints = [{'type': 'eq', 'fun': lambda p: np.sum(p) - 1},
                           {'type': 'ineq', 'fun': lambda p: np.dot(p, wage_vector) - np.dot(p, c_vec)}]
            res = linprog(c_vec, A_eq=np.ones((1, n_outcomes)), b_eq=[1], bounds=[(0, 1)]*n_outcomes, method='highs')
            if res.success:
                minimal_utility = np.dot(res.x, wage_vector)
                c_vec[outcome] = max(0, minimal_utility - np.dot(res.x, c_vec))
        return np.max(c_vec)
    
    actions_data = []
    for log in accepted_logs:
        wage = np.array(log['Contract'])
        principal_utility = log['Principal Utility']
        p_opt = linprog(-wage, A_eq=np.vstack([np.ones(n_outcomes), v - wage]), 
                        b_eq=[1, principal_utility], bounds=[(0, 1)]*n_outcomes, method='highs')
        if p_opt.success:
            actions_data.append((p_opt.x, compute_minimal_cost(tuple(wage))))
    
    if not actions_data:
        raise ValueError("No valid actions inferred from accepted contracts")
    
    p_vectors = np.array([data[0] for data in actions_data])
    kmeans = KMeans(n_clusters=min(10, len(actions_data)), random_state=42, n_init=10).fit(p_vectors)
    unique_actions = kmeans.cluster_centers_
    n_actions = len(unique_actions)
    
    costs = np.zeros(n_actions)
    for i, center in enumerate(unique_actions):
        cluster_costs = []
        for idx in np.where(kmeans.labels_ == i)[0]:
            cluster_costs.append(actions_data[idx][1])
        costs[i] = np.max(cluster_costs) if cluster_costs else 0.0
    
    agent_setting = np.hstack([unique_actions, costs.reshape(-1, 1)])
    
    for reject_log in rejected_logs:
        wage_reject = np.array(reject_log['Contract'])
        action_utilities = np.array([np.dot(agent_setting[i, :-1], wage_reject) - agent_setting[i, -1] for i in range(n_actions)])
        if np.any(action_utilities >= 0):
            violating_actions = np.where(action_utilities >= 0)[0]
            for idx in violating_actions:
                agent_setting[idx, -1] += action_utilities[idx] + 1e-6
    
    return agent_setting
```
