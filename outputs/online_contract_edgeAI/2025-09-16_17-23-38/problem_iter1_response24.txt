```python
import numpy as np
import pandas as pd
from scipy.optimize import linprog
from sklearn.cluster import KMeans
from sklearn.decomposition import PCA

def agent_solver(v: np.ndarray, content: pd.DataFrame) -> np.ndarray:
    n_candidates = 12
    m = len(v)
    L = len(content)

    def solve_distribution(w: np.ndarray, utility: float) -> np.ndarray | None:
        A_eq = np.array([np.ones(m), v - w])
        b_eq = np.array([1.0, utility])
        c = np.zeros(m)
        bounds = [(0, 1)] * m
        res = linprog(c, A_eq=A_eq, b_eq=b_eq, bounds=bounds, method='highs')
        return res.x if res.success else None

    candidate_dists = []
    acceptance_utilities = []

    for _, row in content.iterrows():
        if row['Agent Action'] == 1:
            contract = np.array(row['Contract'])
            principal_utility = row['Principal Utility']
            p = solve_distribution(contract, principal_utility)
            if p is not None:
                candidate_dists.append(p)
                acceptance_utilities.append(principal_utility)

    if len(candidate_dists) < 2:
        raise ValueError("Not enough accepted contracts to infer agent behavior.")

    candidate_dists = np.array(candidate_dists)

    if candidate_dists.shape[0] > n_candidates:
        pca = PCA(n_components=min(n_candidates, candidate_dists.shape[1]))
        reduced_dists = pca.fit_transform(candidate_dists)
        kmeans = KMeans(n_clusters=n_candidates, random_state=42, n_init=10).fit(reduced_dists)
        centers_reduced = kmeans.cluster_centers_
        centers = pca.inverse_transform(centers_reduced)
        centers = np.clip(centers, 0, 1)
        centers = centers / centers.sum(axis=1, keepdims=True)
    else:
        centers = candidate_dists
        n_candidates = len(centers)

    assignments = -np.ones(L, dtype=int)
    for i, row in content.iterrows():
        if row['Agent Action'] == 1:
            contract = np.array(row['Contract'])
            utilities = centers @ contract
            assignments[i] = np.argmax(utilities)

    costs = np.zeros(n_candidates)
    for a in range(n_candidates):
        indices = np.where(assignments == a)[0]
        if len(indices) > 0:
            wages = np.array([content.iloc[i]['Contract'] for i in indices])
            costs[a] = centers[a] @ wages.min(axis=0)
        else:
            costs[a] = 0.0

    for i, row in content.iterrows():
        if row['Agent Action'] == -1:
            contract = np.array(row['Contract'])
            expected_utilities = centers @ contract
            max_util = np.max(expected_utilities)
            for a in range(n_candidates):
                if costs[a] > max_util:
                    costs[a] = max_util

    costs = np.maximum(costs, 0)

    agent_setting = np.hstack([centers, costs.reshape(-1, 1)])
    return agent_setting
```
