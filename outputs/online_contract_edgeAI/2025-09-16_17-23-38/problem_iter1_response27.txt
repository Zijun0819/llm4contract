```python
import numpy as np
import pandas as pd
from scipy.optimize import linprog
from sklearn.cluster import KMeans
from sklearn.metrics import pairwise_distances_argmin_min


def agent_solver(v: np.ndarray, content: pd.DataFrame) -> np.ndarray:
    n_action_candidates = 10
    n_outcomes = v.shape[0]
    n_logs = content.shape[0]

    def solve_distribution(w: np.ndarray, util: float) -> np.ndarray | None:
        A_eq = np.vstack([np.ones(n_outcomes), v - w])
        b_eq = np.array([1.0, util])
        bounds = [(0, 1)] for _ in range(n_outcomes)]
        res = linprog(np.zeros(n_outcomes), A_eq=A_eq, b_eq=b_eq, bounds=bounds, method='highs')
        return res.x if res.success else None

    # Step 1: Extract accepted contracts and infer distributions
    candidate_dists = []
    for _, row in content.iterrows():
        if row['Agent Action'] == 1:
            contract = np.array(row['Contract'])
            util = row['Principal Utility']
            p = solve_distribution(contract, util)
            if p is not None:
                candidate_dists.append(p)

    if not candidate_dists:
        raise ValueError("No valid accepted contracts to infer distributions.")

    dist_matrix = np.array(candidate_dists)
    
    # Step 2: Cluster to get representative actions
    kmeans = KMeans(n_clusters=n_action_candidates, random_state=42, n_init=10).fit(dist_matrix)
    representative_dists = kmeans.cluster_centers_

    # Step 3: Assign logs to representative actions
    assignments = np.full(n_logs, -1, dtype=int)
    for i, (_, row) in enumerate(content.iterrows()):
        if row['Agent Action'] == 1:
            contract = np.array(row['Contract'])
            assigned_idx = np.argmax(representative_dists @ contract)
            assignments[i] = assigned_idx

    # Step 4: Estimate costs from acceptance
    costs_ir = np.zeros(n_action_candidates)
    for a in range(n_action_candidates):
        idx = np.where(assignments == a)[0]
        if len(idx) > 0:
            wages = np.array([content.iloc[i]['Contract'] for i in idx])
            costs_ir[a] = np.min(representative_dists[a] @ wages.T)
        else:
            costs_ir[a] = 0.0

    # Step 5: Adjust for rejections
    costs_rej = np.zeros(n_action_candidates)
    for i, (_, row) in enumerate(content.iterrows()):
        if row['Agent Action'] == -1:
            contract = np.array(row['Contract'])
            utilities = representative_dists @ contract
            costs_rej = np.maximum(costs_rej, utilities)

    # Step 6: Final costs are max of IR and rejection constraints
    final_costs = np.maximum(costs_ir, costs_rej)

    # Step 7: Construct agent setting
    agent_setting = np.hstack([representative_dists, final_costs[:, np.newaxis]])
    return agent_setting
```
