```python
import numpy as np
import pandas as pd
from scipy.optimize import linprog
from sklearn.cluster import KMeans

def agent_solver_v2(v: np.ndarray, content: list[dict]) -> np.ndarray:
    m_outcomes = len(v)
    n_candidates = 10
    L = len(content)
    
    if isinstance(content, pd.DataFrame):
        contracts = np.vstack(content['Contract'].values)
        principal_utils = content['Principal Utility'].values
        agent_actions = content['Agent Action'].values
    else:
        contracts = np.array([log['Contract'] for log in content])
        principal_utils = np.array([log['Principal Utility'] for log in content])
        agent_actions = np.array([log['Agent Action'] for log in content])

    candidate_ps = []
    accepted_indices = agent_actions == 1
    if not np.any(accepted_indices):
        raise ValueError("No accepted contracts to infer agent strategies.")

    accepted_contracts = contracts[accepted_indices]
    accepted_principal_utils = principal_utils[accepted_indices]

    for i in range(len(accepted_contracts)):
        w_i = accepted_contracts[i]
        u_i = accepted_principal_utils[i]
        
        A_eq = np.array([np.ones(m_outcomes), v - w_i])
        b_eq = np.array([1.0, u_i])
        bounds = [(0, 1)] * m_outcomes
        
        res = linprog(np.zeros(m_outcomes), A_eq=A_eq, b_eq=b_eq, bounds=bounds, method='highs')
        if res.success:
            candidate_ps.append(res.x)

    if not candidate_ps:
        raise ValueError("No valid LP solutions found for accepted contracts.")
    
    candidate_ps = np.array(candidate_ps)
    
    if len(candidate_ps) < n_candidates:
        n_candidates = len(candidate_ps)
    
    kmeans = KMeans(n_clusters=n_candidates, random_state=42, n_init=10).fit(candidate_ps)
    p0 = kmeans.cluster_centers_

    assignments = np.full(L, -1, dtype=int)
    for i in range(L):
        if agent_actions[i] == 1:
            contract = contracts[i]
            utilities = p0 @ contract
            assignments[i] = np.argmax(utilities)

    c_ir = np.zeros(n_candidates)
    for a in range(n_candidates):
        action_indices = np.where(assignments == a)[0]
        if len(action_indices) > 0:
            wages = contracts[action_indices].T
            c_ir[a] = np.dot(p0[a], np.min(wages, axis=1))
        else:
            c_ir[a] = 0.0

    c_rej = np.full(n_candidates, -np.inf)
    rejected_indices = agent_actions == -1
    if np.any(rejected_indices):
        rejected_wages = contracts[rejected_indices].T
        for a in range(n_candidates):
            expected_wages = p0[a] @ rejected_wages
            c_rej[a] = np.max(expected_wages)
    
    c_rej = np.where(c_rej == -np.inf, 0, c_rej)

    c_init = np.maximum(c_ir, c_rej)
    c_init = np.maximum(c_init, 0)  # Ensure non-negative costs
    
    # Normalize probability distributions
    p0 = p0 / p0.sum(axis=1, keepdims=True)
    
    agent_setting = np.hstack([p0, c_init[:, np.newaxis]])
    
    return agent_setting
```
