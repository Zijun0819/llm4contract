```python
import numpy as np
import pandas as pd
from scipy.optimize import linprog
from sklearn.decomposition import PCA
from sklearn.cluster import KMeans

def agent_solver_v2(v: np.ndarray, content) -> np.ndarray:
    m_outcomes = len(v)
    
    if isinstance(content, pd.DataFrame):
        contracts = np.vstack(content['Contract'].values)
        principal_utils = content['Principal Utility'].values
        agent_actions = content['Agent Action'].values
    else:
        contracts = np.array([log['Contract'] for log in content])
        principal_utils = np.array([log['Principal Utility'] for log in content])
        agent_actions = np.array([log['Agent Action'] for log in content])

    candidate_ps = []
    accepted_indices = agent_actions == 1
    if not np.any(accepted_indices):
        raise ValueError("No accepted contracts to infer agent strategies.")

    accepted_contracts = contracts[accepted_indices]
    accepted_principal_utils = principal_utils[accepted_indices]

    for i in range(len(accepted_contracts)):
        w_i = accepted_contracts[i]
        u_i = accepted_principal_utils[i]
        
        A_eq = np.array([np.ones(m_outcomes), v - w_i])
        b_eq = np.array([1.0, u_i])
        bounds = [(0, 1)] * m_outcomes
        
        res = linprog(np.zeros(m_outcomes), A_eq=A_eq, b_eq=b_eq, bounds=bounds, method='highs')
        if res.success:
            candidate_ps.append(res.x)

    if not candidate_ps:
        raise ValueError("No valid LP solutions found for accepted contracts.")
    
    candidate_ps = np.array(candidate_ps)
    
    # PCA for dimensionality reduction
    n_samples = candidate_ps.shape[0]
    if n_samples > 3 and n_samples >= m_outcomes:
        n_components = min(3, m_outcomes)
        pca = PCA(n_components=n_components)
        candidate_ps_pca = pca.fit_transform(candidate_ps)
    else:
        candidate_ps_pca = candidate_ps
        pca = None

    # Adaptive number of clusters using elbow method
    max_k = min(15, len(candidate_ps_pca))
    if max_k < 2:
        n_candidates = 2
    else:
        distortions = []
        K_range = range(1, max_k + 1) if max_k >= 2 else range(1, 2)
        for k in K_range:
            kmeans = KMeans(n_clusters=k, random_state=42, n_init=100).fit(candidate_ps_pca)
            distortions.append(kmeans.inertia_)
        
        if len(distortions) > 2:
            diffs = np.diff(distortions)
            diffs2 = np.diff(diffs)
            elbow_idx = np.argmax(diffs2) + 1
            n_candidates = max(2, min(elbow_idx, max_k))
        else:
            n_candidates = min(5, max_k)
    
    if n_candidates > len(candidate_ps_pca):
        n_candidates = len(candidate_ps_pca)

    kmeans = KMeans(n_clusters=n_candidates, random_state=42, n_init=100).fit(candidate_ps_pca)
    if pca is not None and candidate_ps.shape[0] > 3:
        p0_pca = kmeans.cluster_centers_
        p0 = pca.inverse_transform(p0_pca)
    else:
        p0 = kmeans.cluster_centers_

    # Normalize probabilities
    p0 = np.clip(p0, 0, 1)
    row_sums = p0.sum(axis=1, keepdims=True)
    row_sums[row_sums == 0] = 1
    p0 /= row_sums

    # Assignments for all contracts using utility maximization with stricter slack
    assignments = np.full(len(contracts), -1, dtype=int)
    utility_slack = 1e-10
    for i in range(len(contracts)):
        contract = contracts[i]
        utilities = p0 @ contract
        if agent_actions[i] == 1:
            # Accept: choose action with highest utility, but ensure at least one is >= 0
            max_util = np.max(utilities)
            if max_util < -utility_slack:
                assignments[i] = np.argmax(utilities)
            else:
                # Prefer non-negative utility actions
                viable = utilities >= -utility_slack
                if np.any(viable):
                    assignments[i] = np.argmax(np.where(viable, utilities, -np.inf))
                else:
                    assignments[i] = np.argmax(utilities)
        else:
            # Reject: ensure assigned action has negative utility
            penalty_utilities = np.where(utilities >= utility_slack, -np.inf, utilities)
            if np.all(penalty_utilities == -np.inf):
                # All utilities are non-negative; pick the one with minimal utility
                assignments[i] = np.argmin(utilities)
            else:
                assignments[i] = np.argmax(penalty_utilities)

    # Compute costs from IR constraints with stricter slack
    c_ir = np.full(n_candidates, -np.inf)
    for a in range(n_candidates):
        accepted_by_action = (assignments == a) & (agent_actions == 1)
        if np.any(accepted_by_action):
            wages = contracts[accepted_by_action]  # shape (n, 12)
            expected_utilities = p0[a] @ wages.T  # shape (n,)
            min_expected_utility = np.min(expected_utilities)
            c_ir[a] = min_expected_utility

    # Compute costs from IC constraints for rejections
    c_rej = np.full(n_candidates, -np.inf)
    rejected_indices = agent_actions == -1
    if np.any(rejected_indices):
        rejected_wages = contracts[rejected_indices]  # shape (n_rej, 12)
        for a in range(n_candidates):
            expected_wages = p0[a] @ rejected_wages.T  # shape (n_rej,)
            c_rej[a] = np.max(expected_wages)

    # Compute final costs with minimal slack
    slack = 1e-10
    c_final = np.maximum(c_ir, c_rej) + slack

    # Regularization: Ensure strictly positive cost where necessary
    for a in range(n_candidates):
        assigned_indices = assignments == a
        if np.any(assigned_indices):
            if c_final[a] <= 0:
                avg_wage = np.mean(contracts[assigned_indices], axis=0)
                c_final[a] = np.dot(p0[a], avg_wage) + slack

    # Ensure non-negative costs
    c_final = np.maximum(0, c_final)
    
    agent_setting = np.hstack([p0, c_final[:, np.newaxis]])
    
    return agent_setting
```
