```python
import numpy as np
from sklearn.cluster import KMeans
from scipy.optimize import linprog
from sklearn.preprocessing import normalize

def agent_solver_v2(v: np.ndarray, content: list[dict]) -> np.ndarray:
    n_actions = 5
    m_outcomes = len(v)
    contracts = [log['Contract'] for log in content]
    actions = [log['Agent Action'] for log in content]
    contracts = np.array(contracts)

    def solve_lp(contract):
        c = -contract
        A_eq = np.array([[1] * m_outcomes])
        b_eq = np.array([1])
        bounds = [(0, 1)] * m_outcomes
        res = linprog(c, A_eq=A_eq, b_eq=b_eq, bounds=bounds, method='highs')
        if res.success:
            return res.x
        else:
            return None

    possible_distributions = []
    for i in range(len(content)):
        if actions[i] == 1:
            distribution = solve_lp(contracts[i])
            if distribution is not None:
                possible_distributions.append(distribution)

    if not possible_distributions:
        dummy_distribution = np.ones(m_outcomes) / m_outcomes
        possible_distributions = [dummy_distribution]
        n_actions = 1
    else:
        possible_distributions = np.array(possible_distributions)
        kmeans = KMeans(n_clusters=min(n_actions, len(possible_distributions)), random_state=0, n_init=10)
        kmeans.fit(possible_distributions)
        n_actions = kmeans.n_clusters
        possible_distributions = kmeans.cluster_centers_

    costs = np.zeros(n_actions)
    for j in range(n_actions):
        min_rej_val = float('inf')
        for i in range(len(content)):
            if actions[i] == -1:
                utility = possible_distributions[j] @ contracts[i]
                min_rej_val = min(min_rej_val, utility)
        costs[j] = max(0, -min_rej_val)

    agent_settings = np.hstack([possible_distributions, costs[:, np.newaxis]])
    return agent_settings
```
