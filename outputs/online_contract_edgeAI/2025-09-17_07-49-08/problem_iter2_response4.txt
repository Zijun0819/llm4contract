```python
import numpy as np
from sklearn.cluster import KMeans
from sklearn.preprocessing import normalize
from scipy.optimize import linprog

def agent_solver_v2(v: np.ndarray, content: list[dict]) -> np.ndarray:
    n_candidates = 5
    m_outcomes = v.shape[0]
    
    def solve_lp(contract, accept):
        c = -contract
        A_eq = np.array([[1] * m_outcomes])
        b_eq = np.array([1])
        bounds = [(0, 1)] * m_outcomes
        
        if accept == 1:
            res = linprog(c, A_eq=A_eq, b_eq=b_eq, bounds=bounds)
            if res.success:
                return res.x, -res.fun
            else:
                return None, None
        else:
            A_ub = np.array([contract])
            b_ub = np.array([0])
            res = linprog(c, A_eq=A_eq, b_eq=b_eq, A_ub=A_ub, b_ub=b_ub, bounds=bounds)
            if res.success:
                return res.x, -res.fun
            else:
                return None, None

    candidate_ps = []
    for log in content:
        p, _ = solve_lp(np.array(log['Contract']), log['Agent Action'])
        if p is not None:
            candidate_ps.append(p)

    if not candidate_ps:
        return np.zeros((0, m_outcomes + 1))

    all_p = np.array(candidate_ps)
    all_p = normalize(all_p, axis=1, norm='l1')

    n_clusters = min(n_candidates, len(all_p))
    kmeans = KMeans(n_clusters=n_clusters, random_state=0, n_init=10)
    kmeans.fit(all_p)
    p0 = kmeans.cluster_centers_

    costs = np.zeros(p0.shape[0])
    for i in range(p0.shape[0]):
        min_rej_util = float('inf')
        for log in content:
            if log['Agent Action'] == -1:
                contract = np.array(log['Contract'])
                util = p0[i] @ contract
                min_rej_util = min(min_rej_util, util)
        costs[i] = max(0, -min_rej_util)

    agent_setting = np.hstack([p0, costs[:, np.newaxis]])
    return agent_setting
```
