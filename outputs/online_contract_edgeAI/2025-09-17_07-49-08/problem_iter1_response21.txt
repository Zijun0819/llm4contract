```python
import numpy as np
from scipy.optimize import linprog
from sklearn.cluster import KMeans

def agent_solver_v2(v: np.ndarray, content: list[dict]) -> np.ndarray:
    n_actions = 5
    n_outcomes = len(v)
    accepted_contracts = []
    for log in content:
        if log['Agent Action'] == 1:
            accepted_contracts.append((log['Contract'], log['Principal Utility']))

    if not accepted_contracts:
        raise ValueError("No accepted contracts found.")

    def solve_lp(contract, utility):
        A_eq = [np.ones(n_outcomes), v - np.array(contract)]
        b_eq = [1, utility]
        bounds = [(0, 1)] * n_outcomes
        result = linprog(v, A_eq=A_eq, b_eq=b_eq, bounds=bounds, method='highs')
        return result.x if result.success else None

    possible_actions = []
    for contract, utility in accepted_contracts:
        action = solve_lp(contract, utility)
        if action is not None:
            possible_actions.append(action)

    if not possible_actions:
        raise ValueError("Could not solve LP for any accepted contract.")

    kmeans = KMeans(n_clusters=n_actions, random_state=0, n_init=10)
    kmeans.fit(possible_actions)
    action_probabilities = kmeans.cluster_centers_

    costs = np.zeros(n_actions)
    for i in range(n_actions):
        utilities = []
        for contract, _ in accepted_contracts:
            utilities.append(np.dot(action_probabilities[i], contract))
        costs[i] = np.min(utilities)
        costs[i] = max(0, costs[i])

    for i in range(n_actions):
        rejection_utilities = []
        for log in content:
            if log['Agent Action'] == -1:
                rejection_utilities.append(np.dot(action_probabilities[i], log['Contract']))

        if rejection_utilities:
            max_rejection_utility = np.max(rejection_utilities)
            costs[i] = max(costs[i], max_rejection_utility)

    agent_setting = np.column_stack((action_probabilities, costs))
    return agent_setting
```
