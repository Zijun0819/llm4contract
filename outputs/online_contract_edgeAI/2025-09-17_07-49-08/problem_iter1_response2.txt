```python
import numpy as np
from scipy.optimize import linprog
from sklearn.cluster import KMeans
from sklearn.preprocessing import normalize

def agent_solver_v2(v: np.ndarray, content: list[dict]) -> np.ndarray:
    n_candidates = 5
    m_outcomes = v.shape[0]
    L = len(content)

    def solve_lp(w, accept):
        c = -w
        A_eq = np.array([[1] * m_outcomes])
        b_eq = np.array([1])
        bounds = [(0, 1)] * m_outcomes

        if accept == 1:
            res = linprog(c, A_eq=A_eq, b_eq=b_eq, bounds=bounds)
        else:
            A_ub = np.array([w - v])
            b_ub = np.array([0])
            res = linprog(c, A_eq=A_eq, b_eq=b_eq, A_ub=A_ub, b_ub=b_ub, bounds=bounds)

        if res.success:
            return res.x, -res.fun
        else:
            return None, None

    candidate_ps = []
    candidate_costs = []
    for log in content:
        p, util = solve_lp(log['Contract'], log['Agent Action'])
        if p is not None:
            candidate_ps.append(p)
            candidate_costs.append(util)

    if not candidate_ps:
        return np.array([])

    all_p = np.array(candidate_ps)
    all_p = normalize(all_p, axis=1, norm='l1')

    kmeans = KMeans(n_clusters=min(n_candidates, len(all_p)), random_state=0, n_init=10)
    kmeans.fit(all_p)
    p0 = kmeans.cluster_centers_

    costs = []
    for i in range(p0.shape[0]):
        costs.append(0)
        
    for i in range(p0.shape[0]):
        min_rej_val = float('inf')
        for log in content:
            if log['Agent Action'] == -1:
                util = p0[i] @ log['Contract']
                min_rej_val = min(min_rej_val, util)
        costs[i] = -min_rej_val if min_rej_val < 0 else 0

    agent_setting = np.hstack([p0, np.array(costs)[:, np.newaxis]])
    return agent_setting
```
