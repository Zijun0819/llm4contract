```python
import numpy as np
from scipy.optimize import linprog
from sklearn.cluster import KMeans


def agent_solver_v2(v: np.ndarray, content: list[dict]) -> np.ndarray:
    n_actions = 5
    m_outcomes = len(v)
    accepted_contracts = []
    rejected_contracts = []

    for log in content:
        if log['Agent Action'] == 1:
            accepted_contracts.append((log['Contract'], log['Principal Utility']))
        else:
            rejected_contracts.append(log['Contract'])

    if not accepted_contracts:
        return np.zeros((n_actions, m_outcomes + 1))

    def solve_lp(contract, utility):
        c = -v
        A_eq = [np.ones(m_outcomes), np.array(contract) - v]
        b_eq = [1, utility]
        bounds = [(0, 1)] * m_outcomes
        result = linprog(c, A_eq=A_eq, b_eq=b_eq, bounds=bounds, method='highs')
        if result.success:
            return result.x
        else:
            return None

    possible_actions = []
    for contract, utility in accepted_contracts:
        action = solve_lp(contract, utility)
        if action is not None:
            possible_actions.append(action)

    if not possible_actions:
        return np.zeros((n_actions, m_outcomes + 1))

    kmeans = KMeans(n_clusters=min(n_actions, len(possible_actions)), random_state=0, n_init=10)
    kmeans.fit(possible_actions)
    representative_actions = kmeans.cluster_centers_
    n_representative = len(representative_actions)

    costs = np.zeros(n_representative)
    for i in range(n_representative):
        min_utility = float('inf')
        for contract, utility in accepted_contracts:
            agent_utility = np.dot(representative_actions[i], contract)
            if agent_utility < min_utility:
                min_utility = agent_utility

        costs[i] = min_utility

    if rejected_contracts:
        for i in range(n_representative):
            max_rejection_utility = -float('inf')
            for contract in rejected_contracts:
                agent_utility = np.dot(representative_actions[i], contract)
                if agent_utility > max_rejection_utility:
                    max_rejection_utility = agent_utility
            costs[i] = max(costs[i], max_rejection_utility)

    agent_settings = np.concatenate((representative_actions, costs[:, np.newaxis]), axis=1)

    padding = np.zeros((max(0, n_actions - n_representative), m_outcomes + 1))
    agent_settings = np.concatenate((agent_settings, padding), axis=0)

    return agent_settings
```
