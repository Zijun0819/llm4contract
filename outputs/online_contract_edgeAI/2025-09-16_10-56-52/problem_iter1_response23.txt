```python
import numpy as np
import pandas as pd
from scipy.optimize import linprog, minimize
from sklearn.cluster import KMeans
from sklearn.metrics.pairwise import euclidean_distances

def agent_solver(v: np.ndarray, content: list[dict]) -> np.ndarray:
    m_outcomes = len(v)
    accepted_logs = [log for log in content if log['Agent Action'] == 1]
    rejected_logs = [log for log in content if log['Agent Action'] == -1]
    
    if not accepted_logs:
        return np.array([[1/m_outcomes]*m_outcomes + [0]])
    
    n_max = min(10, len(accepted_logs))
    if n_max == 0:
        n_max = 1
    
    def compute_best_p(w, u):
        c = -w
        A_eq = np.vstack([np.ones(m_outcomes), v - w])
        b_eq = np.array([1, u])
        bounds = [(0, 1)] * m_outcomes
        res = linprog(c, A_eq=A_eq, b_eq=b_eq, bounds=bounds, method='highs')
        return res.x if res.success else np.full(m_outcomes, 1/m_outcomes)
    
    all_p = np.array([compute_best_p(log['Contract'], log['Principal Utility']) for log in accepted_logs])
    
    distortions = []
    n_trials = min(6, n_max)
    for n in range(1, n_trials + 1):
        kmeans = KMeans(n_clusters=n, random_state=42, n_init=5).fit(all_p)
        distortions.append(kmeans.inertia_)
    
    best_n = np.argmin(np.diff(distortions)) + 2 if len(distortions) > 1 else 1
    best_n = min(max(1, best_n), n_max)
    
    kmeans = KMeans(n_clusters=best_n, random_state=42, n_init=10).fit(all_p)
    p_centers = kmeans.cluster_centers_
    
    assignments = {}
    for i, p in enumerate(all_p):
        dists = euclidean_distances([p], p_centers)
        assignments.setdefault(np.argmin(dists), []).append(accepted_logs[i]['Contract'])
    
    c_values = np.zeros(best_n)
    for a in range(best_n):
        contracts = assignments.get(a, [])
        if contracts:
            utils = [p_centers[a] @ c for c in contracts]
            c_values[a] = max(0, np.min(utils))
    
    if rejected_logs:
        rej_contracts = [log['Contract'] for log in rejected_logs]
        for a in range(best_n):
            rej_utils = [p_centers[a] @ c for c in rej_contracts]
            max_rej_util = max(rej_utils)
            if max_rej_util > c_values[a]:
                c_values[a] = max_rej_util
    
    result = np.hstack([p_centers, c_values.reshape(-1, 1)])
    return result
```
