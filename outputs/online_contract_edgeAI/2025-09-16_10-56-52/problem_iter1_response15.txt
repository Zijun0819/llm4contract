```python
import numpy as np
import pandas as pd
from scipy.optimize import linprog, minimize, Bounds, LinearConstraint
from sklearn.cluster import KMeans
from sklearn.mixture import GaussianMixture
from sklearn.preprocessing import normalize
from itertools import combinations

def agent_solver(v: np.ndarray, content: pd.DataFrame) -> np.ndarray:
    accepted_logs = [log for log in content if log['Agent Action'] == 1]
    rejected_logs = [log for log in content if log['Agent Action'] == -1]
    n_outcomes = v.shape[0]
    
    def compute_basis_p(w, u):
        m = n_outcomes
        c = w
        A_eq = np.vstack([np.ones(m), v - w])
        b_eq = np.array([1.0, u])
        bounds = Bounds(0, 1)
        constraints = LinearConstraint(A_eq, b_eq, b_eq)
        res = minimize(lambda p: np.dot(c, p), np.full(m, 1/m), bounds=bounds, constraints=constraints)
        return res.x if res.success else None

    p_candidates = []
    utilities = []
    for log in accepted_logs:
        p_candidate = compute_basis_p(np.array(log['Contract']), log['Principal Utility'])
        if p_candidate is not None:
            p_candidates.append(p_candidate)
            utilities.append(log['Principal Utility'])
    
    if not p_candidates:
        p_default = np.full(n_outcomes, 1/n_outcomes)
        c_default = 0.0
        return np.hstack([p_default.reshape(1, -1), np.array([[c_default]])])
    
    p_candidates = np.array(p_candidates)
    utilities = np.array(utilities)
    
    n_components_range = range(1, min(11, len(p_candidates) + 1))
    best_bic = np.inf
    best_gmm = None
    for n_components in n_components_range:
        gmm = GaussianMixture(n_components=n_components, random_state=0, n_init=5)
        gmm.fit(p_candidates)
        bic = gmm.bic(p_candidates)
        if bic < best_bic:
            best_bic = bic
            best_gmm = gmm
    
    n_actions = best_gmm.n_components
    action_probs = best_gmm.weights_
    action_means = best_gmm.means_
    
    action_assignments = best_gmm.predict(p_candidates)
    action_cost_bounds = [ [] for _ in range(n_actions) ]
    for idx, p_val in enumerate(p_candidates):
        action = action_assignments[idx]
        w = np.array(accepted_logs[idx]['Contract'])
        utility = utilities[idx]
        cost_lb = np.dot(action_means[action], w) - utility
        action_cost_bounds[action].append((cost_lb, np.inf))
    
    for log in rejected_logs:
        w_rej = np.array(log['Contract'])
        for a in range(n_actions):
            eu = np.dot(action_means[a], w_rej)
            action_cost_bounds[a].append((eu, np.inf))
    
    costs = np.zeros(n_actions)
    for a in range(n_actions):
        if action_cost_bounds[a]:
            lower_bounds = [lb for lb, ub in action_cost_bounds[a]]
            costs[a] = max(lower_bounds) if lower_bounds else 0.0
        else:
            costs[a] = 0.0
    
    for a in range(n_actions):
        if action_probs[a] < 1e-6:
            action_probs[a] = 0.0
    action_probs = action_probs / action_probs.sum()
    
    agent_setting = np.hstack([action_means, costs.reshape(-1, 1)])
    return agent_setting
```
