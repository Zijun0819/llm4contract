```python
import numpy as np
from scipy.optimize import linprog, minimize
from sklearn.mixture import GaussianMixture
from sklearn.neighbors import KernelDensity
import warnings
warnings.filterwarnings('ignore')

def agent_solver(v: np.ndarray, content: list[dict]) -> np.ndarray:
    num_outcomes = len(v)
    accepted_logs = [log for log in content if log['Agent Action'] == 1]
    rejected_logs = [log for log in content if log['Agent Action'] == -1]
    
    if not accepted_logs and not rejected_logs:
        default_p = np.ones(num_outcomes) / num_outcomes
        default_c = 0.0
        return np.hstack([default_p.reshape(1, -1), np.array([[default_c]])])
    
    candidate_ps = []
    for log in accepted_logs:
        w = np.array(log['Contract'])
        u = log['Principal Utility']
        try:
            A_eq = np.vstack([np.ones(num_outcomes), v - w])
            b_eq = np.array([1.0, u])
            res = linprog(-w, A_eq=A_eq, b_eq=b_eq, bounds=[(0, 1)] * num_outcomes, method='highs')
            if res.success:
                p = res.x
                if np.all(p >= -1e-8) and abs(np.sum(p) - 1) < 1e-8:
                    candidate_ps.append(np.clip(p, 0, 1))
        except:
            continue
            
    if not candidate_ps:
        candidate_ps = [np.ones(num_outcomes) / num_outcomes]
        
    candidate_ps = np.array(candidate_ps)
    max_clusters = min(10, len(candidate_ps))
    if max_clusters == 0:
        default_p = np.ones(num_outcomes) / num_outcomes
        default_c = 0.0
        return np.hstack([default_p.reshape(1, -1), np.array([[default_c]])])
    
    bic_scores = []
    for n in range(1, max_clusters + 1):
        gmm = GaussianMixture(n_components=n, random_state=42, n_init=10, max_iter=200)
        gmm.fit(candidate_ps)
        bic_scores.append(gmm.bic(candidate_ps))
    optimal_n = np.argmin(bic_scores) + 1
    
    gmm = GaussianMixture(n_components=optimal_n, random_state=42, n_init=10, max_iter=200)
    gmm.fit(candidate_ps)
    action_centers = gmm.means_
    action_centers = np.clip(action_centers, 0, 1)
    row_sums = action_centers.sum(axis=1, keepdims=True)
    action_centers = np.where(row_sums > 0, action_centers / row_sums, 1/num_outcomes)
    
    n_actions = action_centers.shape[0]
    lower_bounds = np.full(n_actions, -np.inf)
    upper_bounds = np.full(n_actions, np.inf)
    
    for i in range(n_actions):
        p_i = action_centers[i]
        for log in accepted_logs:
            w = np.array(log['Contract'])
            util = np.dot(p_i, w)
            if util >= 0:
                if lower_bounds[i] == -np.inf:
                    lower_bounds[i] = util
                else:
                    lower_bounds[i] = max(lower_bounds[i], util)
    
    for i in range(n_actions):
        p_i = action_centers[i]
        for log in rejected_logs:
            w = np.array(log['Contract'])
            util = np.dot(p_i, w)
            if util >= 0:
                if upper_bounds[i] == np.inf:
                    upper_bounds[i] = util
                else:
                    upper_bounds[i] = min(upper_bounds[i], util)
    
    initial_costs = np.zeros(n_actions)
    for i in range(n_actions):
        if lower_bounds[i] > -np.inf and upper_bounds[i] < np.inf:
            if lower_bounds[i] < upper_bounds[i]:
                initial_costs[i] = (lower_bounds[i] + upper_bounds[i]) / 2
            else:
                initial_costs[i] = lower_bounds[i] - 1e-8
        elif lower_bounds[i] > -np.inf:
            initial_costs[i] = lower_bounds[i]
        elif upper_bounds[i] < np.inf:
            initial_costs[i] = upper_bounds[i] - 1e-8
        else:
            initial_costs[i] = 0.0
    
    def objective(params):
        p_flat = params[:n_actions * num_outcomes].reshape(n_actions, num_outcomes)
        c = params[n_actions * num_outcomes: n_actions * num_outcomes + n_actions]
        penalty = 0.0
        
        for log in content:
            w = np.array(log['Contract'])
            u_vals = np.array([p @ w - cost_val for p, cost_val in zip(p_flat, c)])
            max_u = np.max(u_vals)
            
            if log['Agent Action'] == 1:
                if max_u < 0:
                    penalty += (max_u - 0) ** 2
                best_a = np.argmax(u_vals)
                principal_util = np.dot(p_flat[best_a], v - w)
                penalty += (principal_util - log['Principal Utility']) ** 2
            else:
                if max_u >= 0:
                    penalty += (max_u - 0) ** 2
        
        return penalty
    
    constraints = []
    for i in range(n_actions):
        constraints.append({'type': 'eq', 'fun': lambda x, idx=i: np.sum(x[idx*num_outcomes:(idx+1)*num_outcomes]) - 1})
    
    bounds = [(0, 1)] * (n_actions * num_outcomes) + [(0, None)] * n_actions
    initial_params = np.concatenate([action_centers.flatten(), initial_costs])
    
    res = minimize(objective, initial_params, method='SLSQP', bounds=bounds, constraints=constraints, tol=1e-6, options={'maxiter': 1000})
    
    if res.success:
        optimized_params = res.x
        p_opt = optimized_params[:n_actions * num_outcomes].reshape(n_actions, num_outcomes)
        c_opt = optimized_params[n_actions * num_outcomes: n_actions * num_outcomes + n_actions]
    else:
        p_opt, c_opt = action_centers, initial_costs
    
    valid_rows = []
    for i in range(n_actions):
        if np.all(p_opt[i] >= 0) and abs(np.sum(p_opt[i]) - 1) < 1e-6 and c_opt[i] >= 0:
            valid_rows.append(np.hstack([p_opt[i], c_opt[i]]))
    
    if not valid_rows:
        default_p = np.ones(num_outcomes) / num_outcomes
        default_c = 0.0
        return np.hstack([default_p.reshape(1, -1), np.array([[default_c]])])
    
    return np.array(valid_rows)
```
