```python
import numpy as np
from scipy.optimize import linprog
from sklearn.cluster import KMeans
from sklearn.preprocessing import normalize

def agent_solver(v, content):
    m_outcomes = len(v)
    accepted_logs = [log for log in content if log['Agent Action'] == 1]
    rejected_logs = [log for log in content if log['Agent Action'] == -1]
    
    if not accepted_logs:
        return np.hstack([np.ones((1, m_outcomes)) / m_outcomes, np.zeros((1, 1))])
    
    def infer_p_candidates(logs):
        candidate_ps = []
        for log in logs:
            w = np.array(log['Contract'])
            u_principal = log['Principal Utility']
            A_eq = np.vstack([np.ones(m_outcomes), v - w])
            b_eq = np.array([1.0, u_principal])
            bounds = [(0, 1) for _ in range(m_outcomes)]
            res = linprog(w, A_eq=A_eq, b_eq=b_eq, bounds=bounds, method='highs')
            if res.success and np.all(res.x >= 0) and np.isclose(np.sum(res.x), 1.0):
                candidate_ps.append(res.x)
        return np.array(candidate_ps) if candidate_ps else None
    
    all_p = infer_p_candidates(accepted_logs)
    if all_p is None or len(all_p) == 0:
        return np.hstack([np.ones((1, m_outcomes)) / m_outcomes, np.zeros((1, 1))])
    
    def adaptive_clustering(points):
        n_min = 1
        n_max = min(20, len(points) - 1)
        if n_min >= n_max:
            return points.mean(axis=0, keepdims=True)
        best_score = np.inf
        best_centers = None
        for n in range(n_min, n_max + 1):
            kmeans = KMeans(n_clusters=n, random_state=0, n_init=10).fit(points)
            if kmeans.inertia_ < best_score:
                best_score = kmeans.inertia_
                best_centers = kmeans.cluster_centers_
        return best_centers
    
    p_centers = adaptive_clustering(all_p)
    p_centers = normalize(p_centers, norm='l1', axis=1)
    n_actions = len(p_centers)
    
    def assign_actions(logs, centers):
        actions = []
        for log in logs:
            w = np.array(log['Contract'])
            utils = centers @ w
            actions.append(np.argmax(utils))
        return np.array(actions)
    
    accepted_actions = assign_actions(accepted_logs, p_centers)
    
    def compute_costs(centers, accepts, rejs):
        costs = np.zeros(n_actions)
        for a in range(n_actions):
            mask = (accepted_actions == a)
            if np.any(mask):
                contracts = np.array([accepted_logs[i]['Contract'] for i in np.where(mask)[0]]).T
                min_util = np.min(centers[a] @ contracts)
                costs[a] = min_util
            else:
                costs[a] = 0.0
        
        if rejs:
            rej_contracts = np.array([log['Contract'] for log in rejs]).T
            rej_utils = centers @ rej_contracts
            max_rej_utils = np.max(rej_utils, axis=1)
            costs = np.maximum(costs, max_rej_utils)
        
        return costs
    
    c_final = compute_costs(p_centers, accepted_logs, rejected_logs)
    
    agent_setting = np.hstack([p_centers, c_final.reshape(-1, 1)])
    return agent_setting
```
