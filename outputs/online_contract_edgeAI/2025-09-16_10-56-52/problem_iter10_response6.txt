```python
import numpy as np
from scipy.optimize import linprog
from sklearn.mixture import GaussianMixture
from sklearn.neighbors import KernelDensity
from scipy.optimize import minimize
import pandas as pd

def agent_solver_v2(v: np.ndarray, content: list[dict]) -> np.ndarray:
    n_outcomes = len(v)
    df = pd.DataFrame(content)
    accepted = df[df['Agent Action'] == 1]
    rejected = df[df['Agent Action'] == -1]
    
    if accepted.empty and rejected.empty:
        default_p = np.ones(n_outcomes) / n_outcomes
        default_c = 0.0
        return np.hstack([default_p.reshape(1, -1), np.array([[default_c]])])
    
    candidate_probs = []
    for _, row in accepted.iterrows():
        w = np.array(row['Contract'])
        u_p = row['Principal Utility']
        A_eq = np.vstack([np.ones(n_outcomes), v - w])
        b_eq = np.array([1.0, u_p])
        res = linprog(-w, A_eq=A_eq, b_eq=b_eq, bounds=[(0, 1)] * n_outcomes, method='highs')
        if res.success:
            p = res.x
            if np.all(p >= -1e-8) and abs(np.sum(p) - 1) < 1e-8:
                candidate_probs.append(np.clip(p, 0, 1))
    
    if not candidate_probs:
        default_p = np.ones(n_outcomes) / n_outcomes
        default_c = 0.0
        return np.hstack([default_p.reshape(1, -1), np.array([[default_c]])])
    
    X = np.array(candidate_probs)
    max_clusters = min(10, len(X))
    bic_scores = []
    for n in range(1, max_clusters + 1):
        gmm = GaussianMixture(n_components=n, random_state=42, n_init=10, max_iter=200)
        gmm.fit(X)
        bic_scores.append(gmm.bic(X))
    optimal_n = np.argmin(bic_scores) + 1
    
    gmm = GaussianMixture(n_components=optimal_n, random_state=42, n_init=10, max_iter=200)
    gmm.fit(X)
    action_centers = gmm.means_
    n_actions = action_centers.shape[0]
    
    costs = np.zeros(n_actions)
    for i in range(n_actions):
        p_i = action_centers[i]
        min_util = np.inf
        for _, row in accepted.iterrows():
            w = np.array(row['Contract'])
            util = p_i @ w
            if util < min_util:
                min_util = util
        if not np.isfinite(min_util):
            min_util = 0.0
        costs[i] = min_util
    
    for _, row in rejected.iterrows():
        w = np.array(row['Contract'])
        for i in range(n_actions):
            util = action_centers[i] @ w
            if util >= costs[i]:
                costs[i] = util + 1e-8
    
    action_centers = np.clip(action_centers, 0, 1)
    action_centers /= action_centers.sum(axis=1, keepdims=True)
    costs = np.clip(costs, 0, None)
    
    def objective(params):
        p_flat = params[:n_actions * n_outcomes].reshape(n_actions, n_outcomes)
        c = params[n_actions * n_outcomes: n_actions * n_outcomes + n_actions]
        penalty = 0.0
        
        for _, row in df.iterrows():
            w = np.array(row['Contract'])
            u_vals = np.array([p @ w - cost_val for p, cost_val in zip(p_flat, c)])
            max_u = np.max(u_vals)
            
            if row['Agent Action'] == 1:
                if max_u < 0:
                    penalty += max_u ** 2
                best_a = np.argmax(u_vals)
                principal_util = p_flat[best_a] @ (v - w)
                penalty += (principal_util - row['Principal Utility']) ** 2
            else:
                if max_u >= 0:
                    penalty += max_u ** 2
        
        for p in p_flat:
            penalty += (np.sum(p) - 1.0) ** 2
        
        return penalty
    
    constraints = [
        {'type': 'eq', 'fun': lambda x, idx=i: np.sum(x[idx * n_outcomes:(idx + 1) * n_outcomes]) - 1}
        for i in range(n_actions)
    ]
    
    bounds = [(0, 1)] * (n_actions * n_outcomes) + [(0, None)] * n_actions
    initial_params = np.concatenate([action_centers.flatten(), costs])
    
    res = minimize(objective, initial_params, method='SLSQP', bounds=bounds, constraints=constraints, tol=1e-6, options={'maxiter': 1000})
    
    if res.success:
        optimized_params = res.x
        p_opt = optimized_params[:n_actions * n_outcomes].reshape(n_actions, n_outcomes)
        c_opt = optimized_params[n_actions * n_outcomes: n_actions * n_outcomes + n_actions]
    else:
        p_opt, c_opt = action_centers, costs
    
    return np.hstack([p_opt, c_opt.reshape(-1, 1)])
```
