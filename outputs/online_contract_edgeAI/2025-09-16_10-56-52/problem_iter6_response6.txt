```python
import numpy as np
import pandas as pd
from scipy.optimize import linprog
from sklearn.mixture import GaussianMixture
from sklearn.neighbors import KernelDensity
from scipy.special import logsumexp

def agent_solver_v2(v: np.ndarray, content: list[dict]) -> np.ndarray:
    n_outcomes = len(v)
    logs = pd.DataFrame(content)
    accepted = logs[logs['Agent Action'] == 1]
    rejected = logs[logs['Agent Action'] == -1]
    
    if len(accepted) == 0:
        return np.array([np.full(n_outcomes, 1/n_outcomes).tolist() + [0.0]])
    
    def infer_probabilities(w, u_p):
        c = w @ v - u_p
        A_eq = np.vstack([np.ones(n_outcomes), w - v])
        b_eq = np.array([1.0, c])
        res = linprog(-v, A_eq=A_eq, b_eq=b_eq, bounds=[(0, 1)] * n_outcomes, method='highs')
        if res.success:
            return res.x
        return None
    
    candidate_probs = []
    for _, row in accepted.iterrows():
        w = np.array(row['Contract'])
        u_p = row['Principal Utility']
        p = infer_probabilities(w, u_p)
        if p is not None:
            candidate_probs.append(p)
    
    if len(candidate_probs) == 0:
        candidate_probs = [np.ones(n_outcomes) / n_outcomes]
    
    X = np.array(candidate_probs)
    n_components = min(8, max(1, len(X) // 3))
    gmm = GaussianMixture(n_components=n_components, random_state=42, covariance_type='diag')
    gmm.fit(X)
    action_centers = gmm.means_
    
    kde = KernelDensity(bandwidth=0.03, kernel='gaussian')
    kde.fit(X)
    log_dens = kde.score_samples(X)
    weights = np.exp(log_dens - logsumexp(log_dens))
    smoothed_center = np.sum(weights[:, None] * X, axis=0)
    action_centers = np.vstack([action_centers, smoothed_center])
    
    accepted_contracts = [np.array(w) for w in accepted['Contract']]
    rejected_contracts = [np.array(w) for w in rejected['Contract']]
    
    def compute_utility(p, w):
        return p @ w
    
    costs = []
    for a_idx in range(len(action_centers)):
        p_a = action_centers[a_idx]
        utils_accepted = [compute_utility(p_a, w) for w in accepted_contracts]
        min_util_accepted = min(utils_accepted) if utils_accepted else 0.0
        utils_rejected = [compute_utility(p_a, w) for w in rejected_contracts]
        max_util_rejected = max(utils_rejected) if utils_rejected else -np.inf
        cost = max(min_util_accepted, max_util_rejected + 1e-8, 0.0)
        costs.append(cost)
    
    agent_setting = np.hstack([action_centers, np.array(costs).reshape(-1, 1)])
    return agent_setting
```
