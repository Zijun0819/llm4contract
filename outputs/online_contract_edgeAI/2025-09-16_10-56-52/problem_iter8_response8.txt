```python
import numpy as np
from scipy.optimize import linprog, minimize
from sklearn.mixture import GaussianMixture

def agent_solver_v2(v: np.ndarray, content: list[dict]) -> np.ndarray:
    num_outcomes = len(v)
    
    def infer_initial_actions():
        accepted_logs = [log for log in content if log['Agent Action'] == 1]
        if not accepted_logs:
            p_default = np.ones(num_outcomes) / num_outcomes
            c_default = 0.0
            return np.array([p_default]), np.array([c_default])
        
        candidate_ps = []
        for log in accepted_logs:
            w = np.array(log['Contract'])
            u = log['Principal Utility']
            A_eq = np.vstack([np.ones(num_outcomes), v - w])
            b_eq = np.array([1.0, u])
            res = linprog(-w, A_eq=A_eq, b_eq=b_eq, bounds=[(0, 1)] * num_outcomes, method='highs')
            if res.success:
                p = res.x
                if np.all(p >= 0) and abs(np.sum(p) - 1) < 1e-8:
                    candidate_ps.append(p)
        
        if not candidate_ps:
            p_default = np.ones(num_outcomes) / num_outcomes
            c_default = 0.0
            return np.array([p_default]), np.array([c_default])
        
        candidate_ps = np.array(candidate_ps)
        if len(candidate_ps) == 1:
            return candidate_ps, np.zeros(1)
        
        max_components = min(10, len(candidate_ps))
        bic_scores = []
        models = []
        for n_comp in range(1, max_components + 1):
            gmm = GaussianMixture(n_components=n_comp, random_state=42, n_init=5, max_iter=200)
            gmm.fit(candidate_ps)
            bic_scores.append(gmm.bic(candidate_ps))
            models.append(gmm)
        best_n = np.argmin(bic_scores) + 1
        gmm = models[best_n - 1]
        action_centers = gmm.means_
        
        cost_estimates = np.zeros(best_n)
        for a in range(best_n):
            action_utils = []
            for log in content:
                w = np.array(log['Contract'])
                util = np.dot(action_centers[a], w)
                if log['Agent Action'] == 1 and np.argmax(action_centers @ w) == a:
                    action_utils.append(util)
            if action_utils:
                cost_estimates[a] = np.min(action_utils)
        
        return action_centers, cost_estimates
    
    p_init, c_init = infer_initial_actions()
    n_actions = p_init.shape[0]
    
    def objective(params):
        p_flat = params[:n_actions * num_outcomes].reshape(n_actions, num_outcomes)
        c = params[n_actions * num_outcomes:]
        penalty = 0.0
        for log in content:
            w = np.array(log['Contract'])
            agent_utils = p_flat @ w - c
            max_util = np.max(agent_utils)
            best_action = np.argmax(agent_utils)
            if log['Agent Action'] == 1:
                if max_util < 0:
                    penalty += (max_util - 0) ** 2
                principal_util = np.dot(p_flat[best_action], v - w)
                penalty += (principal_util - log['Principal Utility']) ** 2
            else:
                if max_util >= 0:
                    penalty += (max_util - (-1e-8)) ** 2
        return penalty
    
    constraints = []
    for i in range(n_actions):
        constraints.append({
            'type': 'eq',
            'fun': lambda x, idx=i: np.sum(x[idx*num_outcomes:(idx+1)*num_outcomes]) - 1
        })
    
    bounds = [(0, 1)] * (n_actions * num_outcomes) + [(0, None)] * n_actions
    x0 = np.concatenate([p_init.flatten(), c_init])
    
    res = minimize(
        objective,
        x0,
        method='SLSQP',
        bounds=bounds,
        constraints=constraints,
        tol=1e-8,
        options={'maxiter': 1000, 'ftol': 1e-8}
    )
    
    if res.success:
        optimized = res.x
        p_opt = optimized[:n_actions * num_outcomes].reshape(n_actions, num_outcomes)
        c_opt = optimized[n_actions * num_outcomes:]
    else:
        p_opt, c_opt = p_init, c_init
    
    for i in range(n_actions):
        p_opt[i] = np.maximum(p_opt[i], 0)
        p_opt[i] /= np.sum(p_opt[i])
    c_opt = np.maximum(c_opt, 0)
    
    for log in content:
        w = np.array(log['Contract'])
        agent_utils = p_opt @ w - c_opt
        max_util = np.max(agent_utils)
        if log['Agent Action'] == 1 and max_util < 0:
            best_action = np.argmax(agent_utils)
            c_opt[best_action] = p_opt[best_action] @ w - 1e-8
        elif log['Agent Action'] == -1 and max_util >= 0:
            best_action = np.argmax(agent_utils)
            c_opt[best_action] = p_opt[best_action] @ w + 1e-8
    
    return np.hstack([p_opt, c_opt.reshape(-1, 1)])
```
