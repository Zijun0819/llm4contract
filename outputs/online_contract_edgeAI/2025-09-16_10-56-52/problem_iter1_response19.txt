```python
import numpy as np
import pandas as pd
from scipy.optimize import linprog, minimize, Bounds, LinearConstraint
from sklearn.cluster import KMeans, DBSCAN

def agent_solver(v: np.ndarray, content: list) -> np.ndarray:
    m_outcomes = len(v)
    accepted_logs = [log for log in content if log['Agent Action'] == 1]
    rejected_logs = [log for log in content if log['Agent Action'] == -1]
    
    if not accepted_logs:
        raise ValueError("No accepted contracts to infer agent settings.")
    
    def infer_p_candidates(logs):
        candidate_ps = []
        for log in logs:
            w = np.array(log['Contract'])
            u_principal = log['Principal Utility']
            A_eq = [np.ones(m_outcomes), v - w]
            b_eq = [1.0, u_principal]
            bounds = [(0, 1) for _ in range(m_outcomes)]
            res = linprog(w, A_eq=A_eq, b_eq=b_eq, bounds=bounds, method='highs')
            if res.success:
                candidate_ps.append(res.x)
        return np.array(candidate_ps) if candidate_ps else None
    
    all_p = infer_p_candidates(accepted_logs)
    if all_p is None:
        raise ValueError("No valid LP solutions from accepted contracts.")
    
    def adaptive_clustering(points):
        n_min = 2
        n_max = min(10, len(points))
        best_score = -np.inf
        best_centers = None
        for n in range(n_min, n_max + 1):
            kmeans = KMeans(n_clusters=n, random_state=0, n_init=10).fit(points)
            score = -kmeans.inertia_
            if score > best_score:
                best_score = score
                best_centers = kmeans.cluster_centers_
        return best_centers if best_centers is not None else points.mean(axis=0, keepdims=True)
    
    p0 = adaptive_clustering(all_p)
    n_actions = len(p0)
    
    def assign_actions(logs, centers):
        actions = []
        for log in logs:
            w = np.array(log['Contract'])
            utils = centers @ w
            actions.append(np.argmax(utils))
        return np.array(actions)
    
    accepted_actions = assign_actions(accepted_logs, p0)
    
    def compute_costs(centers, accepts, rejs):
        c = np.zeros(n_actions)
        for a in range(n_actions):
            idx = np.where(accepted_actions == a)[0]
            if idx.size > 0:
                wages = np.array([accepted_logs[i]['Contract'] for i in idx]).T
                c[a] = centers[a] @ np.min(wages, axis=1)
            else:
                c[a] = 0.0
        if rejs:
            wages_rej = np.array([log['Contract'] for log in rejs]).T
            rej_utils = centers @ wages_rej
            c_rej = np.max(rej_utils, axis=1)
            c = np.maximum(c, c_rej)
        return c
    
    c_final = compute_costs(p0, accepted_logs, rejected_logs)
    
    agent_setting = np.hstack([p0, c_final.reshape(-1, 1)])
    return agent_setting
```
