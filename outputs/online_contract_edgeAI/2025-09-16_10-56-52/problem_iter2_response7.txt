```python
import numpy as np
from scipy.optimize import linprog
from sklearn.mixture import GaussianMixture
from sklearn.preprocessing import StandardScaler

def agent_solver(v, content):
    m_outcomes = 12
    if not content or len(v) != m_outcomes:
        return np.zeros((1, m_outcomes + 1))
    
    accepted_logs = [log for log in content if log['Agent Action'] == 1]
    rejected_logs = [log for log in content if log['Agent Action'] == -1]
    n_accepted = len(accepted_logs)
    n_rejected = len(rejected_logs)
    
    def solve_p(w, u):
        A_eq = np.vstack([np.ones(m_outcomes), v - w])
        b_eq = np.array([1.0, u])
        res = linprog(w, A_eq=A_eq, b_eq=b_eq, bounds=[(0, 1)] * m_outcomes, method='highs')
        if res.success:
            p_candidate = res.x
            if np.abs(np.sum(p_candidate) - 1) < 1e-6 and np.all(p_candidate >= -1e-6) and np.all(p_candidate <= 1 + 1e-6):
                p_candidate = np.clip(p_candidate, 0, 1)
                p_candidate /= np.sum(p_candidate)
                return p_candidate
        return None

    inferred_ps = []
    for log in accepted_logs:
        p_candidate = solve_p(np.array(log['Contract']), log['Principal Utility'])
        if p_candidate is not None:
            inferred_ps.append(p_candidate)
    
    if not inferred_ps:
        return np.ones((1, m_outcomes + 1)) * np.hstack([np.ones(m_outcomes) / m_outcomes, 0.0])
    
    inferred_ps = np.array(inferred_ps)
    
    if n_accepted <= 1:
        n_components = 1
    else:
        scaler = StandardScaler()
        scaled_ps = scaler.fit_transform(inferred_ps)
        n_components_range = range(1, min(10, n_accepted) + 1)
        best_bic = np.inf
        best_n = 1
        for n_components in n_components_range:
            gmm = GaussianMixture(n_components=n_components, random_state=0, n_init=5, max_iter=100)
            gmm.fit(scaled_ps)
            bic = gmm.bic(scaled_ps)
            if bic < best_bic:
                best_bic = bic
                best_n = n_components
        n_components = best_n
    
    gmm = GaussianMixture(n_components=n_components, random_state=0, n_init=5, max_iter=100)
    gmm.fit(inferred_ps)
    p_centers = gmm.means_
    actions_assigned = gmm.predict(inferred_ps)
    n_actions = p_centers.shape[0]
    
    c_ir = np.zeros(n_actions)
    for a in range(n_actions):
        indices = np.where(actions_assigned == a)[0]
        if len(indices) > 0:
            contracts_a = np.array([accepted_logs[i]['Contract'] for i in indices])
            min_utility = np.min(np.dot(contracts_a, p_centers[a]))
            c_ir[a] = min_utility
        else:
            c_ir[a] = 0.0
    
    if n_rejected > 0:
        rejected_contracts = np.array([log['Contract'] for log in rejected_logs])
        max_utility_per_action = np.max(np.dot(rejected_contracts, p_centers.T), axis=0)
        c_final = np.maximum(c_ir, max_utility_per_action)
    else:
        c_final = c_ir
    
    agent_setting = np.hstack([p_centers, c_final.reshape(-1, 1)])
    return agent_setting
```
