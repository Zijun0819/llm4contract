```python
import numpy as np
import pandas as pd
from scipy.optimize import linprog, minimize
from sklearn.cluster import KMeans
from scipy.spatial.distance import cdist

def agent_solver_v2(v: np.ndarray, content: list[dict]) -> np.ndarray:
    n_candidates = max(3, min(10, len(content) // 10))
    L = len(content)
    m_outcomes = len(v)
    
    accepted_logs = [log for log in content if log['Agent Action'] == 1]
    if len(accepted_logs) == 0:
        return np.zeros((1, m_outcomes + 1))
    
    w_accepted = np.array([log['Contract'] for log in accepted_logs])
    contract_set = np.unique(w_accepted, axis=0)
    if len(contract_set) > 1:
        w_center = np.mean(w_accepted, axis=0)
        sil_scores = []
        max_clusters = min(10, len(w_accepted))
        if max_clusters > 1:
            for k in range(2, max_clusters + 1):
                kmeans = KMeans(n_clusters=k, random_state=0, n_init='auto').fit(w_accepted)
                sil_scores.append(np.mean(silhouette_samples(w_accepted, kmeans.labels_)))
            best_k = np.argmax(sil_scores) + 2
        else:
            best_k = 1
    else:
        best_k = 1
    
    kmeans_contract = KMeans(n_clusters=best_k, random_state=0, n_init='auto').fit(w_accepted)
    contract_clusters = kmeans_contract.labels_
    
    action_centers_list = []
    action_weights_list = []
    action_indices_list = []
    
    for cluster_id in range(best_k):
        cluster_mask = (contract_clusters == cluster_id)
        cluster_contracts = w_accepted[cluster_mask]
        if len(cluster_contracts) == 0:
            continue
        cluster_value = np.mean(cluster_contracts @ v)
        
        def objective(p, w_cluster=cluster_contracts, value_target=cluster_value):
            util_diff = (p @ w_cluster.T) - (p @ v).reshape(-1, 1)
            violation = np.maximum(0, util_diff).sum()
            return violation
        
        constraint = {'type': 'eq', 'fun': lambda p: np.sum(p) - 1}
        bounds = [(0, 1) for _ in range(m_outcomes)]
        initial_guess = np.ones(m_outcomes) / m_outcomes
        res = minimize(objective, initial_guess, method='SLSQP', bounds=bounds, constraints=constraint)
        if res.success:
            p_center = res.x
            weights = np.exp(-cdist([p_center], cluster_contracts).flatten())
            weights = weights / np.sum(weights)
            action_centers_list.append(p_center)
            action_weights_list.append(weights)
            action_indices_list.append(np.where(cluster_mask)[0])
    
    n_actions = len(action_centers_list)
    if n_actions == 0:
        return np.zeros((1, m_outcomes + 1))
    
    p0 = np.array(action_centers_list)
    
    c = np.zeros(n_actions)
    for act_id in range(n_actions):
        w_cluster = w_accepted[action_indices_list[act_id]]
        agent_utils = w_cluster @ p0[act_id]
        min_util = np.min(agent_utils)
        c[act_id] = max(0, min_util)
    
    if any(log['Agent Action'] == -1 for log in content):
        w_rejected = np.array([log['Contract'] for log in content if log['Agent Action'] == -1])
        for act_id in range(n_actions):
            rej_utils = w_rejected @ p0[act_id]
            max_rej_util = np.max(rej_utils)
            if max_rej_util > c[act_id]:
                c[act_id] = max_rej_util
    
    agent_setting = np.hstack([p0, c.reshape(-1, 1)])
    return agent_setting
```
