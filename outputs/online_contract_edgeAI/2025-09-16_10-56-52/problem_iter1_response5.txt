```python
import numpy as np
from scipy.optimize import linprog, minimize
from sklearn.cluster import KMeans
from sklearn.mixture import GaussianMixture

def agent_solver_v2(v: np.ndarray, content: list[dict]) -> np.ndarray:
    def linear_program_solver(w: np.ndarray, u: float) -> np.ndarray:
        m = len(w)
        c = np.ones(m)
        A_eq = np.vstack([np.ones(m), v - w])
        b_eq = np.array([1.0, u])
        bounds = [(0, 1)] * m
        res = linprog(c, A_eq=A_eq, b_eq=b_eq, bounds=bounds, method='highs')
        return res.x if res.success else None
    
    accepted_logs = [log for log in content if log['Agent Action'] == 1]
    if not accepted_logs:
        raise ValueError("No accepted contracts in logs.")
    
    inferred_ps = []
    for log in accepted_logs:
        p_star = linear_program_solver(np.array(log['Contract']), log['Principal Utility'])
        if p_star is not None:
            inferred_ps.append(p_star)
    
    inferred_ps = np.array(inferred_ps)
    n_components = min(7, max(2, len(accepted_logs) // 5))
    gmm = GaussianMixture(n_components=n_components, covariance_type='spherical', random_state=0).fit(inferred_ps)
    p0 = gmm.means_
    n_actions = p0.shape[0]
    
    action_assignments = []
    for log in accepted_logs:
        w_vec = np.array(log['Contract'])
        utilities = p0 @ w_vec
        best_action = np.argmax(utilities)
        action_assignments.append(best_action)
    
    c_estimates = np.zeros(n_actions)
    for a in range(n_actions):
        contracts_a = [np.array(log['Contract']) for i, log in enumerate(accepted_logs) if action_assignments[i] == a]
        if contracts_a:
            min_wages = np.min(contracts_a, axis=0)
            c_estimates[a] = p0[a] @ min_wages
        else:
            c_estimates[a] = 0.0
    
    reject_logs = [log for log in content if log['Agent Action'] == -1]
    if reject_logs:
        rej_contracts = np.array([log['Contract'] for log in reject_logs]).T
        rej_utils_per_action = p0 @ rej_contracts
        max_rej_utils = np.max(rej_utils_per_action, axis=1)
        c_estimates = np.maximum(c_estimates, max_rej_utils)
    
    final_costs = np.zeros(n_actions)
    for a in range(n_actions):
        def cost_objective(c_a):
            violations = 0.0
            for log in accepted_logs:
                w_vec = np.array(log['Contract'])
                util_a = p0[a] @ w_vec - c_a
                if action_assignments[accepted_logs.index(log)] == a and util_a < 0:
                    violations += abs(util_a)
            for log in reject_logs:
                w_vec = np.array(log['Contract'])
                util_a = p0[a] @ w_vec - c_a
                if util_a >= 0:
                    violations += abs(util_a)
            return violations
        
        res = minimize(cost_objective, c_estimates[a], method='Nelder-Mead')
        final_costs[a] = max(0.0, res.x[0])
    
    agent_setting = np.hstack([p0, final_costs.reshape(-1, 1)])
    return agent_setting
```
