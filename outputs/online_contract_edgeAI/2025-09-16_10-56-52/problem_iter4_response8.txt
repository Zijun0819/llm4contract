```python
import numpy as np
from scipy.optimize import linprog
from sklearn.mixture import GaussianMixture
from sklearn.neighbors import KernelDensity

def agent_solver(v: np.ndarray, content: list[dict]) -> np.ndarray:
    n_outcomes = len(v)
    accepted_logs = [log for log in content if log['Agent Action'] == 1]
    rejected_logs = [log for log in content if log['Agent Action'] == -1]
    
    if not accepted_logs:
        return np.hstack([np.full((1, n_outcomes), 1.0/n_outcomes), np.zeros((1,1))])
    
    contracts_acc = np.array([log['Contract'] for log in accepted_logs])
    principal_utils = np.array([log['Principal Utility'] for log in accepted_logs])
    
    p_candidates = []
    for i in range(len(accepted_logs)):
        w = contracts_acc[i]
        u = principal_utils[i]
        A_eq = np.vstack([np.ones(n_outcomes), v - w])
        b_eq = np.array([1.0, u])
        bounds = [(0,1) for _ in range(n_outcomes)]
        res = linprog(w, A_eq=A_eq, b_eq=b_eq, bounds=bounds, method='highs')
        if res.success:
            p_candidates.append(res.x)
    
    if not p_candidates:
        return np.hstack([np.full((1, n_outcomes), 1.0/n_outcomes), np.zeros((1,1))])
    
    p_candidates = np.array(p_candidates)
    
    max_clusters = min(10, len(p_candidates))
    bic_scores = []
    for n in range(1, max_clusters+1):
        gm = GaussianMixture(n_components=n, random_state=42, n_init=3)
        gm.fit(p_candidates)
        bic_scores.append(gm.bic(p_candidates))
    optimal_n = np.argmin(bic_scores) + 1
    
    gm = GaussianMixture(n_components=optimal_n, random_state=42, n_init=3)
    gm.fit(p_candidates)
    p_means = gm.means_
    assignments = gm.predict(p_candidates)
    
    action_min_utils = [np.inf] * optimal_n
    for idx, a in enumerate(assignments):
        util = np.dot(p_means[a], contracts_acc[idx])
        if util < action_min_utils[a]:
            action_min_utils[a] = util
    
    if rejected_logs:
        rej_contracts = np.array([log['Contract'] for log in rejected_logs])
        rej_utils = p_means @ rej_contracts.T
        action_rej_max = np.max(rej_utils, axis=1)
    else:
        action_rej_max = np.full(optimal_n, -np.inf)
    
    costs = np.zeros(optimal_n)
    for a in range(optimal_n):
        cost_lb = max(0, action_rej_max[a])
        if action_min_utils[a] != np.inf:
            assigned_idx = np.where(assignments == a)[0][0]
            cost_lb = max(cost_lb, action_min_utils[a] - principal_utils[assigned_idx])
        costs[a] = cost_lb
    
    kde = KernelDensity(kernel='gaussian', bandwidth=0.05)
    kde.fit(p_means)
    log_dens = kde.score_samples(p_means)
    weights = np.exp(log_dens - np.max(log_dens))
    weights /= weights.sum()
    
    p_smoothed = p_means * weights[:, np.newaxis]
    p_smoothed /= p_smoothed.sum(axis=1, keepdims=True)
    
    return np.hstack([p_smoothed, costs.reshape(-1,1)])
```
