```python
import numpy as np
from scipy.optimize import linprog, minimize
from sklearn.cluster import KMeans

def agent_solver(v: np.ndarray, content) -> np.ndarray:
    accepted_logs = [log for log in content if log['Agent Action'] == 1]
    rejected_logs = [log for log in content if log['Agent Action'] == -1]
    n_accepted = len(accepted_logs)
    if n_accepted == 0:
        raise ValueError("No accepted contracts in logs")

    def utility_dimension_reduction(w_list):
        utils = np.array([np.dot(v - w, w) for w in w_list])
        kmeans = KMeans(n_clusters=min(10, n_accepted), random_state=0, n_init=10).fit(utils.reshape(-1, 1))
        unique_means = np.unique(kmeans.cluster_centers_.flatten())
        return unique_means

    unique_utils = utility_dimension_reduction([log['Contract'] for log in accepted_logs])
    n_actions = len(unique_utils)

    def create_agent_setting(centroids, costs):
        return np.hstack([centroids, costs.reshape(-1, 1)])

    def compute_potential_centroids():
        all_p = []
        for log in accepted_logs:
            w = np.array(log['Contract'])
            u = log['Principal Utility']
            res = linprog(w, A_eq=[np.ones(12), v - w], b_eq=[1.0, u], bounds=[(0, 1)] * 12, method='highs')
            if res.success:
                all_p.append(res.x)
        if not all_p:
            raise ValueError("No valid p vectors inferred")
        kmeans = KMeans(n_clusters=n_actions, random_state=0, n_init=10).fit(all_p)
        return kmeans.cluster_centers_

    p0 = compute_potential_centroids()

    def assign_actions_and_compute_costs():
        assignments = np.zeros(n_accepted, dtype=int)
        for i, log in enumerate(accepted_logs):
            w = log['Contract']
            utilities = p0 @ w
            assignments[i] = np.argmax(utilities)
        
        costs = np.zeros(n_actions)
        for a in range(n_actions):
            indices = np.where(assignments == a)[0]
            if indices.size > 0:
                contracts = np.array([accepted_logs[i]['Contract'] for i in indices])
                min_utils = np.min(contracts @ p0[a], axis=0)
                costs[a] = max(0, min_utils)
            else:
                costs[a] = 0.0

        for log in rejected_logs:
            w = np.array(log['Contract'])
            rej_utils = p0 @ w
            for a in range(n_actions):
                if rej_utils[a] >= costs[a]:
                    costs[a] = rej_utils[a] + 1e-6

        return costs

    c_final = assign_actions_and_compute_costs()
    return create_agent_setting(p0, c_final)
```
