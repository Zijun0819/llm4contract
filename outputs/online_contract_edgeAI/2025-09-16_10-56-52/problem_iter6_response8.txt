```python
import numpy as np
import pandas as pd
from scipy.optimize import linprog
from sklearn.mixture import GaussianMixture

def agent_solver(v: np.ndarray, content: list[dict]) -> np.ndarray:
    n_outcomes = len(v)
    logs = pd.DataFrame(content)
    accepted = logs[logs['Agent Action'] == 1]
    rejected = logs[logs['Agent Action'] == -1]
    
    # Function to solve for minimal cost distribution that achieves principal utility
    def solve_min_lp(w, u_principal):
        # The agent's expected utility under contract w with distribution p is p @ w - c
        # Principal utility is p @ (v - w) = u_principal
        # So p @ (v - w) = u_principal
        c_vec = -w  # We want to minimize -p @ w (maximize p @ w) subject to constraints
        A_eq = np.vstack([np.ones(n_outcomes), v - w])
        b_eq = np.array([1.0, u_principal])
        bounds = [(0, 1) for _ in range(n_outcomes)]
        res = linprog(c_vec, A_eq=A_eq, b_eq=b_eq, bounds=bounds, method='highs')
        if res.success:
            return res.x
        return None
    
    candidate_p = []
    for _, row in accepted.iterrows():
        w = np.array(row['Contract'])
        u_p = row['Principal Utility']
        p_sol = solve_min_lp(w, u_p)
        if p_sol is not None:
            candidate_p.append(p_sol)
    
    if not candidate_p:
        candidate_p = [np.ones(n_outcomes) / n_outcomes]
    
    X = np.array(candidate_p)
    n_components_range = range(1, min(11, len(X) + 1))
    best_bic = np.inf
    best_gmm = None
    for n_components in n_components_range:
        gmm = GaussianMixture(n_components=n_components, random_state=42, covariance_type='diag')
        gmm.fit(X)
        bic = gmm.bic(X)
        if bic < best_bic:
            best_bic = bic
            best_gmm = gmm
    
    action_centers = best_gmm.means_
    n_actions = action_centers.shape[0]
    action_centers = action_centers / action_centers.sum(axis=1, keepdims=True)  # Ensure normalization
    
    # Assign each accepted contract to the action that maximizes its utility
    action_assignments = {}
    for idx, row in accepted.iterrows():
        w = np.array(row['Contract'])
        utilities = action_centers @ w
        best_action = np.argmax(utilities)
        action_assignments[idx] = best_action
    
    # Group contracts by their assigned action
    contracts_by_action = [[] for _ in range(n_actions)]
    for idx, row in accepted.iterrows():
        action_idx = action_assignments[idx]
        contracts_by_action[action_idx].append(np.array(row['Contract']))
    
    # Extract all rejected contracts
    rejected_contracts = [np.array(row['Contract']) for _, row in rejected.iterrows()]
    
    # For each action, compute the minimal utility from accepted contracts assigned to it (IR lower bound)
    def compute_ir_constraint(action_idx):
        contracts = contracts_by_action[action_idx]
        if not contracts:
            return -np.inf
        ws = np.array(contracts)
        p = action_centers[action_idx]
        utilities = p @ ws.T
        return np.min(utilities)
    
    # For each action, compute the maximal utility from contracts assigned to other actions (IC constraint)
    def compute_ic_constraint(action_idx):
        other_actions = [i for i in range(n_actions) if i != action_idx]
        contracts = []
        for a in other_actions:
            contracts.extend(contracts_by_action[a])
        if not contracts:
            return -np.inf
        ws = np.array(contracts)
        p = action_centers[action_idx]
        utilities = p @ ws.T
        return np.max(utilities)
    
    # For each action, compute the maximal utility from rejected contracts (rejection constraint)
    def compute_reject_constraint(action_idx):
        if len(rejected_contracts) == 0:
            return -np.inf
        ws = np.array(rejected_contracts)
        p = action_centers[action_idx]
        utilities = p @ ws.T
        return np.max(utilities)
    
    # For each action, the cost must be at least the maximum of the three constraint values
    ir_constraints = np.array([compute_ir_constraint(a) for a in range(n_actions)])
    ic_constraints = np.array([compute_ic_constraint(a) for a in range(n_actions)])
    rej_constraints = np.array([compute_reject_constraint(a) for a in range(n_actions)])
    
    # The cost for each action is the maximum of the constraints (ensuring IR, IC, and rejection conditions)
    costs = np.maximum.reduce([ir_constraints, ic_constraints, rej_constraints])
    costs = np.maximum(costs, 0.0)  # Ensure non-negative costs
    
    agent_setting = np.hstack([action_centers, costs.reshape(-1, 1)])
    return agent_setting
```
