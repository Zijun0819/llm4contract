```python
import numpy as np
from scipy.optimize import linprog
from sklearn.mixture import GaussianMixture
import pandas as pd

def agent_solver(v: np.ndarray, content: list[dict]) -> np.ndarray:
    n_outcomes = len(v)
    logs = pd.DataFrame(content)
    accepted = logs[logs['Agent Action'] == 1]
    rejected = logs[logs['Agent Action'] == -1]
    
    def solve_lp(w, u_threshold):
        c = -w
        A_eq = np.vstack([np.ones(n_outcomes), v - w])
        b_eq = np.array([1.0, u_threshold])
        bounds = [(0, 1)] * n_outcomes
        res = linprog(c, A_eq=A_eq, b_eq=b_eq, bounds=bounds, method='highs')
        if res.success:
            return res.x
        return None
    
    candidate_p = []
    for _, row in accepted.iterrows():
        w = np.array(row['Contract'])
        u_actual = row['Principal Utility']
        p_sol = solve_lp(w, u_actual)
        if p_sol is not None:
            candidate_p.append(p_sol)
    
    if not candidate_p:
        candidate_p = [np.ones(n_outcomes) / n_outcomes]
    
    X = np.array(candidate_p)
    min_components = min(3, len(X))
    gmm = GaussianMixture(n_components=min_components, random_state=0, n_init=3)
    gmm.fit(X)
    action_centers = gmm.means_
    n_actions = action_centers.shape[0]
    action_centers = action_centers / action_centers.sum(axis=1, keepdims=True)
    
    min_utils = np.full(n_actions, -np.inf)
    for _, row in accepted.iterrows():
        w = np.array(row['Contract'])
        utilities = action_centers @ w
        best_action = np.argmax(utilities)
        min_utils[best_action] = max(min_utils[best_action], utilities[best_action])
    
    max_utils_rej = np.full(n_actions, np.inf)
    if not rejected.empty:
        for _, row in rejected.iterrows():
            w = np.array(row['Contract'])
            utilities = action_centers @ w
            for a in range(n_actions):
                if utilities[a] >= 0:
                    max_utils_rej[a] = min(max_utils_rej[a], utilities[a])
    
    costs = np.zeros(n_actions)
    for a in range(n_actions):
        if np.isfinite(max_utils_rej[a]):
            if min_utils[a] <= max_utils_rej[a]:
                costs[a] = (min_utils[a] + max_utils_rej[a]) / 2
            else:
                costs[a] = min_utils[a]
        else:
            costs[a] = min_utils[a]
    
    costs = np.maximum(costs, 0)
    return np.hstack([action_centers, costs.reshape(-1, 1)])
```
