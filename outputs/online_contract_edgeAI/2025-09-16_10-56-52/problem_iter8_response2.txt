```python
import numpy as np
from scipy.optimize import linprog, minimize
from sklearn.mixture import GaussianMixture
from scipy.special import logsumexp
from sklearn.neighbors import KernelDensity
import pandas as pd
import warnings
warnings.filterwarnings('ignore')

def agent_solver(v: np.ndarray, content: list[dict]) -> np.ndarray:
    n_outcomes = len(v)
    df = pd.DataFrame(content)
    accepted = df[df['Agent Action'] == 1]
    rejected = df[df['Agent Action'] == -1]
    
    if len(accepted) == 0:
        return np.array([[1/n_outcomes] * n_outcomes + [0.0]])
    
    def infer_probability(w, u_p):
        A_eq = np.vstack([np.ones(n_outcomes), w - v])
        b_eq = np.array([1.0, w @ v - u_p])
        res = linprog(-np.ones(n_outcomes), A_eq=A_eq, b_eq=b_eq, bounds=[(0, 1)] * n_outcomes, method='highs')
        return res.x if res.success else None
    
    candidate_probs = []
    for _, row in accepted.iterrows():
        w = np.array(row['Contract'])
        u_p = row['Principal Utility']
        p = infer_probability(w, u_p)
        if p is not None:
            candidate_probs.append(p)
    
    if not candidate_probs:
        candidate_probs = [np.ones(n_outcomes) / n_outcomes]
    
    X = np.array(candidate_probs)
    n_candidates = min(10, max(2, len(X) // 3))
    
    if len(X) > 1:
        bics = []
        gmm_models = []
        for n in range(1, min(n_candidates+1, len(X)+1)):
            gmm = GaussianMixture(n_components=n, random_state=0, n_init=5, max_iter=100)
            gmm.fit(X)
            bics.append(gmm.bic(X))
            gmm_models.append(gmm)
        best_idx = np.argmin(bics)
        best_gmm = gmm_models[best_idx]
        action_centers = best_gmm.means_
        labels = best_gmm.predict(X)
    else:
        action_centers = X
        labels = np.zeros(len(X), dtype=int)
    
    accepted_contracts = [np.array(w) for w in accepted['Contract']]
    rejected_contracts = [np.array(w) for w in rejected['Contract']]
    
    n_actions = len(action_centers)
    min_utils = np.full(n_actions, np.inf)
    max_rej_utils = np.full(n_actions, -np.inf)
    
    for i, (w, label) in enumerate(zip(accepted_contracts, labels)):
        util = action_centers[label] @ w
        if util < min_utils[label]:
            min_utils[label] = util
    
    for w in rejected_contracts:
        for a in range(n_actions):
            util = action_centers[a] @ w
            if util > max_rej_utils[a]:
                max_rej_utils[a] = util
    
    costs = np.maximum(min_utils, np.where(np.isfinite(max_rej_utils), max_rej_utils + 1e-8, -np.inf))
    costs = np.clip(costs, 0, None)
    
    def objective(params):
        p_flat = params[:n_actions * n_outcomes].reshape(n_actions, n_outcomes)
        c = params[n_actions * n_outcomes: n_actions * n_outcomes + n_actions]
        penalty = 0.0
        
        for _, row in df.iterrows():
            w = np.array(row['Contract'])
            u_vals = np.array([p @ w - cost_val for p, cost_val in zip(p_flat, c)])
            max_u = np.max(u_vals)
            
            if row['Agent Action'] == 1:
                if max_u < 0:
                    penalty += (max_u) ** 2
                best_a = np.argmax(u_vals)
                principal_util = p_flat[best_a] @ (v - w)
                penalty += (principal_util - row['Principal Utility']) ** 2
            else:
                if max_u >= 0:
                    penalty += (max_u) ** 2
        
        for p in p_flat:
            if not np.allclose(p.sum(), 1.0, atol=1e-6):
                penalty += (p.sum() - 1.0) ** 2
        
        return penalty
    
    constraints = [
        {'type': 'eq', 'fun': lambda x, idx=i: np.sum(x[idx*n_outcomes:(idx+1)*n_outcomes]) - 1}
        for i in range(n_actions)
    ]
    
    bounds = [(0, 1)] * (n_actions * n_outcomes) + [(0, None)] * n_actions
    initial_params = np.concatenate([action_centers.flatten(), costs])
    
    res = minimize(objective, initial_params, method='SLSQP', bounds=bounds, constraints=constraints, tol=1e-6, options={'maxiter': 500})
    
    if res.success:
        optimized_params = res.x
        p_opt = optimized_params[:n_actions * n_outcomes].reshape(n_actions, n_outcomes)
        c_opt = optimized_params[n_actions * n_outcomes: n_actions * n_outcomes + n_actions]
    else:
        p_opt, c_opt = action_centers, costs
    
    return np.hstack([p_opt, c_opt.reshape(-1, 1)])
```
