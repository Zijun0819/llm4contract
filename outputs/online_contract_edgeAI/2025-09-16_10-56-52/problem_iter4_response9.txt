```python
import numpy as np
from scipy.optimize import minimize, Bounds, LinearConstraint
from sklearn.mixture import GaussianMixture
from sklearn.neighbors import KernelDensity

def agent_solver(v: np.ndarray, content: list[dict]) -> np.ndarray:
    n_outcomes = len(v)
    
    accepted_logs = [log for log in content if log['Agent Action'] == 1]
    rejected_logs = [log for log in content if log['Agent Action'] == -1]
    
    if not accepted_logs:
        return np.hstack([np.full((1, n_outcomes), 1/n_outcomes), np.zeros((1, 1))])
    
    contracts_acc = np.array([log['Contract'] for log in accepted_logs])
    principal_utils = np.array([log['Principal Utility'] for log in accepted_logs])
    
    def solve_p(w, u):
        def objective(p):
            return np.dot(w, p)
        constraints = [
            {'type': 'eq', 'fun': lambda p: np.sum(p) - 1},
            {'type': 'eq', 'fun': lambda p: np.dot(v - w, p) - u}
        ]
        bounds = [(0, 1) for _ in range(n_outcomes)]
        initial_guess = np.ones(n_outcomes) / n_outcomes
        result = minimize(objective, initial_guess, bounds=bounds, constraints=constraints)
        if result.success:
            return result.x
        A_eq = np.vstack([np.ones(n_outcomes), v - w])
        b_eq = np.array([1.0, u])
        linear_constraint = LinearConstraint(A_eq, b_eq, b_eq)
        result_alt = minimize(lambda p: np.dot(w, p), initial_guess, bounds=Bounds(0, 1), constraints=linear_constraint)
        return result_alt.x if result_alt.success else None
    
    p_candidates = []
    for i in range(len(accepted_logs)):
        p_sol = solve_p(contracts_acc[i], principal_utils[i])
        if p_sol is not None:
            p_candidates.append(p_sol)
    
    if not p_candidates:
        return np.hstack([np.full((1, n_outcomes), 1/n_outcomes), np.zeros((1, 1))])
    
    p_candidates = np.array(p_candidates)
    
    max_clusters = min(10, len(p_candidates))
    if max_clusters < 1:
        return np.hstack([np.full((1, n_outcomes), 1/n_outcomes), np.zeros((1, 1))])
    
    bic_scores = []
    for n in range(1, max_clusters + 1):
        gm = GaussianMixture(n_components=n, random_state=42, n_init=3).fit(p_candidates)
        bic_scores.append(gm.bic(p_candidates))
    optimal_n = np.argmin(bic_scores) + 1
    
    gm = GaussianMixture(n_components=optimal_n, random_state=42, n_init=3).fit(p_candidates)
    p_means = gm.means_
    
    action_assignments = gm.predict(p_candidates)
    
    action_min_utils = [np.inf] * optimal_n
    for i, a in enumerate(action_assignments):
        util = np.dot(p_means[a], contracts_acc[i])
        if util < action_min_utils[a]:
            action_min_utils[a] = util
    
    rej_contracts = np.array([log['Contract'] for log in rejected_logs]) if rejected_logs else np.empty((0, n_outcomes))
    action_rej_max = np.full(optimal_n, -np.inf)
    if rej_contracts.size > 0:
        rej_utils = p_means @ rej_contracts.T
        action_rej_max = np.max(rej_utils, axis=1)
    
    costs = np.zeros(optimal_n)
    for a in range(optimal_n):
        cost_lb = max(0, action_rej_max[a]) if action_rej_max[a] > -np.inf else 0
        if action_min_utils[a] != np.inf:
            cost_lb = max(cost_lb, action_min_utils[a])
        costs[a] = cost_lb
    
    if optimal_n > 1:
        kde = KernelDensity(kernel='gaussian', bandwidth=0.05).fit(p_means)
        log_dens = kde.score_samples(p_means)
        weights = np.exp(log_dens - np.max(log_dens))
        weights = weights / weights.sum()
        p_smoothed = np.zeros_like(p_means)
        for a in range(optimal_n):
            p_smoothed[a] = p_means[a] * weights[a]
        p_smoothed = p_smoothed / np.sum(p_smoothed, axis=1, keepdims=True)
    else:
        p_smoothed = p_means
    
    return np.hstack([p_smoothed, costs.reshape(-1, 1)])
```
