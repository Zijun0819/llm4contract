```python
import numpy as np
from scipy.optimize import minimize
from sklearn.cluster import KMeans
from scipy.spatial.distance import cdist

def agent_solver_v2(v: np.ndarray, content: list[dict]) -> np.ndarray:
    accepted_logs = [log for log in content if log['Agent Action'] == 1]
    rejected_logs = [log for log in content if log['Agent Action'] == -1]
    
    if not accepted_logs:
        kmeans = KMeans(n_clusters=3, random_state=0, n_init=10)
        dummy_ps = np.random.dirichlet(np.ones(12), size=3)
        p0 = kmeans.fit(dummy_ps).cluster_centers_
        c0 = np.zeros(3)
        return np.hstack([p0, c0[:, np.newaxis]])
    
    accepted_payments = np.array([log['Contract'] for log in accepted_logs])
    accepted_utils = np.array([log['Principal Utility'] for log in accepted_logs])
    
    n_candidates = min(len(accepted_logs) + len(rejected_logs) // 2, 10)
    n_candidates = max(n_candidates, 3)
    
    inferred_ps = []
    for log in accepted_logs:
        w_i = np.array(log['Contract'])
        u_i = log['Principal Utility']
        if u_i < 1e-10:
            w_expected = w_i - v * (u_i) / np.dot(v, v) * v
            p_proposal = w_expected / np.sum(w_expected)
            inferred_ps.append(p_proposal)
        else:
            res = minimize(lambda p: np.dot(p, w_i), 
                          x0=np.ones(12)/12,
                          constraints=[
                              {'type': 'eq', 'fun': lambda p: np.sum(p) - 1},
                              {'type': 'eq', 'fun': lambda p: np.dot(p, v) - u_i}
                          ],
                          bounds=[(0,1)]*12)
            if res.success:
                inferred_ps.append(res.x)
            else:
                inferred_ps.append(np.ones(12)/12)
    
    inferred_ps = np.array(inferred_ps)
    
    distance_matrix = cdist(inferred_ps, inferred_ps)
    if len(inferred_ps) <= n_candidates:
        p0 = inferred_ps
    else:
        kmeans = KMeans(n_clusters=n_candidates, random_state=0, n_init=10).fit(inferred_ps)
        p0 = kmeans.cluster_centers_
    
    action_assignment = []
    for log in accepted_logs:
        w = np.array(log['Contract'])
        earnings = p0 @ w
        action_assignment.append(np.argmax(earnings))
    
    cost_min = np.zeros(len(p0))
    for a_idx in range(len(p0)):
        indices = [i for i, act in enumerate(action_assignment) if act == a_idx]
        if indices:
            pay_mat = np.array([accepted_logs[i]['Contract'] for i in indices])
            costs = p0[a_idx] @ pay_mat.T
            cost_min[a_idx] = np.min(costs)
        else:
            cost_min[a_idx] = 0.0
    
    if rejected_logs:
        rej_pay = np.array([log['Contract'] for log in rejected_logs])
        rej_earn = p0 @ rej_pay.T
        rej_val = np.max(rej_earn, axis=1)
        cost_min = np.maximum(cost_min, rej_val)
    
    return np.hstack([p0, cost_min[:, np.newaxis]])
```
