```python
import numpy as np
import pandas as pd
from scipy.optimize import linprog
from sklearn.cluster import KMeans
from sklearn.mixture import GaussianMixture
from scipy.spatial.distance import cdist

def agent_solver(v: np.ndarray, content: list[dict]) -> np.ndarray:
    m_outcomes = len(v)
    accepted_logs = [log for log in content if log['Agent Action'] == 1]
    rejected_logs = [log for log in content if log['Agent Action'] == -1]
    n_accepted = len(accepted_logs)
    n_rejected = len(rejected_logs)
    
    def solve_p(w, u):
        A_eq = np.vstack([np.ones(m_outcomes), v - w])
        b_eq = np.array([1.0, u])
        res = linprog(w, A_eq=A_eq, b_eq=b_eq, bounds=[(0,1)]*m_outcomes, method='highs')
        return res.x if res.success else None

    inferred_ps = []
    utilities = []
    for log in accepted_logs:
        p_candidate = solve_p(np.array(log['Contract']), log['Principal Utility'])
        if p_candidate is not None:
            inferred_ps.append(p_candidate)
            utilities.append(log['Principal Utility'])
    inferred_ps = np.array(inferred_ps)
    
    if n_accepted > 0:
        gmm = GaussianMixture(n_components=min(10, n_accepted, 20), random_state=0, n_init=5).fit(inferred_ps)
        p_centers = gmm.means_
        actions_assigned = gmm.predict(inferred_ps)
    else:
        p_centers = np.ones((1, m_outcomes)) / m_outcomes
        actions_assigned = np.zeros(len(inferred_ps), dtype=int)
    
    n_actions = p_centers.shape[0]
    c_ir = np.zeros(n_actions)
    for a in range(n_actions):
        indices = np.where(actions_assigned == a)[0]
        if len(indices) > 0:
            contracts_a = np.array([accepted_logs[i]['Contract'] for i in indices])
            utilities_a = np.array([utilities[i] for i in indices])
            min_wage_per_outcome = np.min(contracts_a, axis=0)
            c_ir[a] = np.dot(p_centers[a], min_wage_per_outcome)
        else:
            c_ir[a] = 0.0
    
    if n_rejected > 0:
        rejected_contracts = np.array([log['Contract'] for log in rejected_logs]).T
        max_utility_per_action = np.max(np.dot(p_centers, rejected_contracts), axis=1)
    else:
        max_utility_per_action = np.full(n_actions, -np.inf)
    
    c_final = np.maximum(c_ir, max_utility_per_action)
    agent_setting = np.hstack([p_centers, c_final.reshape(-1,1)])
    return agent_setting
```
