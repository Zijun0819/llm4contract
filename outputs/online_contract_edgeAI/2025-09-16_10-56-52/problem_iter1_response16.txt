```python
import numpy as np
import pandas as pd
from scipy.optimize import linprog, minimize, LinearConstraint, Bounds
from sklearn.cluster import KMeans, DBSCAN

def agent_solver(v: np.ndarray, content: list) -> np.ndarray:
    n_outcomes = len(v)
    logs = pd.DataFrame(content)
    accepted_logs = logs[logs['Agent Action'] == 1]
    rejected_logs = logs[logs['Agent Action'] == -1]
    
    def solve_p_for_log(log):
        w_i = np.array(log['Contract'])
        u_prin = log['Principal Utility']
        c = w_i
        A_eq = np.array([np.ones(n_outcomes), v - w_i])
        b_eq = np.array([1.0, u_prin])
        bounds = Bounds(0, 1)
        constraints = LinearConstraint(A_eq, b_eq, b_eq)
        result = minimize(lambda p: p @ c, x0=np.ones(n_outcomes)/n_outcomes, constraints=constraints, bounds=bounds, method='trust-constr')
        if result.success:
            return result.x
        else:
            return None

    candidate_ps = []
    for _, log in accepted_logs.iterrows():
        p = solve_p_for_log(log)
        if p is not None:
            candidate_ps.append(p)
            
    if not candidate_ps:
        candidate_ps = [np.ones(n_outcomes)/n_outcomes]
        
    all_p = np.array(candidate_ps)
    n_candidates = min(10, len(candidate_ps))
    kmeans = KMeans(n_clusters=n_candidates, random_state=42, n_init=10).fit(all_p)
    p_centers = kmeans.cluster_centers_
    
    if len(rejected_logs) > 0:
        rej_wages = np.array([log['Contract'] for _, log in rejected_logs.iterrows()]).T
        rej_utils = p_centers @ rej_wages
    else:
        rej_utils = -np.inf * np.ones((n_candidates, 1))
        
    def infer_costs():
        def objective(c, p_set, acc_wages, rej_max):
            total_err = 0.0
            for a, p_a in enumerate(p_set):
                for i, w in enumerate(acc_wages[a]):
                    util_acc = p_a @ w - c[a]
                    if util_acc < -1e-6:
                        total_err += (util_acc)**2
                util_rej_bound = p_a @ rej_max - c[a]
                if util_rej_bound > 1e-6:
                    total_err += (util_rej_bound)**2
            return total_err

        acc_wages_by_action = [[] for _ in range(n_candidates)]
        for _, log in accepted_logs.iterrows():
            w = np.array(log['Contract'])
            action = np.argmax([p @ w for p in p_centers])
            acc_wages_by_action[action].append(w)
            
        rej_max_per_action = np.max(rej_utils, axis=1) if len(rejected_logs) > 0 else -np.inf * np.ones(n_candidates)
        c_init = np.zeros(n_candidates)
        for a in range(n_candidates):
            if acc_wages_by_action[a]:
                min_util = min([p_centers[a] @ w for w in acc_wages_by_action[a]])
                c_init[a] = min_util
            else:
                c_init[a] = 0.0
                
        result = minimize(lambda c: objective(c, p_centers, acc_wages_by_action, rej_max_per_action), x0=c_init, method='L-BFGS-B', bounds=[(0, None)]*n_candidates)
        return result.x if result.success else c_init

    costs = infer_costs()
    agent_setting = np.hstack([p_centers, costs.reshape(-1,1)])
    return agent_setting
```
