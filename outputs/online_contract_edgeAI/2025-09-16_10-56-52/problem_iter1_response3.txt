```python
import numpy as np
from scipy.optimize import linprog
from sklearn.cluster import KMeans
from sklearn.mixture import GaussianMixture
import cvxpy as cp
from scipy.spatial.distance import cdist

def agent_solver(v, content):
    n_candidates = 8
    m_outcomes = len(v)
    L = len(content)
    accepted_logs = [log for log in content if log['Agent Action'] == 1]
    
    def solve_p(w, u):
        m = len(w)
        c = w
        A_eq = [np.ones(m), v - w]
        b_eq = [1.0, u]
        bounds = [(0, 1) for _ in range(m)]
        options = {'tol': 1e-10}
        res = linprog(c, A_eq=A_eq, b_eq=b_eq, bounds=bounds, method='highs-ds', options=options)
        if res.success:
            p = res.x
            if np.allclose(p @ w, u):
                return p
        return None
    
    inferred_ps = []
    for log in accepted_logs:
        w_i = log['Contract']
        u_i = log['Principal Utility']
        p_i = solve_p(w_i, u_i)
        if p_i is not None:
            inferred_ps.append(p_i)
    
    if not inferred_ps:
        inferred_ps = [np.ones(m_outcomes) / m_outcomes for _ in range(4)]
        inferred_ps = np.array(inferred_ps)
    else:
        inferred_ps = np.array(inferred_ps)
        if len(inferred_ps) > n_candidates:
            gmm = GaussianMixture(n_components=n_candidates, covariance_type='diag', random_state=0)
            gmm.fit(inferred_ps)
            inferred_ps = gmm.means_
        else:
            kmeans = KMeans(n_clusters=len(inferred_ps), random_state=0, n_init=10).fit(inferred_ps)
            inferred_ps = kmeans.cluster_centers_
    
    n = len(inferred_ps)
    
    if n == 0:
        p_default = np.ones(m_outcomes) / m_outcomes
        c_default = 0.0
        return np.hstack([p_default.reshape(1, -1), [[c_default]]])
    
    assignments = {}
    for i, log in enumerate(content):
        w = log['Contract']
        if log['Agent Action'] == 1:
            utils = inferred_ps @ w
            best_action = np.argmax(utils)
            assignments[i] = best_action
    
    c_lower = np.zeros(n)
    c_upper = np.full(n, np.inf)
    
    for a in range(n):
        accepted_indices = [i for i, act in assignments.items() if act == a]
        if accepted_indices:
            wages_matrix = np.array([content[i]['Contract'] for i in accepted_indices]).T
            utility_at_a = inferred_ps[a] @ wages_matrix
            if len(accepted_indices) > 0:
                max_payoff = np.max(wages_matrix.T @ inferred_ps[a])
                c_lower[a] = np.min(utility_at_a - max_payoff + inferred_ps[a] @ wages_matrix.min(axis=1))
    
    rej_logs = [log for log in content if log['Agent Action'] == -1]
    for log in rej_logs:
        w_rej = log['Contract']
        rej_utils = inferred_ps @ w_rej
        for a in range(n):
            if rej_utils[a] > c_lower[a]:
                c_lower[a] = rej_utils[a]
    
    p_vars = [cp.Variable(m_outcomes, nonneg=True) for _ in range(n)]
    c_vars = cp.Variable(n, nonneg=True)
    constraints = []
    for a in range(n):
        constraints.append(cp.sum(p_vars[a]) == 1)
    
    for i, log in enumerate(content):
        w_i = log['Contract']
        if log['Agent Action'] == 1:
            a_assigned = assignments.get(i, 0)
            constraints.append(p_vars[a_assigned] @ w_i >= c_vars[a_assigned])
        else:
            for a in range(n):
                constraints.append(p_vars[a] @ w_i <= c_vars[a])
    
    for a in range(n):
        constraints.append(c_vars[a] >= c_lower[a])
    
    prob = cp.Problem(cp.Minimize(cp.sum([cp.sum_squares(p_vars[a] - inferred_ps[a]) for a in range(n)])), constraints)
    try:
        prob.solve(solver=cp.ECOS, abstol=1e-8, reltol=1e-8, max_iters=1000)
        if prob.status not in ["infeasible", "unbounded"]:
            p_final = [p_var.value for p_var in p_vars]
            c_final = c_vars.value
        else:
            p_final = inferred_ps
            c_final = c_lower
    except:
        p_final = inferred_ps
        c_final = c_lower
    
    agent_setting = np.hstack([np.array(p_final), np.array(c_final).reshape(-1, 1)])
    return agent_setting
```
