```python
import numpy as np
import pandas as pd
from scipy.optimize import linprog, lsq_linear
from sklearn.mixture import GaussianMixture


def agent_solver_v2(v: np.ndarray, content: pd.DataFrame) -> np.ndarray:
    """
    Infer a valid agent setting (actions as outcome distributions + nonnegative costs)
    consistent with the historical interaction logs between the principal and agent.

    Args:
        v: (5,) array, principal reward per outcome.
        content: pandas DataFrame with columns 'Contract' (list of 5 floats),
                 'Principal Utility' (float), 'Agent Action' (1 or -1).

    Returns:
        A numpy array of shape (n_actions, 6): first 5 columns are probabilities 
        over the 5 outcomes (sum to 1), last column is the non-negative cost.
    """
    m = v.shape[0]
    contracts = np.vstack(content['Contract'].values)  # shape (N,5)
    principal_utils = content['Principal Utility'].values  # shape (N,)
    agent_actions = content['Agent Action'].values       # shape (N,)

    # Step 1: Separate accepted and rejected contracts
    accept_idx = np.where(agent_actions == 1)[0]
    reject_idx = np.where(agent_actions == -1)[0]

    # To allow the solver to adapt number of actions, pick candidate number by BIC with GMM
    accepted_probs = []
    accepted_wages = []
    for i in accept_idx:
        w = contracts[i]
        u_p = principal_utils[i]
        # We want to find p: p >=0, sum=1, w，p = payout, and p，v - c >= 0
        # Approach: For each accepted contract, find some p s.t p，w == payout and p feasible probs.
        #
        # Here we approximate p by projecting on feasible distributions:
        #
        # Solve linprog to find a p matching contract payout (w，p=const) and sum=1, p>=0
        # To keep consistent with principal utility u_p, roughly p，v - c >=0, but c unknown
        # So just find feasible p with constraint w，p=u_p + c (ignore c for now)
        #
        # Instead we fit p to satisfy contract payments and probabilities constraints:
        res = linprog(
            c=np.zeros(m),
            A_eq=[w, np.ones(m)],
            b_eq=[np.sum(w), 1.0],
            bounds=[(0, 1)]*m,
            method='highs'
        )
        # Above doesn't guarantee p (redundant constraints); instead, try least squares for p:

        # Instead matrix for A_eq = [w; ones] on p, b_eq=[payout=contract payout by w，p, 1]
        # But payout already matches contract, so we approximate p by optmizing p−0, sum=1,
        # close to normalized contract payment vector:
        # We'll fit a p minimizing ||p - normalized contract||^2 s.t p，w = payout and sum=1, p−0.
        c_vec = np.array(content.loc[i, 'Contract'], dtype=np.float64)
        norm_c = c_vec / (c_vec.sum() + 1e-8)

        A_eq = np.vstack([w, np.ones(m)])
        b_eq = np.array([np.dot(w, norm_c), 1.0])
        res_ls = lsq_linear(
            A_eq.T, b_eq, bounds=(0, 1), lsmr_tol='auto', max_iter=1000
        )
        if res_ls.success:
            p_est = res_ls.x
            # enforce probability simplex correction in rare case numerical error
            p_est = np.maximum(p_est, 0)
            p_est /= p_est.sum()
            accepted_probs.append(p_est)
            accepted_wages.append(c_vec)
    if len(accepted_probs) == 0:
        # fallback: assign uniform probabilities
        accepted_probs = [np.ones(m) / m]
        accepted_wages = [np.mean(contracts[accept_idx], axis=0) if len(accept_idx) > 0 else np.ones(m)]

    accepted_probs = np.array(accepted_probs)
    accepted_wages = np.array(accepted_wages)

    # Step 2: Fit GMM to accepted outcome distributions to obtain mixture components corresponding to actions
    # Choose number of actions by BIC minimization in range(2..min(12, len(accepted_probs)))
    n_samples = accepted_probs.shape[0]
    max_components = min(12, n_samples) if n_samples > 2 else 2
    best_bic = np.inf
    best_gmm = None
    for k in range(2, max_components+1):
        try:
            gmm = GaussianMixture(n_components=k, covariance_type='full', random_state=123, n_init=5)
            gmm.fit(accepted_probs)
            bic = gmm.bic(accepted_probs)
            if bic < best_bic:
                best_bic = bic
                best_gmm = gmm
        except Exception:
            pass
    if best_gmm is None:
        # fallback: one cluster
        best_gmm = GaussianMixture(n_components=1, covariance_type='full', random_state=123, n_init=5)
        best_gmm.fit(accepted_probs)

    n_actions = best_gmm.n_components
    # Step 3: Extract means from GMM as probability vectors (clip and project to simplex)
    def project_to_simplex(y):
        # Efficient projection of vector y onto simplex sum=1, y>=0
        # Using algorithm from: https://arxiv.org/pdf/1101.6081.pdf
        y_sorted = -np.sort(-y)
        tmpsum = 0.0
        tmax = 0.0
        for i in range(len(y)):
            tmpsum += y_sorted[i]
            tmax = (tmpsum - 1) / (i + 1)
            if i == len(y) - 1 or y_sorted[i+1] <= tmax:
                break
        theta = tmax
        return np.maximum(y - theta, 0)

    action_ps = []
    for mean in best_gmm.means_:
        p_proj = project_to_simplex(mean)
        action_ps.append(p_proj)
    action_ps = np.vstack(action_ps)

    # Step 4: Infer costs for each action ensuring:
    # (a) IR for accepted logs assigned to that action: E[p,contract] - cost >= 0
    # (b) IC within assigned accepted logs: no better action yields strictly better payoff
    # (c) Rejected logs have all actions' expected payoff < 0

    # Assign accepted logs to closest action in L2 norm on p space (could also use loglikelihood)
    accept_assign = np.argmin(
        ((accepted_probs[:, None, :] - action_ps[None, :, :]) ** 2).sum(axis=2),
        axis=1
    )

    # Initial cost lower bounds: max over accepted assigned logs of cost_i >= p_i，w_i
    c_lower_bounds = np.zeros(n_actions)
    for a in range(n_actions):
        idx_a = np.where(accept_assign == a)[0]
        if len(idx_a) > 0:
            vals = accepted_probs[idx_a] @ accepted_wages[idx_a].T
            # Wait: p_i is shape (len(idx_a),5), accepted_wages shape (len(idx_a),5)
            # Actually, accepted_probs[idx_a] shape (len(idx_a),5)
            # accepted_wages[idx_a] shape (len(idx_a),5)
            # Compute scalar p_i，w_i for each i in idx_a:
            p_i = accepted_probs[idx_a]  # shape (?,5)
            w_i = accepted_wages[idx_a]  # shape (?,5)
            payoff = np.einsum('ij,ij->i', p_i, w_i)
            c_lower_bounds[a] = max(c_lower_bounds[a], payoff.min())  # cost − minimal payoff

    # Step 5: From previous lower bounds on costs (IR) and rejections (cost > payoff)
    # For rejects:
    if len(reject_idx) > 0:
        reject_contracts = contracts[reject_idx]
        r_utils = action_ps @ reject_contracts.T  # shape (n_actions, n_rejects)
        # For each action, cost must be >= max expected payoff over rejected contracts (to forbid acceptance)
        cost_reject = r_utils.max(axis=1)
    else:
        cost_reject = np.zeros(n_actions)

    # Step 6: Final cost guess is max(IR cost, reject threshold)
    costs = np.maximum(c_lower_bounds, cost_reject)
    costs = np.maximum(costs, 0)  # ensure non-negative

    # Step 7: Enforce IC constraints among accepted logs:
    # For each accepted log i assigned to action a,
    # payoff_a(i) - cost_a >= payoff_a'(i) - cost_a' for all a'
    # Rearranged:
    # cost_a' - cost_a >= payoff_a'(i) - payoff_a(i)
    # Work as linear inequalities over costs

    # Formulate and solve LP to find minimal costs satisfying constraints:
    n_vars = n_actions
    A_ub = []
    b_ub = []
    p_accept = accepted_probs
    w_accept = accepted_wages
    for idx, a in enumerate(accept_assign):
        p_i = p_accept[idx]
        w_i = w_accept[idx]
        payoff_a = np.dot(p_i, w_i)
        for a_p in range(n_actions):
            payoff_ap = np.dot(action_ps[a_p], w_i)
            if a_p != a:
                # cost_a' - cost_a >= payoff_a'(i) - payoff_a(i) => -cost_a' + cost_a <= - (payoff_a'(i) - payoff_a(i))
                row = np.zeros(n_vars)
                row[a_p] = -1
                row[a] = 1
                A_ub.append(row)
                b_ub.append(-(payoff_ap - payoff_a))
    # Also costs − estimated initial costs from reject and IR step: costs >= lower bounds
    A_lb = -np.eye(n_vars)
    b_lb = -costs

    A_ub = np.array(A_ub) if A_ub else np.zeros((0,n_vars))
    b_ub = np.array(b_ub) if b_ub else np.array([])
    
    A = np.vstack((A_ub, A_lb))
    b = np.concatenate((b_ub, b_lb))

    # Objective: minimize sum of costs (or zero since only feasibility)
    c_obj = np.ones(n_vars)

    # Solve LP
    res = linprog(c=c_obj, A_ub=A, b_ub=b, bounds=[(0, None)]*n_vars, method='highs')
    if not res.success:
        # fallback: use previous costs
        costs = costs
    else:
        costs = res.x

    # Clip costs non-negative
    costs = np.maximum(costs, 0)

    # Final agent setting: concatenate action_ps and costs as last col
    agent_setting = np.hstack([action_ps, costs[:, np.newaxis]])
    return agent_setting
```
