```python
import numpy as np
import pandas as pd
from scipy.optimize import linprog
from sklearn.cluster import AgglomerativeClustering

def agent_solver_v2(v: np.ndarray, content: list[dict]) -> np.ndarray:
    """
    Infer a valid agent setting matrix from historical logs.

    Args:
        v: Principal's value vector for the 5 outcomes, shape (5,).
        content: List of dicts, each with keys:
            - "Contract": list or np.array shape (5,), payment vector for 5 outcomes.
            - "Principal Utility": float, principal's utility for contract.
            - "Agent Action": int, 1 for accept, -1 for reject.

    Returns:
        np.ndarray with shape (n_actions, 6):
          - First 5 columns are outcome probabilities summing to 1.
          - Last column is non-negative agent cost.
    """
    m = len(v)  # number of outcomes: 5
    L = len(content)

    # Parse data arrays for efficiency
    contracts = np.array([np.array(log['Contract']) for log in content])  # (L,5)
    p_utils = np.array([log['Principal Utility'] for log in content])
    a_actions = np.array([log['Agent Action'] for log in content])

    # Step 1: Separate accepted and rejected logs
    accepted_idx = np.where(a_actions == 1)[0]
    rejected_idx = np.where(a_actions == -1)[0]

    if accepted_idx.size == 0:
        # No accept logs -> agent always rejects, return trivial agent setting (single action with zero prob and zero cost)
        return np.hstack([np.ones((1, m)) / m, np.array([[0.]])])

    W_accept = contracts[accepted_idx]  # (A,5)
    U_accept = p_utils[accepted_idx]    # (A,)

    W_reject = contracts[rejected_idx] if rejected_idx.size > 0 else np.empty((0, m))

    A = accepted_idx.size
    R = rejected_idx.size

    # ----------------------------
    # Step 2: Infer agent's actions from accepted contracts:
    # We want to uncover n distinct agent actions explaining accepted contracts.
    # Each agent action = (p in simplex, c >=0) explaining that agent accepts contract iff E_p[w] >= c.
    # Try to find cluster centers for outcome probs from accepted contracts minimizing a surrogate function.
    # Using W_accept and assumed expected utilities ~ (p@w - c)

    # We'll cluster weighted distributions that map contracts to utilities to infer plausible agent actions.

    # Initial heuristic: estimate expected outcome distribution per contract via LP 
    # (try to find p s.t p @ w = u + c for some non-neg c, here simplified guess c=0 for approximation)
    # Since agent expected utility = p@w - c >=0 if accept, minimize deviation to infer p

    def infer_p_for_contract(w, u):
        # Solve for p: maximize p.@w s.t sum p=1, p>=0, and p@v should be consistent with 
        # principal's utility and payments roughly.
        # Here simplify: solve min ||p@w - u - c|| with c=0 guess, thus linear program:
        cvec = np.zeros(m)
        A_eq = [np.ones(m)]
        b_eq = [1.0]
        bounds = [(0,1)] * m

        # Because p@w = u + c >= u, approximate p such that p@w ~ u + shift
        # For trials, fix c=0, solve feasibility for p with expected p@w¡Ý u, here use linprog to find feasible p close to uniform
        # In absence of exact c, solve LP to find some p so p@w >= u
        res = linprog(
            c = np.zeros(m),
            A_ub = [-w],
            b_ub = [-u],
            A_eq = A_eq,
            b_eq = b_eq,
            bounds = bounds,
            method = "highs",
            options={"disp": False}
        )
        if res.success:
            return res.x
        else:
            # fallback uniform if infeasible
            return np.ones(m)/m

    # Infer approximate p vectors for accepted contracts
    approx_ps = np.vstack([infer_p_for_contract(W_accept[i], U_accept[i]) for i in range(A)])

    # Step 3: Cluster p's to extract agent actions - adaptive cluster number based on stability and minimal number
    # To avoid too many clusters, try from 2 up to min(A,10)
    max_clusters = min(10, A)
    best_n = 1
    best_score = np.inf
    best_labels = None
    for k in range(1, max_clusters+1):
        # Agglomerative clustering on approx_ps in L1-norm (manhattan) space to get diverse cluster shapes
        clustering = AgglomerativeClustering(n_clusters=k, affinity="l1", linkage="average")
        labels = clustering.fit_predict(approx_ps)
        centers = np.array([approx_ps[labels == i].mean(axis=0) for i in range(k)])

        # Check quality: measure total intra-cluster distance
        dist = 0
        for i in range(k):
            members = approx_ps[labels == i]
            dist += np.sum(np.linalg.norm(members - centers[i], ord=1, axis=1))
        # Penalize too many clusters lightly to favor robustness
        score = dist + 0.1*k
        if score < best_score:
            best_score = score
            best_n = k
            best_labels = labels
        else:
            # No improvement, stop increasing clusters
            break

    n = best_n
    p_centers = np.array([approx_ps[best_labels==i].mean(axis=0) for i in range(n)])

    # Renormalize p_centers to ensure each sums to 1 % handle numerical precision
    p_centers = np.clip(p_centers, 0, None)
    p_sums = p_centers.sum(axis=1, keepdims=True)
    zero_sum = (p_sums.squeeze() == 0)
    # Fix zero sums to uniform
    p_centers[zero_sum] = 1/m
    p_centers /= p_centers.sum(axis=1, keepdims=True)

    # ----------------
    # Step 4: Infer costs c_i >=0 for each action i, consistent with:
    # Agent accepts contract w iff p_i @ w - c_i >=0 (IR),
    # Reject contracts w: for all i, p_i @ w - c_i <0 (IR rejection),
    # Agent picks the best action for accepted contracts (IC - incentive compatibility).

    # For each accepted contract j, agent picked some action i_j that fulfills:
    #   p_i_j @ w_j - c_i_j >= p_h @ w_j - c_h for all h
    #   p_i_j @ w_j - c_i_j >= 0 (IR)
    # For each rejected contract k:
    #   max_i (p_i @ w_k - c_i) < 0.

    # We do not have direct mapping of action chosen per accepted contract.
    # Infer actions assignment by best fit: assign contract j to i maximizing p_i@w_j

    action_assign = np.argmax(p_centers @ W_accept.T, axis=0)  # (A,) action indices

    # Set up LP variables: c = [c0, ..., c_{n-1}], costs to be found >=0

    # Collect IR constraints for accepted logs:
    # p_i@w_j - c_i >= 0 for assigned i=action_assign[j]
    # IC constraints: for all h, p_{i_j}@w_j - c_{i_j} >= p_h@w_j - c_h

    # Collect Rejection constraints:
    # For each rejected contract w_k: max_i (p_i @ w_k - c_i) < 0
    # Which is: For all i, p_i @ w_k - c_i <= epsilon < 0 (use negative small margin)

    # Formulate LP as feasibility problem minimizing sum(c) to get parsimonious solution

    # Variables: vector c (costs), shape (n,)
    # Constraints will be linear inequalities in form A_ub @ c <= b_ub and A_eq @ c = b_eq with bounds c >=0

    # Build matrices
    eps = 1e-5

    from scipy.optimize import linprog

    A_ub = []
    b_ub = []
    # IC constraints for accepted contracts:
    # For each j in accepted logs:
    # For all h in [0,n):
    # (p_h - p_{i_j}) @ w_j <= c_h - c_{i_j}
    # Re-arranged:
    # c_h - c_{i_j} >= (p_h - p_i_j) @ w_j
    # => (c_h) - (c_i_j) >= RHS, => -(c_h) + (c_i_j) <= -RHS

    for idx_j, j in enumerate(accepted_idx):
        w_j = W_accept[idx_j]
        i_j = action_assign[idx_j]
        p_ij = p_centers[i_j]

        for h in range(n):
            lhs = np.zeros(n)
            lhs[h] = -1
            lhs[i_j] = 1
            rhs = -((p_centers[h] - p_ij) @ w_j)
            A_ub.append(lhs)
            b_ub.append(rhs)

    # IR constraints accepted: c_i <= p_i @ w_j (so p_i @ w_j - c_i >=0)
    for idx_j, j in enumerate(accepted_idx):
        w_j = W_accept[idx_j]
        i_j = action_assign[idx_j]
        lhs = np.zeros(n)
        lhs[i_j] = 1
        rhs = (p_centers[i_j] @ w_j)
        # c_i <= rhs => c_i - rhs <= 0
        A_ub.append(lhs)
        b_ub.append(rhs)

    # Rejection constraints:
    # For each rejected contract w_k:
    # For all i: p_i @ w_k - c_i < 0 -> c_i > p_i @ w_k
    # Write as -c_i < -p_i@w_k -> c_i > p_i@w_k => -c_i < -p_i@w_k
    # flip to: c_i > p_i@w_k -> c_i - p_i@w_k >= eps (margins for strict rejection)
    # So c_i - p_i@w_k >= eps
    # Or equivalently: - c_i <= - p_i@w_k - eps

    for k in range(R):
        w_k = W_reject[k]
        for i in range(n):
            lhs = np.zeros(n)
            lhs[i] = -1
            rhs = -((p_centers[i] @ w_k) + eps)
            A_ub.append(lhs)
            b_ub.append(rhs)

    A_ub = np.array(A_ub) if A_ub else None
    b_ub = np.array(b_ub) if b_ub else None

    bounds = [(0, None)] * n

    # Objective: minimize sum c_i to get parsimonious cost vector
    c_obj = np.ones(n)

    # Solve LP
    res = linprog(
        c=c_obj,
        A_ub=A_ub,
        b_ub=b_ub,
        bounds=bounds,
        method="highs",
        options={"disp": False}
    )

    if res.success:
        costs = res.x
        # Fix negatives to zero tolerance to zero
        costs = np.clip(costs, 0, None)
    else:
        # fallback: zero costs (may violate IC/IR, but provide a fallback)
        costs = np.zeros(n)

    # ----------------
    # Step 5: Return final agent setting matrix (n, 6)
    # Columns 0-4: outcome probabilities per action
    # Column 5: action costs

    agent_setting = np.hstack([p_centers, costs[:, None]])

    return agent_setting
```
