```python
import numpy as np
import pandas as pd
from scipy.optimize import linprog, minimize
from sklearn.cluster import AgglomerativeClustering


def agent_solver_v2(v: np.ndarray, content: pd.DataFrame) -> np.ndarray:
    """
    Infer a valid agent setting (action distributions over outcomes + costs)
    consistent with historical interaction logs under IR and IC constraints.
    
    Args:
        v: Principal's reward vector for 5 outcomes, shape (5,)
        content: pd.DataFrame with columns ['Contract', 'Principal Utility', 'Agent Action']
            - Contract: list or array of 5 payments
            - Principal Utility: float (0 if agent rejects)
            - Agent Action: 1 (accept) or -1 (reject)
            
    Returns:
        agent_setting: np.ndarray, shape (n_actions, 6)
            - First 5 cols: probability distributions over outcomes summing to 1
            - Last col: non-negative agent cost
    """
    
    m = v.size
    logs = content.copy()
    L = len(logs)

    # Convert Contract column to np arrays (5,)
    contracts = np.vstack(logs['Contract'].to_numpy())

    accept_mask = (logs['Agent Action'] == 1).to_numpy()
    reject_mask = (logs['Agent Action'] == -1).to_numpy()

    accepted_contracts = contracts[accept_mask]  # shape (L_accept,5)
    accepted_pu = logs.loc[accept_mask, 'Principal Utility'].to_numpy()  # shape (L_accept,)

    rejected_contracts = contracts[reject_mask]  # shape (L_reject,5)

    # -- STEP 1: Infer candidate outcome distributions from accepted logs via LP

    # For each accepted log:
    # We solve for p >=0, sum(p)=1 s.t agent utility p . w - c >= 0
    # However cost unknown: We treat agent expected payment p.w ¡Ý cost c, and
    # IR from logs: principal utility = v.p - p.w = given, so p.w = v.p - PU
    #
    # But p is unknown. To get p, solve min ||p - v_norm|| s.t p.w = v.p - PU, sum(p)=1, p>=0,
    # Use LP/Quadratic find feasible p.

    candidate_ps = []
    eps_lp = 1e-9

    # Helper: for given contract w and principal utility u_principal:
    # Agent utility = E_p[w] - c
    # Principal utility = E_p[v] - E_p[w] = u_principal
    # => E_p[w] = E_p[v] - u_principal
    # c = E_p[w] - agent utility >= 0

    for i, u_p in enumerate(accepted_pu):
        w = accepted_contracts[i]
        # We want to find p with
        # sum(p) = 1
        # p @ w = p @ v - u_p
        # p >= 0
        A_eq = np.vstack([np.ones(m), w - v])
        b_eq = np.array([1.0, -u_p])
        bounds = [(0, 1) for _ in range(m)]

        # Objective: try to get p close to "v normalized" or uniform distribution to avoid extreme
        # We'll minimize distance to uniform distribution
        c_obj = np.ones(m)  # minimize sum p_i (just placeholder)

        res = linprog(c=c_obj, A_eq=A_eq, b_eq=b_eq, bounds=bounds, method='highs')
        if res.success:
            p = res.x
            # sanitize numerical errors: clip small negatives
            p[p < 0] = 0
            p = p / np.sum(p)
            candidate_ps.append(p)
        else:
            # fall back: solve least squares projection on constraints manually
            # or skip candidate for numerical problems
            pass

    if not candidate_ps:
        # If no exact feasible p found for accepted, fallback:
        # Approximate each p by normalized product of w and v (heuristic)
        for w, u_p in zip(accepted_contracts, accepted_pu):
            p_approx = np.clip(v / np.sum(v), 0, 1)
            p_approx = p_approx / p_approx.sum()
            candidate_ps.append(p_approx)

    candidate_ps = np.array(candidate_ps)  # (num_accept,5)

    # -- STEP 2: Cluster candidate p vectors using AgglomerativeClustering
    # We use adaptive n_clusters (between 3 and 10) based on silhouette heuristic

    from sklearn.metrics import silhouette_score

    best_labels = None
    best_num = 1
    best_score = -1
    for k in range(3, min(15, len(candidate_ps)+1)):
        model = AgglomerativeClustering(n_clusters=k, linkage='average')
        labels = model.fit_predict(candidate_ps)
        if len(set(labels)) < 2:
            continue
        try:
            score = silhouette_score(candidate_ps, labels)
            if score > best_score:
                best_score = score
                best_labels = labels
                best_num = k
        except Exception:
            # Some failures may occur if identical vectors
            continue

    if best_labels is None:
        # fallback to 1 cluster -> mean p of all candidates
        best_num = 1
        best_labels = np.zeros(len(candidate_ps), dtype=int)

    n_actions = best_num
    p_clusters = np.zeros((n_actions, m))
    for k in range(n_actions):
        members = candidate_ps[best_labels == k]
        if len(members) == 0:
            p_clusters[k] = np.ones(m) / m
        else:
            avg_p = np.mean(members, axis=0)
            p_clusters[k] = avg_p / np.sum(avg_p)

    # -- STEP 3: Assign ALL accepted contracts to best-fitting action via p @ w objective
    assigns = - np.ones(L, dtype=int)
    # For accepted logs:
    for idx, log_idx in enumerate(np.where(accept_mask)[0]):
        w = contracts[log_idx]
        # Compute expected payment under each p cluster: E_p[w] = p @ w
        payoffs = p_clusters @ w
        # agent accepts => utility >= 0 => assigned to max E_p[w] to explain acceptance
        assigns[log_idx] = np.argmax(payoffs)

    # -- STEP 4: Estimate cost c for each action to satisfy IR and IC from accepted logs

    # For each action a:
    # IR from accepted logs assigned to a:
    # cost <= E_p[w] for these logs (agent utility >=0)
    # So lower bound on cost is max over (E_p[w] - 0)
    # We'll set cost = minimal c consistent with accept and rejects

    c_actions = np.zeros(n_actions)
    for a in range(n_actions):
        accepted_indices = np.where(assigns == a)[0]
        if len(accepted_indices) == 0:
            c_actions[a] = 0.0
            continue
        # cost <= min over accepted logs of E_p[w], since agent utility >= 0 => p.w - c >=0 => c <= p.w
        E_pw_accepts = []
        for i in accepted_indices:
            p = p_clusters[a]
            w = contracts[i]
            E_pw_accepts.append(np.dot(p, w))
        c_actions[a] = np.min(E_pw_accepts)  # smallest upper bound on cost

    # -- STEP 5: Ensure IC for rejects: agent must reject those contracts (agent utility < 0)
    # So for rejected contracts:
    # agent utility under all actions must be <0:
    # p.w - c < 0 -> c > p.w for all a and reject contracts

    if np.any(reject_mask):
        rejected_inds = np.where(reject_mask)[0]
        rejected_ws = contracts[rejected_inds]  # (num_rej,5)
        for a in range(n_actions):
            p = p_clusters[a]
            # Max expected payment for rejected contracts:
            pw_rej_vals = rejected_ws @ p
            max_pw_rej = np.max(pw_rej_vals)
            # cost must be strictly greater than max_pw_rej to make utility negative
            if max_pw_rej >= c_actions[a]:
                c_actions[a] = max_pw_rej + 1e-6

    # -- STEP 6: Sanity check for cost ¡Ý0
    c_actions = np.maximum(c_actions, 0)

    # -- STEP 7: Final output matrix: probabilities + cost column
    agent_setting = np.hstack([p_clusters, c_actions[:, None]])

    return agent_setting
```
