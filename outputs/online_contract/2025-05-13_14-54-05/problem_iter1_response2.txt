```python
import numpy as np
from scipy.optimize import linprog
from sklearn.cluster import AgglomerativeClustering


def agent_solver_v2(v: np.ndarray, content: list[dict]) -> np.ndarray:
    """
    Infer a valid agent setting matrix (actions x (5 outcomes + 1 cost)) consistent with
    historical logs: each row is [p_1, ..., p_5, cost].
    Adaptively selects number of actions and ensures IR/IC constraints from logs.
    """

    # Parameters
    m = v.size
    logs = content
    L = len(logs)
    contracts = np.array([log['Contract'] for log in logs])
    agent_actions = np.array([log['Agent Action'] for log in logs])
    principal_utils = np.array([log['Principal Utility'] for log in logs])

    # Step 1: Extract accepted contract indices and rejected contract indices
    accept_idx = np.where(agent_actions == 1)[0]
    reject_idx = np.where(agent_actions == -1)[0]

    # If no acceptances, fallback to trivial agent (one action uniform dist zero cost)
    if len(accept_idx) == 0:
        p_uniform = np.ones(m) / m
        c_zero = 0.0
        return np.hstack([p_uniform.reshape(1, -1), np.array([[c_zero]])])

    # Step 2: For each accepted contract, solve a LP to find a plausible outcome distribution p:
    # We look for p s.t:
    #   sum(p) = 1,
    #   p >= 0,
    #   p @ w - cost >= 0 (agent accepts, so utility >= 0),
    #   and p @ v = principal utility + p @ w (since principal utility = p@v - p@w)
    # Thus cost = p @ w - agent utility >=0
    # Since agent utility >=0, cost <= p@w
    #
    # We approximate p by minimizing ||p - p0|| for some p0 (we take p0 uniform as baseline)
    # under constraints:
    #   p@w = p@v - principal_util (=> linear equality)
    #
    # We use least squares with linear equality and sum to 1, and p>=0.

    def infer_p(w, principal_u):
        # Constraints: p@w = p@v - principal_u
        A_eq = np.vstack([np.ones(m), w])
        b_eq = np.array([1.0, (v @ w) - principal_u])  # rearranged target

        # Actually, principal_u = p@v - p@w => p@w = p@v - principal_u
        # But v fixed, unknown p, we want to solve for p
        # So we treat p as variable, solve:
        # p@v - p@w = principal_u
        # or p@(v - w) = principal_u

        # Actually, this is one eq, not two.
        # So better to do:
        # sum p =1
        # p @ (v - w) = principal_u

        A_eq = np.array([np.ones(m), v - w])
        b_eq = np.array([1.0, principal_u])

        # Bounds p_i in [0,1]
        bounds = [(0, 1) for _ in range(m)]

        # Objective: minimize distance to uniform distribution (as prior)
        c_obj = np.zeros(m)

        # Use linprog to find feasible p (any feasible p suffices)
        res = linprog(c=c_obj, A_eq=A_eq, b_eq=b_eq, bounds=bounds, method='highs')

        if res.success:
            return res.x
        else:
            # fallback: project uniform to constraints by least squares
            from scipy.optimize import minimize

            def obj(p):
                return np.sum((p - (1.0 / m)) ** 2)

            cons = (
                {'type': 'eq', 'fun': lambda p: np.sum(p) - 1},
                {'type': 'eq', 'fun': lambda p: p @ (v - w) - principal_u},
            )
            bounds_m = [(0, 1) for _ in range(m)]
            x0 = np.ones(m) / m
            sol = minimize(obj, x0, bounds=bounds_m, constraints=cons, method='SLSQP', options={'maxiter': 500})
            if sol.success and np.all(sol.x >= -1e-8):
                return np.clip(sol.x, 0, 1)
            else:
                return None

    inferred_ps = []
    valid_accept_idx = []
    for i in accept_idx:
        p_i = infer_p(contracts[i], principal_utils[i])
        if p_i is not None:
            inferred_ps.append(p_i)
            valid_accept_idx.append(i)

    if len(inferred_ps) == 0:
        # No feasible p's found, fallback trivial
        p_uniform = np.ones(m) / m
        c_zero = 0.0
        return np.hstack([p_uniform.reshape(1, -1), np.array([[c_zero]])])

    inferred_ps = np.array(inferred_ps)

    # Step 3: Cluster inferred_ps to find distinct agent actions
    # Use agglomerative clustering with adaptive number of clusters by distance threshold
    max_clusters = min(10, len(inferred_ps))
    clustering = AgglomerativeClustering(n_clusters=None, distance_threshold=0.15)
    clustering.fit(inferred_ps)
    labels = clustering.labels_
    n_actions = labels.max() + 1

    # Compute cluster centers as action outcome distributions p
    p_actions = np.zeros((n_actions, m))
    for a in range(n_actions):
        members = inferred_ps[labels == a]
        if len(members) > 0:
            mean_p = np.mean(members, axis=0)
            mean_p = np.clip(mean_p, 0, 1)
            mean_p /= mean_p.sum()
            p_actions[a] = mean_p
        else:
            # fallback uniform if empty cluster (should not happen)
            p_actions[a] = np.ones(m) / m

    # Step 4: Estimate cost c for each action to satisfy IR and IC constraints
    # IR: For accepted contracts assigned to that action, agent utility >=0:
    #     c_a <= p_a @ w  (cost â‰¤ expected payment)
    # IC: For rejected contracts, ensure cost > max over p_a @ w (agent rejects)
    # Finally, pick c_a as max over min accepted expected payment and max rejected expected payment + epsilon

    # Assign each accepted log to closest action by L1 distance on p
    assigned_actions = -np.ones(L, dtype=int)
    for i in valid_accept_idx:
        p_i = infer_p(contracts[i], principal_utils[i])
        if p_i is None:
            continue
        dists = np.sum(np.abs(p_actions - p_i), axis=1)
        assigned_actions[i] = np.argmin(dists)

    # For logs not accepted or no p inferred, assign -1 (no assignment)
    # Compute costs
    c_actions = np.zeros(n_actions)
    epsilon = 1e-5

    for a in range(n_actions):
        # Accepted logs assigned to a
        idx_accept_a = np.where(assigned_actions == a)[0]
        if len(idx_accept_a) > 0:
            # Compute minimal expected payment over those contracts
            epays = np.array([p_actions[a] @ contracts[i] for i in idx_accept_a])
            c_lower_bound = epays.min()
        else:
            c_lower_bound = 0.0

        # For rejected logs, find max expected payment to ensure cost > all rejected expected payments (IC)
        if len(reject_idx) > 0:
            epays_rej = np.array([p_actions[a] @ contracts[i] for i in reject_idx])
            c_rej_bound = epays_rej.max() + epsilon
        else:
            c_rej_bound = 0.0

        c_actions[a] = max(c_lower_bound, c_rej_bound, 0.0)

    # Step 5: Verify IR and IC constraints for all logs, adjust if needed
    # If any accepted log assigned fails IR, increase cost; if any rejected log fails IC, increase cost
    adjusted = True
    iteration = 0
    max_iter = 10
    while adjusted and iteration < max_iter:
        adjusted = False
        iteration += 1

        # IR: For accepted logs
        for i in valid_accept_idx:
            a = assigned_actions[i]
            if a == -1:
                continue
            p_a = p_actions[a]
            cost = c_actions[a]
            util = p_a @ contracts[i] - cost
            if util < -1e-8:
                # Increase cost to satisfy IR
                c_actions[a] = p_a @ contracts[i]
                adjusted = True

        # IC: For rejected logs
        for i in reject_idx:
            for a in range(n_actions):
                p_a = p_actions[a]
                cost = c_actions[a]
                util = p_a @ contracts[i] - cost
                if util >= -1e-8:
                    # Increase cost to break IC for rejected contract
                    c_actions[a] = p_a @ contracts[i] + epsilon
                    adjusted = True

    # Step 6: Normalize p_actions to sum to 1 again (numerical safety)
    p_actions = np.clip(p_actions, 0, 1)
    p_actions /= p_actions.sum(axis=1, keepdims=True)

    # Step 7: Build final agent setting matrix (actions x (5 + 1))
    agent_setting = np.hstack([p_actions, c_actions.reshape(-1, 1)])

    return agent_setting
```
