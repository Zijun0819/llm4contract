```python
import numpy as np
from sklearn.cluster import KMeans
from scipy.optimize import linprog

def agent_solver(v: np.ndarray, content: list[dict]) -> np.ndarray:
    """
    Infer a valid agent setting matrix (actions x [probabilities over 5 outcomes + cost]) that explains all historical logs.
    Args:
        v: Principal's reward vector for 5 outcomes, shape (5,)
        content: List of dicts with keys 'Contract' (list of 5 payments), 'Principal Utility' (float), 'Agent Action' (1 or -1)

    Returns:
        agent_setting: ndarray of shape (n_actions, 6), with first 5 columns probability distributions and last column cost >= 0
    """
    m = v.shape[0]
    L = len(content)

    # Extract contract matrix W (L x m), agent actions A, principal utilities U
    W = np.array([log['Contract'] for log in content])  # shape (L, m)
    A = np.array([log['Agent Action'] for log in content])  # shape (L,)
    U = np.array([log['Principal Utility'] for log in content])  # shape (L,)

    # 1) Separate accepted and rejected logs
    accepted_idx = np.where(A == 1)[0]
    rejected_idx = np.where(A == -1)[0]

    # 2) For each accepted contract: agent's expected utility >= 0, principal utility = p @ (v - w)
    # We want to find p (prob dist over outcomes) and cost c >= 0 for each action
    # Heuristic: Cluster accepted contracts by outcome distribution inferred from contracts and utilities

    # Define a function to estimate agent outcome distribution p for each accepted contract
    # by solving LP: find p >=0, sum p=1, s.t p @ w = c + 0 (agent utility >=0), c unknown but inferred later
    # Since agent cost unknown, and principal utility = p @ (v - w) = p @ v - p @ w
    # We can guess p that fits p @ w ~ agent cost (unknown) but p @ v - p @ w = principal utility U[i]
    # Instead, approximate p by maximizing correlation with w and v-U[i]

    # We formulate LP: For each accepted contract i,
    # find p_i, s.t sum p_i=1, p_i>=0, and p_i @ w_i = c_i unknown, p_i @ v - p_i @ w_i = U_i given

    # We use a relaxed approach: For each accepted contract i,
    # solve LP: minimize ||p @ v - p @ w_i - U_i||, s.t sum p=1, p>=0
    # In practice, we solve LP to find p_i satisfying sum p=1, minimize |p @ (v-w_i) - U_i| small

    def infer_p_for_contract(w_i, u_i):
        # minimize |p@(v - w_i) - u_i| s.t sum p=1, p>=0
        # convert to two LPs: minimize p@(v - w_i) - u_i and minimize -(p@(v - w_i) - u_i)
        coeff = v - w_i
        # LP1: min p@(v - w_i)
        res1 = linprog(c=coeff, A_eq=[np.ones(m)], b_eq=[1], bounds=[(0,1)]*m, method='highs')
        # LP2: max p@(v - w_i) = min -p@(v - w_i)
        res2 = linprog(c=-coeff, A_eq=[np.ones(m)], b_eq=[1], bounds=[(0,1)]*m, method='highs')
        candidates = []
        if res1.success:
            candidates.append(res1.x)
        if res2.success:
            candidates.append(res2.x)
        # Choose candidate minimizing |p@(v - w_i) - u_i|
        best_p = None
        best_err = np.inf
        for p_cand in candidates:
            err = abs(p_cand @ coeff - u_i)
            if err < best_err:
                best_err = err
                best_p = p_cand
        return best_p

    # Gather inferred p for accepted contracts
    inferred_ps = []
    accepted_indices_for_p = []
    for i in accepted_idx:
        p_i = infer_p_for_contract(W[i], U[i])
        if p_i is not None:
            inferred_ps.append(p_i)
            accepted_indices_for_p.append(i)
    if len(inferred_ps) == 0:
        # fallback: uniform distributions for accepted contracts
        inferred_ps = [np.ones(m)/m] * len(accepted_idx)
        accepted_indices_for_p = list(accepted_idx)

    inferred_ps = np.array(inferred_ps)  # shape (N_acc, m)

    # 3) Cluster inferred_ps to get n_actions representative outcome distributions p_a
    # Choose n_actions adaptively: from 3 to 10, pick smallest n with stable clustering
    best_n = 3
    best_inertia = np.inf
    best_labels = None
    best_centers = None
    for n_try in range(3, min(10, len(inferred_ps)) + 1):
        km = KMeans(n_clusters=n_try, random_state=42, n_init=10).fit(inferred_ps)
        if km.inertia_ < best_inertia:
            best_inertia = km.inertia_
            best_n = n_try
            best_labels = km.labels_
            best_centers = km.cluster_centers_

    p_actions = best_centers  # shape (best_n, m)

    # 4) For each accepted contract, assign cluster/action a that best explains agent acceptance:
    # Agent utility for contract i with action a = p_a @ w_i - c_a >= 0 (IR)
    # Principal utility U[i] = p_a @ (v - w_i) if accepted, else zero
    # We don't know c_a yet; estimate cost c_a for each action by IR constraints from accepted logs.

    # Build matrix for LP to solve costs c_a >= 0
    # Constraints:
    # For each accepted contract i assigned to action a_i:
    # p_a_i @ w_i - c_a_i >= 0  (agent IR)
    # For rejected contracts j:
    # max_a p_a @ w_j - c_a < 0  (agent rejects all contracts)

    assign_a = np.full(L, -1, dtype=int)
    for idx_i, label in zip(accepted_indices_for_p, best_labels):
        assign_a[idx_i] = label

    n_actions = best_n

    # Prepare LP to find costs c_a >=0 satisfying:
    # For accepted logs i:
    # c_{a_i} <= p_{a_i} @ w_i
    # For rejected logs j:
    # For all a: c_a > p_a @ w_j  (strictly greater => c_a >= p_a @ w_j + slack)
    # Use slack = 1e-8 to ensure strictness

    # Number of variables: n_actions costs c_a
    # Constraints:
    # accepted: c_a <= p_a @ w_i  => -c_a >= -p_a @ w_i
    # rejected: c_a >= p_a @ w_j + slack

    slack = 1e-8

    # Build A_ub, b_ub for linprog with bounds c_a >= 0
    # accepted constraints: -c_a <= -p_a @ w_i
    # rejected constraints: c_a >= p_a @ w_j + slack -> -c_a <= -(p_a @ w_j + slack)

    A_ub = []
    b_ub = []

    for i in accepted_idx:
        a_i = assign_a[i]
        if a_i == -1:
            # not assigned, skip
            continue
        # -c_a_i <= -p_a_i @ w_i
        row = np.zeros(n_actions)
        row[a_i] = -1
        A_ub.append(row)
        b_ub.append(-p_actions[a_i] @ W[i])

    for j in rejected_idx:
        for a in range(n_actions):
            # -c_a <= -(p_a @ w_j + slack)
            row = np.zeros(n_actions)
            row[a] = -1
            A_ub.append(row)
            b_ub.append(-(p_actions[a] @ W[j] + slack))

    A_ub = np.array(A_ub)
    b_ub = np.array(b_ub)

    bounds = [(0, None)] * n_actions

    # Objective: minimize sum costs (arbitrary)
    c_obj = np.ones(n_actions)

    # Solve LP
    res = linprog(c=c_obj, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')

    if not res.success:
        # fallback: nonnegative costs zero
        costs = np.zeros(n_actions)
    else:
        costs = res.x

    # 5) Verify consistency: for accepted contracts, agent utility >=0
    # for rejected contracts, max_a agent utility < 0
    # If violated, increase slack and retry (up to 3 times)
    for attempt in range(3):
        violated = False
        for i in accepted_idx:
            a_i = assign_a[i]
            if a_i == -1:
                continue
            util = p_actions[a_i] @ W[i] - costs[a_i]
            if util < -1e-8:
                violated = True
                break
        if violated:
            slack *= 10
            for j in rejected_idx:
                for a in range(n_actions):
                    b_ub[len(accepted_idx)*1 + j*n_actions + a] = -(p_actions[a] @ W[j] + slack)
            res = linprog(c=c_obj, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')
            if not res.success:
                costs = np.zeros(n_actions)
                break
            costs = res.x
        else:
            # Check rejected constraints
            for j in rejected_idx:
                max_util = -np.inf
                for a in range(n_actions):
                    util = p_actions[a] @ W[j] - costs[a]
                    if util > max_util:
                        max_util = util
                if max_util >= -1e-8:
                    violated = True
                    break
            if violated:
                slack *= 10
                for j in rejected_idx:
                    for a in range(n_actions):
                        b_ub[len(accepted_idx)*1 + j*n_actions + a] = -(p_actions[a] @ W[j] + slack)
                res = linprog(c=c_obj, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')
                if not res.success:
                    costs = np.zeros(n_actions)
                    break
                costs = res.x
            else:
                break

    # 6) Normalize p_actions to ensure it's valid distribution (sum=1, nonneg)
    p_actions = np.clip(p_actions, 0, None)
    p_actions /= p_actions.sum(axis=1, keepdims=True)

    # 7) Output agent_setting matrix: n_actions x (5+1)
    agent_setting = np.hstack([p_actions, costs[:, None]])
    return agent_setting
```
