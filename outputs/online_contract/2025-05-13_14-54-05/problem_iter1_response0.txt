```python
import numpy as np
import pandas as pd
from scipy.optimize import linprog
from sklearn.cluster import AgglomerativeClustering


def agent_solver_v2(v: np.ndarray, content: list[dict]) -> np.ndarray:
    """
    Infer a valid agent setting matrix from historical logs.

    Args:
        v: numpy array of shape (5,), principal's reward per outcome.
        content: list of dicts, each with keys:
            - 'Contract': list of 5 payments,
            - 'Principal Utility': float,
            - 'Agent Action': int (1 for accept, -1 for reject)

    Returns:
        agent_setting: np.ndarray of shape (n_actions, 6)
            First 5 cols: probability distribution over outcomes (sum=1)
            Last col: non-negative cost of action
    """

    m = len(v)  # number of outcomes (5)
    L = len(content)

    # Extract contracts, utilities, and actions arrays for convenience
    contracts = np.array([log['Contract'] for log in content])  # (L,5)
    p_utils = np.array([log['Principal Utility'] for log in content])  # (L,)
    agent_actions = np.array([log['Agent Action'] for log in content])  # (L,)

    # Separate accepted and rejected logs
    accepted_idx = np.where(agent_actions == 1)[0]
    rejected_idx = np.where(agent_actions == -1)[0]

    # --- Step 1: Infer agent outcome distributions p_i for accepted contracts
    # We solve for p_i: p_i @ w_i = principal utility + c_i (unknown cost),
    # but we don't know c_i yet. Instead, we try to find p_i that satisfy:
    #   p_i @ w_i >= 0 (agent accepts) and principal utility = p_i @ (v - w_i)
    # However, principal utility = v @ p_i - cost_i, cost_i = v @ p_i - principal util
    # We start by approximating p_i via LP that minimizes ||p_i @ w_i - principal utility||,
    # with p_i sum to 1, p_i >= 0

    def infer_p_for_accept(w: np.ndarray, util: float) -> np.ndarray | None:
        # We want to find p s.t
        #  sum p_j = 1
        #  p_j >= 0
        #  p @ (v - w) = util  => equality constraint
        #
        # Objective: minimize deviation between p@w and some expected value?
        # Instead, minimize ||p - uniform|| to get a meaningful distribution.
        c = np.ones(m) / m  # minimize distance to uniform (arbitrary)
        A_eq = np.vstack([np.ones(m), v - w])
        b_eq = np.array([1, util])
        bounds = [(0, 1)] * m
        res = linprog(c, A_eq=A_eq, b_eq=b_eq, bounds=bounds, method="highs")
        if res.success:
            return res.x
        else:
            return None

    inferred_ps = []
    valid_indices = []
    for i in accepted_idx:
        p_i = infer_p_for_accept(contracts[i], p_utils[i])
        if p_i is not None:
            inferred_ps.append(p_i)
            valid_indices.append(i)

    if len(inferred_ps) == 0:
        # fallback: use uniform distribution for all accepted logs
        inferred_ps = [np.ones(m) / m] * len(accepted_idx)
        valid_indices = accepted_idx.tolist()

    inferred_ps = np.array(inferred_ps)  # shape (n_valid_accepts, 5)

    # --- Step 2: Cluster inferred p's to discover distinct agent actions
    # Use Agglomerative clustering to adaptively find number of clusters
    max_clusters = min(10, len(inferred_ps))
    if max_clusters < 2:
        n_clusters = 1
    else:
        # Try clustering with different k and pick k that yields stable clusters
        # Here, we pick n_clusters = max_clusters for diversity
        n_clusters = max_clusters

    clustering = AgglomerativeClustering(n_clusters=n_clusters).fit(inferred_ps)
    labels = clustering.labels_  # cluster assignment for each inferred p

    # Compute cluster centers (mean of p vectors)
    p_centers = np.zeros((n_clusters, m))
    for k in range(n_clusters):
        cluster_ps = inferred_ps[labels == k]
        if cluster_ps.shape[0] > 0:
            center = cluster_ps.mean(axis=0)
            # normalize to sum to 1 to avoid numerical issues
            center = np.clip(center, 0, None)
            s = center.sum()
            if s > 0:
                center /= s
            else:
                center = np.ones(m) / m
            p_centers[k] = center
        else:
            p_centers[k] = np.ones(m) / m

    # --- Step 3: Estimate agent costs c_k for each cluster (action)

    # We know for accepted contracts i in cluster k:
    #   agent utility = p_k @ w_i - c_k >= 0 (IR)
    #   principal utility = v @ p_k - c_k = given in logs
    # So cost c_k = max over i in cluster k of (p_k @ w_i - agent utility_i)
    # But agent utility_i unknown; we only have principal utility_i = v @ p_k - c_k
    # => c_k = v @ p_k - principal utility_i
    # To be IR consistent, for all i in cluster k with accept:
    #   p_k @ w_i - c_k >= 0 => c_k <= p_k @ w_i
    # For rejection logs:
    #   agent utility < 0 => p_k @ w_i - c_k < 0 => c_k > p_k @ w_i

    # Compute c_k lower bound from accepted contracts:
    c_lower_bounds = np.zeros(n_clusters)
    for k in range(n_clusters):
        idxs = [valid_indices[j] for j in range(len(valid_indices)) if labels[j] == k]
        if len(idxs) == 0:
            c_lower_bounds[k] = 0.0
            continue
        vals = []
        for i_ in idxs:
            w_i = contracts[i_]
            principal_util_i = p_utils[i_]
            # cost c_k = v@p_k - principal_util_i
            c_i = v @ p_centers[k] - principal_util_i
            # IR: c_k <= p_k @ w_i (agent accepts)
            if c_i <= p_centers[k] @ w_i + 1e-9:
                vals.append(c_i)
        c_lower_bounds[k] = max(vals) if vals else 0.0

    # Compute c_k upper bound from rejected contracts (if any)
    c_upper_bounds = np.full(n_clusters, np.inf)
    if len(rejected_idx) > 0:
        for k in range(n_clusters):
            # For all rejected contracts:
            p_w_rej = contracts[rejected_idx] @ p_centers[k]
            # agent utility < 0 => c_k > p_k @ w_i for all rejected i
            c_upper_bounds[k] = min(p_w_rej) - 1e-8  # strict inequality

    # --- Step 4: Determine feasible costs c_k satisfying:
    # c_lower_bounds[k] <= c_k <= c_upper_bounds[k], c_k >= 0

    c_final = np.zeros(n_clusters)
    for k in range(n_clusters):
        lb = max(c_lower_bounds[k], 0)
        ub = c_upper_bounds[k]
        if lb <= ub:
            # feasible, pick midpoint for stability
            if np.isinf(ub):
                c_final[k] = lb
            else:
                c_final[k] = 0.5 * (lb + ub)
        else:
            # infeasible, fallback to lb (IR-consistent)
            c_final[k] = lb

    # --- Step 5: Check IC constraints between actions:
    # Agent prefers chosen action over others, i.e. for all a,b:
    # p_a @ w_i - c_a >= p_b @ w_i - c_b for accepted contract i assigned to a
    # We assign each accepted contract to closest cluster by p_k @ w_i - c_k

    assigns = -np.ones(L, dtype=int)
    for i in accepted_idx:
        w_i = contracts[i]
        utilities = p_centers @ w_i - c_final
        assigns[i] = int(np.argmax(utilities))

    # Verify IC: for each accepted contract i assigned to action a,
    # check if for all b, p_a @ w_i - c_a >= p_b @ w_i - c_b
    # If violated, increase c_b to enforce IC, but in practice this may be complex.
    # Here, we trust clustering + cost selection to yield approximate IC.

    # --- Step 6: Format agent setting matrix
    agent_setting = np.hstack([p_centers, c_final.reshape(-1, 1)])
    return agent_setting
```
