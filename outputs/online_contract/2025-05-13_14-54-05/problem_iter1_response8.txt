```python
import numpy as np
from scipy.optimize import linprog
from sklearn.cluster import DBSCAN


def agent_solver(v: np.ndarray, content: list[dict]) -> np.ndarray:
    """
    Infer a valid agent setting (actions: outcome distributions + cost) from historical logs.

    Args:
        v (np.ndarray): Principal's reward vector for 5 outcomes, shape (5,)
        content (list of dict): List of logs, each with keys:
            - 'Contract' (list or np.ndarray): payment vector length 5
            - 'Principal Utility' (float)
            - 'Agent Action' (int): 1 for accept, -1 for reject

    Returns:
        np.ndarray: n x 6 matrix: first 5 cols probabilities summing to 1, last col cost >=0
    """
    m = v.size
    logs = content

    # Extract contracts and agent actions
    contracts = np.array([np.array(log['Contract']) for log in logs])  # shape (L,5)
    actions = np.array([log['Agent Action'] for log in logs])          # shape (L,)
    principal_utilities = np.array([log['Principal Utility'] for log in logs])  # (L,)

    L = len(logs)

    # Step 1: From accepted contracts, estimate expected outcome distributions p_i
    # We have: Agent expected utility = p_i @ w - cost_i >= 0
    # and Principal utility = p_i@(v - w)
    # Since cost_i = p_i @ w - u_agent >= 0, but unknown u_agent,
    # We try to find p_i s.t. p_i sums to 1, p_i >=0, and p_i @ w = u_agent + cost_i
    # We approximate p_i by solving LP that fits observed principal utility and acceptance

    # We first solve for p_i for accepted contracts by minimizing ||p_i - p_ref|| to get feasible p_i
    # We choose p_ref = uniform distribution as a prior.

    p_candidates = []
    accept_indices = np.where(actions == 1)[0]
    reject_indices = np.where(actions == -1)[0]

    for i in accept_indices:
        w = contracts[i]
        u_principal = principal_utilities[i]
        # We want to find p: sum p=1, p>=0, and p@(v - w) = u_principal
        # Solve LP: minimize 0 s.t constraints

        A_eq = np.vstack([np.ones(m), v - w])
        b_eq = np.array([1.0, u_principal])
        bounds = [(0, 1)] * m

        # Objective: zero vector (just feasibility)
        c = np.zeros(m)
        res = linprog(c, A_eq=A_eq, b_eq=b_eq, bounds=bounds, method='highs')
        if res.success:
            p_candidates.append(res.x)
        else:
            # fallback: project uniform onto simplex ignoring second constraint
            p_candidates.append(np.ones(m) / m)

    if len(p_candidates) == 0:
        # No accepted contracts, fallback to trivial single action with uniform p and zero cost
        p = np.ones(m) / m
        cost = 0.
        return np.hstack([p, cost])[np.newaxis, :]

    p_candidates = np.array(p_candidates)

    # Step 2: Cluster p_candidates to identify distinct agent actions
    # Use DBSCAN to adaptively find clusters; eps and min_samples are tuned heuristically
    clustering = DBSCAN(eps=0.1, min_samples=2).fit(p_candidates)
    labels = clustering.labels_
    unique_labels = set(labels)
    if -1 in unique_labels:  # noise points, assign them each as own cluster
        noise_pts = np.where(labels == -1)[0]
        max_label = max(unique_labels)
        for i, nidx in enumerate(noise_pts):
            labels[nidx] = max_label + 1 + i
        unique_labels = set(labels)

    n_actions = len(unique_labels)
    agent_p = np.zeros((n_actions, m))
    agent_cost = np.zeros(n_actions)

    # Step 3: For each cluster (action), estimate outcome distribution as mean of p's in cluster
    # and infer cost as minimum cost making all accepts in that cluster IR and all rejects IC

    # Build index list per cluster
    cluster_indices = {label: np.where(labels == label)[0] for label in unique_labels}

    # Assign each accepted contract to a cluster (action) by closest p candidate
    # Also assign rejects to closest cluster by max agent expected utility p@w - cost < 0

    # For rejections, we will use these actions to check IR/IC constraints after cost assignment

    # Step 4: Infer cost per action:
    # For each action a:
    # For each accepted contract assigned to a:
    #    cost_a <= p_a @ w (agent utility >= 0)
    # For each rejected contract:
    #    cost_a > p_a @ w (agent utility < 0)
    # Cost must be >= 0.

    # To satisfy all IR and IC constraints simultaneously, solve linear inequalities on costs

    # First compute mean p per cluster:
    for a, label in enumerate(sorted(unique_labels)):
        idxs = cluster_indices[label]
        ps_in_cluster = p_candidates[idxs]
        p_mean = ps_in_cluster.mean(axis=0)
        # project p_mean to simplex in case of minor numerical errors
        p_mean = np.maximum(p_mean, 0)
        p_mean /= p_mean.sum()
        agent_p[a] = p_mean

    # Build constraints for costs: variables c_a >=0
    # For accepted contracts: cost_a <= p_a@w
    # For rejected contracts and all actions: cost_a > p_a@w

    # Variables: c = (c_0,...,c_(n_actions-1))

    # Inequalities:
    # For accept contract i assigned to action a:
    #    c_a <= p_a @ w_i  ->  c_a - s_i <= 0   where s_i = p_a @ w_i
    # For reject contract j:
    #    c_a > p_a @ w_j   ->  c_a - s_j > 0   for all a

    # So to be safe, we require for rejects:
    #    c_a >= s_j + eps for small eps>0

    # We formulate linprog to minimize sum c_a (arbitrary) subject to constraints

    eps = 1e-6

    # Prepare constraints matrix and bounds
    # Number of variables: n_actions
    # For accept constraints: one per accepted contract
    # For reject constraints: n_actions per rejected contract

    A_ub = []
    b_ub = []
    for i, idx in enumerate(accept_indices):
        w = contracts[idx]
        # find closest cluster a to p_candidates[i]
        # use p_candidates[i] because accept_indices maps to p_candidates directly
        # but i is index in accept_indices, p_candidates[i]
        p_i = p_candidates[i]
        # find closest agent_p row by l2 norm:
        distances = np.linalg.norm(agent_p - p_i, axis=1)
        a = np.argmin(distances)
        s = agent_p[a] @ w
        # c_a - s <= 0 -> put in form sum_j A_ub[i,j]*c_j <= b_ub[i]
        row = np.zeros(n_actions)
        row[a] = 1
        A_ub.append(row)
        b_ub.append(s)

    # For rejects:
    # For each rejected contract j and each action a:
    # c_a >= p_a @ w_j + eps  =>  -c_a <= - (p_a @ w_j + eps)
    for idx in reject_indices:
        w = contracts[idx]
        for a in range(n_actions):
            s = agent_p[a] @ w + eps
            row = np.zeros(n_actions)
            row[a] = -1
            A_ub.append(row)
            b_ub.append(-s)

    A_ub = np.array(A_ub) if A_ub else None
    b_ub = np.array(b_ub) if b_ub else None

    # Costs >= 0
    bounds = [(0, None)] * n_actions

    # Objective: minimize sum of costs (arbitrary)
    c_obj = np.ones(n_actions)

    res = linprog(c=c_obj, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')

    if not res.success:
        # fallback: set cost to max(0, max rejected p_a@w) or 0
        cost = np.zeros(n_actions)
        if reject_indices.size > 0:
            for a in range(n_actions):
                max_rej = max((agent_p[a] @ contracts[idx]) for idx in reject_indices)
                cost[a] = max(max_rej, 0)
        else:
            cost = np.zeros(n_actions)
    else:
        cost = res.x

    # Step 5: Return agent setting (p_a, cost_a)
    agent_setting = np.hstack([agent_p, cost[:, None]])
    return agent_setting
```
