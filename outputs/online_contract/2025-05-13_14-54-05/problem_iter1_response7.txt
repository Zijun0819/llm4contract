```python
import numpy as np
import pandas as pd
from scipy.optimize import linprog
from sklearn.cluster import AgglomerativeClustering

def agent_solver(v: np.ndarray, content: pd.DataFrame) -> np.ndarray:
    """
    Infer a valid agent setting (actions as outcome distributions + cost)
    consistent with historical logs of contracts, principal utility, and agent actions.

    Parameters:
    - v: 1D np.ndarray of length 5, principal's reward vector for 5 outcomes.
    - content: pd.DataFrame with columns:
        'Contract' (list of 5 floats),
        'Principal Utility' (float),
        'Agent Action' (1 for accept, -1 for reject)

    Returns:
    - agent_setting: np.ndarray shape (n_actions, 6),
        first 5 cols: action outcome probabilities (sum to 1),
        last col: action cost (non-negative).
    """

    # Extract data arrays
    contracts = np.vstack(content['Contract'].values)  # shape (L, 5)
    princ_utils = content['Principal Utility'].values  # shape (L,)
    agent_actions = content['Agent Action'].values      # shape (L,)
    L, m = contracts.shape

    # Separate accepted and rejected logs
    accepted_idx = np.where(agent_actions == 1)[0]
    rejected_idx = np.where(agent_actions == -1)[0]

    # We want to find a set of n_actions agent strategies (p, c)
    # such that for each accepted contract i: exists action a with
    #   U_agent(a, contract_i) = p_a.dot(contract_i) - c_a >= 0 (IR)
    #   principal utility matches: (p_a.dot(v) - contract_i.dot(p_a)) = principal_util_i (approx)
    # for each rejected contract j: for all actions a,
    #   p_a.dot(contract_j) - c_a < 0 (reject IR)

    # Step 1: Infer candidate outcome distributions p_a for accepted logs by solving LPs:

    # The system is underdetermined, but we try to find for each accepted log i an outcome distribution p_i 
    # that explains principal utility approximately:
    # principal utility = p_i.dot(v) - contract_i.dot(p_i)
    # => p_i.dot(v + contract_i) = principal utility_i + contract_i.dot(p_i) + p_i.dot(v)
    # Actually better to solve for p_i using constraints:
    # sum p_i = 1, p_i >= 0
    # And objective can be to minimize absolute difference between predicted principal utility and given

    # Instead, solve min_p || p.dot(v) - contract_i.dot(p) - principal_util_i || s.t. p in simplex
    # This is nonlinear in p. So approximate by linearizing:

    # We'll solve for each accepted contract i:
    # minimize |p dot (v+contract_i) - principal_util_i - contract_i.dot(p)| is complicated.
    # Let's try to solve a LP to find p_i s.t:
    #   sum p_i = 1,
    #   p_i >= 0,
    #   p_i.dot(contract_i) - c = u_agent >= 0 (unknown c)
    # We'll fix c later.

    # Instead, here we do a simpler heuristic:
    # For each accepted log:
    #   Use linear programming to find p_i satisfying sum p_i=1, p_i>=0,
    #   and p_i.dot(contract_i) >= 0 (agent accepted)
    #   and principal utility approx = p_i.dot(v) - p_i.dot(contract_i)
    #   We minimize absolute error in principal utility.
    # We'll solve:
    #   min e
    #   s.t sum p_i = 1, p_i >=0
    #       -e <= p_i.dot(v) - p_i.dot(contract_i) - principal_util_i <= e
    #       p_i.dot(contract_i) >= 0

    candidate_p = []
    eps = 1e-6
    for i in accepted_idx:
        c_i = contracts[i]
        pu_i = princ_utils[i]

        # Variables: p vector length m, error scalar e
        # We'll transform to LP form: minimize e s.t. constraints

        # Objective: minimize e
        # Variables order: [p_0,...,p_4, e]
        c_obj = np.zeros(m + 1)
        c_obj[-1] = 1  # minimize e

        # Constraints:
        # sum p_i = 1 --> A_eq
        A_eq = np.zeros((1, m + 1))
        A_eq[0, :m] = 1
        b_eq = np.array([1.0])

        # Inequalities:
        # -e <= p.dot(v) - p.dot(c_i) - pu_i <= e
        # => p.dot(v - c_i) - pu_i <= e
        # => -p.dot(v - c_i) + pu_i <= e
        # This gives two inequalities:
        # p.dot(v - c_i) - e <= pu_i
        # -p.dot(v - c_i) - e <= -pu_i

        A_ub = np.zeros((2, m + 1))
        A_ub[0, :m] = v - c_i
        A_ub[0, -1] = -1
        b_ub = np.array([pu_i])

        A_ub[1, :m] = - (v - c_i)
        A_ub[1, -1] = -1
        b_ub = np.append(b_ub, [-pu_i])

        # p.dot(c_i) >= 0 => -p.dot(c_i) <= 0
        A_ub = np.vstack([A_ub, np.append(-c_i, 0).reshape(1, m + 1)])
        b_ub = np.append(b_ub, [0])

        # Bounds for p_i in [0,1], e >= 0
        bounds = [(0, 1)] * m + [(0, None)]

        res = linprog(c=c_obj, A_ub=A_ub, b_ub=b_ub, A_eq=A_eq, b_eq=b_eq, bounds=bounds, method='highs')

        if res.success and res.x[-1] < 1e-3:  # small error, accept p
            p_i = res.x[:m]
            candidate_p.append(p_i)
        else:
            # fallback: uniform distribution (likely poor fit)
            candidate_p.append(np.ones(m) / m)

    candidate_p = np.array(candidate_p)

    # Step 2: Cluster candidate p to get prototype actions
    # Adaptive number of clusters: at least 2, at most min(10, #accepted)
    n_clusters = min(max(2, len(candidate_p) // 5), 10)
    if len(candidate_p) < n_clusters:
        n_clusters = len(candidate_p)

    if n_clusters < 1:
        # No accepted contracts; default trivial action
        p_default = np.ones(m) / m
        c_default = 0.0
        return np.hstack([p_default.reshape(1, -1), np.array([[c_default]])])

    # Use AgglomerativeClustering for stability on small data
    clusterer = AgglomerativeClustering(n_clusters=n_clusters)
    labels = clusterer.fit_predict(candidate_p)
    actions_p = np.zeros((n_clusters, m))
    for k in range(n_clusters):
        cluster_points = candidate_p[labels == k]
        # average distribution in cluster, re-normalize
        mean_p = cluster_points.mean(axis=0)
        mean_p = np.clip(mean_p, 0, None)
        if mean_p.sum() > 0:
            mean_p /= mean_p.sum()
        else:
            mean_p = np.ones(m) / m
        actions_p[k] = mean_p

    # Step 3: Estimate costs c for each action
    # For each action k, find minimal cost c_k that satisfies IR for all assigned accepted contracts:
    # p_k.dot(contract_i) - c_k >= 0 => c_k <= p_k.dot(contract_i)
    # Also must satisfy rejection constraints:
    # For all rejected contracts j: for all k,
    # p_k.dot(contract_j) - c_k < 0 => c_k > p_k.dot(contract_j)

    # Assign each accepted contract to best fitting action by smallest absolute error on p.dot(contract)
    assigned_actions = np.zeros(len(accepted_idx), dtype=int)
    for i_idx, i in enumerate(accepted_idx):
        c_i = contracts[i]
        # agent utility approx = max_a p_a.dot(c_i) - c_a (unknown c_a)
        # Without c_a, assign by max p.dot(c_i)
        dots = actions_p @ c_i
        assigned_actions[i_idx] = np.argmax(dots)

    # For each action:
    costs = np.zeros(n_clusters)

    # Compute minimal cost c_k to satisfy IR for assigned accepted logs:
    # cost <= min_{i in assigned_k} p_k.dot(contract_i)
    for k in range(n_clusters):
        assigned_idx_k = np.where(assigned_actions == k)[0]
        if len(assigned_idx_k) > 0:
            vals = []
            for ai in assigned_idx_k:
                i = accepted_idx[ai]
                val = actions_p[k] @ contracts[i]
                vals.append(val)
            costs[k] = min(vals)
        else:
            costs[k] = 0.0

    # Now check rejection constraints:
    # For each rejected contract j, ensure for all k:
    # p_k.dot(contract_j) - c_k < 0 => c_k > p_k.dot(contract_j)
    # So for all rejected contracts and all k:
    # costs[k] > max_j p_k.dot(contract_j)

    if len(rejected_idx) > 0:
        rej_contracts = contracts[rejected_idx]
        for k in range(n_clusters):
            max_rej = np.max(rej_contracts @ actions_p[k])
            if costs[k] <= max_rej:
                # Increase cost slightly above max_rej to maintain rejection IR
                costs[k] = max_rej + 1e-6

    # Ensure costs non-negative
    costs = np.clip(costs, 0, None)

    # Finally, output agent setting matrix: n_clusters x (5+1)
    agent_setting = np.hstack([actions_p, costs[:, None]])

    return agent_setting
```
