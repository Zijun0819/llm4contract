```python
import numpy as np
from scipy.optimize import linprog
from sklearn.cluster import KMeans

def agent_solver_v2(v: np.ndarray, content: list[dict]) -> np.ndarray:
    """
    Infer a valid agent setting (actions' outcome distributions and costs)
    consistent with historical contracts, principal utilities, and agent acceptance/rejection.

    Args:
        v (np.ndarray): Principal's reward vector of length 5.
        content (list of dict): Historical interaction logs with keys:
            - 'Contract': list of 5 payments
            - 'Principal Utility': float
            - 'Agent Action': int (1 for accept, -1 for reject)

    Returns:
        np.ndarray: n x 6 matrix, each row:
            [p1, p2, p3, p4, p5, cost], with p probabilities sum to 1,
            cost >= 0, explaining all historical data.
    """
    m = v.shape[0]  # number of outcomes (5)
    L = len(content)

    contracts = np.array([log['Contract'] for log in content])  # L x 5
    principal_utils = np.array([log['Principal Utility'] for log in content])  # L
    agent_actions = np.array([log['Agent Action'] for log in content])  # L

    accept_idx = np.where(agent_actions == 1)[0]
    reject_idx = np.where(agent_actions == -1)[0]

    # If no accepted contracts, fallback to single uniform action with zero cost
    if len(accept_idx) == 0:
        p_uniform = np.ones(m) / m
        cost_zero = 0.0
        return np.hstack([p_uniform, cost_zero])[np.newaxis, :]

    accepted_contracts = contracts[accept_idx]  # n_accept x 5
    accepted_principal_utils = principal_utils[accept_idx]

    # Adaptive number of clusters (actions)
    n_actions_max = min(10, max(2, len(accept_idx) // 10))

    # Cluster accepted contracts in contract payment space to identify actions
    kmeans = KMeans(n_clusters=n_actions_max, random_state=42, n_init=15).fit(accepted_contracts)

    p_candidates = np.zeros((n_actions_max, m))

    for cluster_id in range(n_actions_max):
        members_mask = (kmeans.labels_ == cluster_id)
        members_idx = accept_idx[members_mask]
        if len(members_idx) == 0:
            # No members in cluster, fallback uniform
            p_candidates[cluster_id] = np.ones(m) / m
            continue

        member_contracts = contracts[members_idx]
        member_principal_utils = principal_utils[members_idx]

        w_avg = np.mean(member_contracts, axis=0)
        u_avg = np.mean(member_principal_utils)

        # We want p >=0, sum p=1, s.t. p.(v - w_avg) approx u_avg
        # Solve two LPs to minimize absolute deviation by enforcing one-sided constraints

        def linprog_p(target, sense):
            # sense=1: p.(v - w_avg) >= target
            # sense=-1: p.(v - w_avg) <= target
            A_eq = np.ones((1, m))
            b_eq = np.array([1])
            if sense == 1:
                A_ub = - (v - w_avg).reshape(1, -1)
                b_ub = np.array([-target])
            else:
                A_ub = (v - w_avg).reshape(1, -1)
                b_ub = np.array([target])
            bounds = [(0, 1)] * m
            res = linprog(c=np.zeros(m), A_eq=A_eq, b_eq=b_eq, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')
            return res

        res_ge = linprog_p(u_avg, 1)
        res_le = linprog_p(u_avg, -1)

        p_candidate = None
        error_ge = np.inf
        error_le = np.inf
        if res_ge.success:
            val = res_ge.x @ (v - w_avg)
            error_ge = abs(val - u_avg)
        if res_le.success:
            val = res_le.x @ (v - w_avg)
            error_le = abs(val - u_avg)

        if error_ge < error_le and res_ge.success:
            p_candidate = res_ge.x
        elif res_le.success:
            p_candidate = res_le.x

        if p_candidate is None:
            p_candidate = np.ones(m) / m

        # Numerical cleanup: clip and normalize
        p_candidate = np.clip(p_candidate, 0, None)
        sum_p = p_candidate.sum()
        if sum_p > 0:
            p_candidate /= sum_p
        else:
            p_candidate = np.ones(m) / m

        p_candidates[cluster_id] = p_candidate

    # Assign accepted logs to nearest p candidate by contract payment space distance
    assigned_actions = -np.ones(L, dtype=int)
    for i in accept_idx:
        w = contracts[i]
        # Distance in contract payment space to cluster centers (kmeans.cluster_centers_)
        # Use cluster centers as proxy for assignment
        dists = np.linalg.norm(kmeans.cluster_centers_ - w, axis=1)
        assigned_actions[i] = int(np.argmin(dists))

    # Initialize costs: for each action, minimal cost consistent with IR (agent utility >= 0)
    costs = np.zeros(n_actions_max)
    for a in range(n_actions_max):
        idxs = np.where(assigned_actions == a)[0]
        if len(idxs) > 0:
            costs[a] = min((p_candidates[a] @ contracts[i]) for i in idxs)
        else:
            costs[a] = 0.0

    # Adjust costs to satisfy rejection constraints:
    # For each rejected log, agent utility < 0 for all actions => cost > p.w
    if len(reject_idx) > 0:
        for a in range(n_actions_max):
            max_p_w_reject = max(p_candidates[a] @ contracts[i] for i in reject_idx)
            if max_p_w_reject >= costs[a]:
                costs[a] = max_p_w_reject + 1e-6

    # Iterative correction to enforce IR and IC constraints strictly
    # IR: For accepted i assigned a, p_a.w_i - cost_a >= 0
    # IC: For accepted i assigned a, p_a.w_i - cost_a >= p_b.w_i - cost_b for all b != a
    max_iters = 10
    tol = 1e-8
    for _ in range(max_iters):
        violated = False
        for i in accept_idx:
            a = assigned_actions[i]
            w_i = contracts[i]
            u_i_a = p_candidates[a] @ w_i - costs[a]

            # IR check
            if u_i_a < -tol:
                # Decrease cost[a] to fix IR violation, but cost >=0
                costs[a] = max(costs[a] + u_i_a, 0)
                violated = True

            # IC check
            for b in range(n_actions_max):
                if b == a:
                    continue
                u_i_b = p_candidates[b] @ w_i - costs[b]
                if u_i_b > u_i_a + tol:
                    diff = u_i_b - u_i_a
                    # Adjust costs to reduce violation:
                    # Increase cost[b], decrease cost[a], keep costs >=0
                    costs[a] = max(costs[a] - diff / 2, 0)
                    costs[b] = costs[b] + diff / 2
                    violated = True
        if not violated:
            break

    # Final cleanup: ensure valid distributions and nonnegative costs
    p_candidates = np.clip(p_candidates, 0, 1)
    sums = p_candidates.sum(axis=1, keepdims=True)
    sums[sums == 0] = 1.0
    p_candidates /= sums
    costs = np.clip(costs, 0, None)

    agent_setting = np.hstack([p_candidates, costs[:, np.newaxis]])
    return agent_setting
```
