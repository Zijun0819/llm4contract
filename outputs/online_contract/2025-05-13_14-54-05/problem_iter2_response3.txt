```python
import numpy as np
import pandas as pd
from sklearn.cluster import AgglomerativeClustering
from scipy.optimize import linprog

def agent_solver_v2(v: np.ndarray, content: list[dict]) -> np.ndarray:
    """
    Infer a valid agent setting (actions with outcome distributions and costs) that explains all historical logs.

    Args:
        v: Principal's value vector for 5 outcomes, shape (5,).
        content: List of dict logs, each with keys:
            - 'Contract': 5-dim payment vector,
            - 'Principal Utility': scalar,
            - 'Agent Action': 1 (accept) or -1 (reject).

    Returns:
        agent_setting: n_actions x 6 matrix:
            - first 5 cols: probabilities over outcomes (sum to 1),
            - last col: cost ≥ 0.
    """
    m = len(v)
    logs = pd.DataFrame(content)
    contracts = np.stack(logs['Contract'].values)  # shape (L, 5)
    actions = logs['Agent Action'].values          # shape (L,)
    util_principal = logs['Principal Utility'].values  # shape (L,)

    accepted_idx = np.where(actions == 1)[0]
    rejected_idx = np.where(actions == -1)[0]

    # If no accepted logs, return trivial uniform distribution with zero cost
    if len(accepted_idx) == 0:
        p0 = np.ones((1, m)) / m
        c0 = np.array([0.0])
        return np.hstack([p0, c0[:, None]])

    accepted_contracts = contracts[accepted_idx]  # (num_accept, 5)
    accepted_utils = util_principal[accepted_idx]  # (num_accept,)

    # Outcome-aware features for clustering: combine contract and principal utility info
    # Feature: contract payments concatenated with principal utility (scaled)
    util_scaled = (accepted_utils - accepted_utils.min()) / (accepted_utils.ptp() + 1e-12)
    features = np.hstack([accepted_contracts, util_scaled[:, None]])

    # Adaptive clustering to find natural number of agent actions
    clusterer = AgglomerativeClustering(n_clusters=None, distance_threshold=0.5, linkage='ward')
    labels = clusterer.fit_predict(features)
    n_actions = labels.max() + 1

    p_estimates = np.zeros((n_actions, m))
    costs = np.zeros(n_actions)

    # For each cluster (agent action), infer p and cost by solving a small QP/LP approximation
    # Heuristic: approximate p as weighted average of normalized contracts in cluster
    # Then estimate cost as minimal expected agent utility over cluster contracts

    for a in range(n_actions):
        cluster_idx = accepted_idx[labels == a]
        if len(cluster_idx) == 0:
            # No data for this cluster, fallback uniform and zero cost
            p_estimates[a] = np.ones(m) / m
            costs[a] = 0.0
            continue

        cont_cluster = contracts[cluster_idx]  # (n_a, 5)
        util_cluster = util_principal[cluster_idx]  # (n_a,)

        # Normalize contracts row-wise to sum to 1 (proxy for outcome distribution)
        cont_norm = cont_cluster / (cont_cluster.sum(axis=1, keepdims=True) + 1e-12)

        # Weighted average by principal utilities shifted to positive (to emphasize better contracts)
        weights = util_cluster - util_cluster.min() + 1e-3
        weights /= weights.sum()
        p_a = (weights[:, None] * cont_norm).sum(axis=0)

        # Project onto simplex to ensure valid probability vector
        p_a = np.maximum(p_a, 0)
        p_a_sum = p_a.sum()
        if p_a_sum < 1e-12:
            p_a = np.ones(m) / m
        else:
            p_a /= p_a_sum

        # Estimate cost c_a from IR constraints:
        # agent utility = p_a @ w_i - c_a ≥ 0  =>  c_a ≤ min_i p_a @ w_i
        exp_utils = cont_cluster @ p_a
        c_a = exp_utils.min()
        c_a = max(0.0, c_a)

        p_estimates[a] = p_a
        costs[a] = c_a

    # Assign accepted logs to best action by agent utility (p_a @ w_i - c_a)
    assigned_actions = np.full(len(actions), -1, dtype=int)
    for i in range(len(actions)):
        w_i = contracts[i]
        utilities = p_estimates @ w_i - costs
        if actions[i] == 1:
            # Accepted: assign to action with max utility (≥0)
            if utilities.max() < 0:
                # Infeasible, relax cost of best action to allow acceptance
                a_best = utilities.argmax()
                costs[a_best] = min(costs[a_best], (p_estimates[a_best] @ w_i))
                utilities = p_estimates @ w_i - costs
            assigned_actions[i] = utilities.argmax()
        else:
            # Rejected: no assignment needed, keep -1
            assigned_actions[i] = -1

    # Build constraints for costs to enforce IR, IC, and rejection strictly

    # Variables: costs for each action (length n_actions)
    # Constraints:
    # IR: For accepted logs i assigned to a_i: c_a_i ≤ p_a_i @ w_i
    # IC: For accepted logs i assigned to a_i and any other action b != a_i:
    #     c_b - c_a_i ≥ (p_b @ w_i) - (p_a_i @ w_i)
    # Rejection: For rejected logs i and all actions a:
    #     c_a ≥ p_a @ w_i + eps

    eps = 1e-5
    n = n_actions
    L = len(contracts)

    A_ub = []
    b_ub = []

    # IR constraints: c_a ≤ p_a @ w_i  →  c_a - p_a @ w_i ≤ 0
    for i in accepted_idx:
        a_i = assigned_actions[i]
        if a_i == -1:
            continue  # safety check
        w_i = contracts[i]
        row = np.zeros(n)
        row[a_i] = 1.0
        A_ub.append(row)
        b_ub.append(p_estimates[a_i] @ w_i)

    # IC constraints: c_b - c_a_i ≥ (p_b @ w_i) - (p_a_i @ w_i)
    # → -c_b + c_a_i ≤ -((p_b @ w_i) - (p_a_i @ w_i))
    for i in accepted_idx:
        a_i = assigned_actions[i]
        if a_i == -1:
            continue
        w_i = contracts[i]
        p_a_i = p_estimates[a_i]
        for b in range(n):
            if b == a_i:
                continue
            p_b = p_estimates[b]
            row = np.zeros(n)
            row[b] = -1.0
            row[a_i] = 1.0
            rhs = -((p_b @ w_i) - (p_a_i @ w_i))
            A_ub.append(row)
            b_ub.append(rhs)

    # Rejection constraints: c_a ≥ p_a @ w_i + eps
    # → -c_a ≤ -(p_a @ w_i + eps)
    for i in rejected_idx:
        w_i = contracts[i]
        for a in range(n):
            row = np.zeros(n)
            row[a] = -1.0
            A_ub.append(row)
            b_ub.append(-(p_estimates[a] @ w_i + eps))

    A_ub = np.array(A_ub) if A_ub else None
    b_ub = np.array(b_ub) if b_ub else None

    # Objective: minimize sum of costs with tiny regularization to avoid trivial large costs
    c_obj = np.ones(n) * 1e-6

    bounds = [(0, None) for _ in range(n)]

    res = linprog(c=c_obj, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')

    if res.success:
        costs = res.x
    else:
        # LP failed: fallback to previous costs clipped at zero
        costs = np.clip(costs, 0, None)

    # Normalize p_estimates again to ensure valid distributions
    p_estimates = np.clip(p_estimates, 0, None)
    p_sums = p_estimates.sum(axis=1, keepdims=True)
    zero_mask = p_sums < 1e-12
    p_estimates[zero_mask.flatten()] = np.ones(m) / m
    p_estimates[~zero_mask.flatten()] /= p_sums[~zero_mask.flatten()]

    costs = np.clip(costs, 0, None)

    agent_setting = np.hstack([p_estimates, costs[:, None]])
    return agent_setting
```
