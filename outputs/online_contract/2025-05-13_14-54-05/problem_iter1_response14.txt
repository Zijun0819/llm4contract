```python
import numpy as np
import pandas as pd
from scipy.optimize import linprog
from sklearn.cluster import AgglomerativeClustering


def agent_solver_v2(v: np.ndarray, content: pd.DataFrame) -> np.ndarray:
    """
    Infer a valid agent setting matrix (actions x [5 outcome probs + 1 cost]) that
    explains all historical contracts and agent decisions under IR and IC constraints.

    Args:
        v: np.ndarray, shape (5,), principal's reward vector for 5 outcomes.
        content: pd.DataFrame with columns ['Contract', 'Principal Utility', 'Agent Action'].
                 'Contract' is list-like of length 5 payment vector,
                 'Principal Utility' is float,
                 'Agent Action' is 1 (accept) or -1 (reject).

    Returns:
        agent_setting: np.ndarray, shape (n_actions, 6).
          Each row: [p1, p2, p3, p4, p5, cost]
          where sum(p_i) =1, p_i >=0, cost >=0
    """
    m = v.shape[0]
    logs = content.reset_index(drop=True)
    L = len(logs)

    # Extract arrays for faster processing
    contracts = np.array([np.array(c) for c in logs['Contract']])  # shape (L,5)
    principal_utils = np.array(logs['Principal Utility'])          # shape (L,)
    agent_actions = np.array(logs['Agent Action'])                 # shape (L,)

    # Step 1: Separate accepted and rejected contract indices
    accept_idx = np.where(agent_actions == 1)[0]
    reject_idx = np.where(agent_actions == -1)[0]

    # If no accepted logs, fallback trivial setting
    if len(accept_idx) == 0:
        # One action: uniform outcome and zero cost
        uniform_p = np.ones(m) / m
        return np.hstack([uniform_p, np.array([0.0])]).reshape(1, m+1)

    # Step 2: Infer "empirical" outcome distributions p_i from accepted contracts.
    # For each accepted contract i, solve for p_i:
    # max sum_j p_j * w_j subject to sum p_j = 1, p>=0, and agent utility constraint holds
    # Here agent utility = p @ w - cost >=0, cost unknown.
    # We try to find a p_i that "justifies" acceptance with cost = p_i @ w - 0.
    # So the agent cost for action i is c_i = p_i @ w_i

    def infer_p_given_w(w):
        # Solve for p: max p @ w, s.t sum p=1, p>=0
        # p maximizing p @ w is putting all mass on max w_j, but must explain variability.
        # Instead, here we try to find p s.t p @ w = agent utility + cost unknown.
        # We relax and find p maximizing entropy subject to sum p=1, p>=0, and
        # p @ w close to principal utility + cost unknown.
        # For tractability, just use linear program: find p maximizing min p_j >=0, sum p=1, and close p @ w to principal utility.
        # We will pick p as the solution to min ||p - uniform|| s.t p @ w >= 0 (acceptance)
        c_obj = np.zeros(m)
        A_eq = [np.ones(m)]
        b_eq = [1]
        bounds = [(0, 1) for _ in range(m)]
        # We want p @ w >= epsilon, so model as inequality:
        # linprog doesn't allow >= so transform:
        # -p @ w <= -epsilon with epsilon=0 for acceptance boundary
        A_ub = [-w]
        b_ub = [0]
        res = linprog(c=c_obj, A_eq=A_eq, b_eq=b_eq, bounds=bounds,
                      A_ub=A_ub, b_ub=b_ub, method='highs')
        if res.success:
            return res.x
        else:
            # fallback uniform distribution
            return np.ones(m) / m

    p_candidates = np.array([infer_p_given_w(contracts[i]) for i in accept_idx])

    # Step 3: Cluster p_candidates to form distinct agent actions
    # Use AgglomerativeClustering with a distance threshold to adapt n_clusters
    # This finds a number of clusters automatically based on linkage distance
    cluster_model = AgglomerativeClustering(n_clusters=None, distance_threshold=0.05, linkage='ward')
    labels = cluster_model.fit_predict(p_candidates)

    n_actions = labels.max() + 1

    # Compute cluster centers as mean p in each cluster
    p_centers = np.vstack([
        p_candidates[labels == k].mean(axis=0) if np.any(labels == k) else np.ones(m)/m
        for k in range(n_actions)
    ])

    # Normalize p_centers just in case numerical issues
    p_centers /= p_centers.sum(axis=1, keepdims=True)
    p_centers = np.clip(p_centers, 0, 1)
    p_centers /= p_centers.sum(axis=1, keepdims=True)

    # Step 4: Estimate agent costs c for each action:
    # For each action k, agent cost c_k satisfies:
    # For accepted contracts assigned to k: p_k @ w_i - c_k >= 0 (IR)
    # => c_k <= min_i (p_k @ w_i) over i assigned to k
    # For rejected contracts: p_k @ w_j - c_k < 0 (IC)
    # => c_k > max_j (p_k @ w_j) over rejected contracts

    costs = np.zeros(n_actions)

    # Assign accepted contracts to clusters by closest p center in L1 norm
    assigned_accepts = -np.ones(len(accept_idx), dtype=int)
    for i, p_i in enumerate(p_candidates):
        dists = np.linalg.norm(p_centers - p_i, ord=1, axis=1)
        assigned_accepts[i] = np.argmin(dists)

    for k in range(n_actions):
        # Accepted contracts assigned to k
        idx_k = accept_idx[assigned_accepts == k]
        if len(idx_k) > 0:
            accepted_vals = np.dot(p_centers[k], contracts[idx_k].T)  # shape (len(idx_k),)
            c_ir_bound = accepted_vals.min()
        else:
            # No accepted contracts assigned => cost no less than zero
            c_ir_bound = 0.0

        # For rejected contracts, agent utility must be < 0
        if len(reject_idx) > 0:
            rej_vals = np.dot(p_centers[k], contracts[reject_idx].T)  # shape (len(reject_idx),)
            # Agent rejects => p_k @ w_j - c_k < 0 => c_k > max rej_vals
            c_ic_bound = rej_vals.max()
        else:
            c_ic_bound = -np.inf  # no rejection constraints

        # Combine bounds: cost must satisfy
        # c_k <= c_ir_bound (to keep accepted contracts IR)
        # c_k > c_ic_bound (to keep rejected contracts utility < 0)
        # If no feasible cost, relax slightly with epsilon tolerance

        if c_ir_bound > c_ic_bound + 1e-8:
            costs[k] = max(c_ic_bound + 1e-6, 0.0)
        else:
            # Conflict, fallback to midpoint or zero cost
            costs[k] = max((c_ir_bound + c_ic_bound) / 2, 0.0)

    # Step 5: Post-process: ensure costs non-negative, p normalized
    costs = np.clip(costs, 0, None)
    p_centers = np.clip(p_centers, 0, 1)
    p_centers /= p_centers.sum(axis=1, keepdims=True)

    agent_setting = np.hstack([p_centers, costs[:, None]])
    return agent_setting
```
