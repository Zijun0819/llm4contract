```python
import numpy as np
from scipy.optimize import linprog
from sklearn.cluster import DBSCAN

def agent_solver_v2(v: np.ndarray, content: list[dict]) -> np.ndarray:
    """
    Infer a valid agent setting matrix from historical logs with contracts, principal utilities,
    and agent actions. This version adaptively infers outcome distributions and costs by
    enforcing IR, IC, and rejection consistency constraints.

    Args:
        v (np.ndarray): Principal's reward vector of length 5.
        content (list of dict): Historical interaction logs with keys:
            - 'Contract': list of 5 payments
            - 'Principal Utility': float
            - 'Agent Action': int (1 for accept, -1 for reject)

    Returns:
        np.ndarray: n_actions x (5 + 1) matrix, each row: [p(outcomes), cost]
    """

    contracts = np.array([log['Contract'] for log in content])  # (L,5)
    principal_utils = np.array([log['Principal Utility'] for log in content])  # (L,)
    actions = np.array([log['Agent Action'] for log in content])  # (L,)
    L, m = contracts.shape

    accepted_idx = np.where(actions == 1)[0]
    rejected_idx = np.where(actions == -1)[0]

    # If no accepted logs, return trivial uniform distribution with zero cost
    if len(accepted_idx) == 0:
        uniform_p = np.ones(m) / m
        return np.hstack([uniform_p.reshape(1, -1), np.array([[0.0]])])

    # Step 1: For each accepted log, find a feasible p satisfying:
    # sum p = 1, p >= 0, and p@(v - w) = principal_utility
    candidate_ps = []
    accepted_contracts = contracts[accepted_idx]
    accepted_principal_utils = principal_utils[accepted_idx]

    for w, u in zip(accepted_contracts, accepted_principal_utils):
        A_eq = np.vstack([np.ones(m), v - w])
        b_eq = np.array([1.0, u])
        bounds = [(0, 1)] * m
        res = linprog(c=np.zeros(m), A_eq=A_eq, b_eq=b_eq, bounds=bounds, method='highs')

        if res.success:
            p = res.x
            # Clip small negative values to zero for numerical stability
            p = np.clip(p, 0, None)
            s = p.sum()
            if s > 0:
                p /= s
            else:
                p = np.ones(m) / m
            candidate_ps.append(p)
        else:
            # If no feasible p found, skip this log (will be handled by clustering/noise)
            continue

    if len(candidate_ps) == 0:
        # fallback uniform if no feasible p found
        uniform_p = np.ones(m) / m
        return np.hstack([uniform_p.reshape(1, -1), np.array([[0.0]])])

    candidate_ps = np.array(candidate_ps)

    # Step 2: Cluster candidate_ps to identify distinct agent actions using DBSCAN
    clustering = DBSCAN(eps=0.15, min_samples=3).fit(candidate_ps)
    labels = clustering.labels_
    unique_labels = set(labels)
    if -1 in unique_labels:
        unique_labels.remove(-1)  # remove noise label

    if len(unique_labels) == 0:
        # no clusters found, treat all as one cluster
        unique_labels = {0}
        labels = np.zeros(len(candidate_ps), dtype=int)

    cluster_centers = []
    for lbl in sorted(unique_labels):
        pts = candidate_ps[labels == lbl]
        center = pts.mean(axis=0)
        # Normalize center to valid distribution
        center = np.clip(center, 0, None)
        s = center.sum()
        if s > 0:
            center /= s
        else:
            center = np.ones(m) / m
        cluster_centers.append(center)
    cluster_centers = np.array(cluster_centers)
    n_actions = cluster_centers.shape[0]

    # Step 3: Assign accepted logs to clusters (actions)
    # accepted_idx corresponds to candidate_ps order
    assigned_actions = np.full(L, -1, dtype=int)
    accepted_label_list = list(sorted(unique_labels))
    for idx_in_candidate_ps, lbl in enumerate(labels):
        if lbl == -1:
            continue
        action_idx = accepted_label_list.index(lbl)
        assigned_actions[accepted_idx[idx_in_candidate_ps]] = action_idx

    # Step 4: Infer costs per action from accepted logs:
    # cost_a <= min_{i assigned to a} p_a @ w_i to keep agent utility >= 0
    costs = np.zeros(n_actions)
    for a in range(n_actions):
        idxs = np.where(assigned_actions == a)[0]
        if len(idxs) == 0:
            costs[a] = 0.0
            continue
        p_a = cluster_centers[a]
        accepted_contracts_a = contracts[idxs]
        upper_bounds = accepted_contracts_a @ p_a
        # cost must be <= min upper bound to satisfy IR for all assigned accepted logs
        costs[a] = max(0.0, upper_bounds.min())

    # Step 5: Ensure rejection consistency:
    # For each rejected contract w, agent utility < 0 for all actions:
    # p_a @ w - cost_a < 0 => cost_a > p_a @ w
    if len(rejected_idx) > 0:
        rejected_contracts = contracts[rejected_idx]
        for a in range(n_actions):
            p_a = cluster_centers[a]
            vals = rejected_contracts @ p_a
            max_rej_val = vals.max()
            if costs[a] <= max_rej_val:
                costs[a] = max_rej_val + 1e-6

    # Step 6: Enforce IC constraints for accepted logs:
    # For accepted log i assigned to action a:
    # p_a @ w_i - cost_a >= p_b @ w_i - cost_b for all b != a
    # If violated, adjust costs iteratively to fix violations (up to 15 iterations)
    max_iters = 15
    tol = 1e-9
    for _ in range(max_iters):
        violated = False
        for i in accepted_idx:
            a = assigned_actions[i]
            if a == -1:
                continue
            w_i = contracts[i]
            u_i_a = cluster_centers[a] @ w_i - costs[a]
            for b in range(n_actions):
                if b == a:
                    continue
                u_i_b = cluster_centers[b] @ w_i - costs[b]
                diff = u_i_b - u_i_a
                if diff > tol:
                    # Violation found: decrease cost[a], increase cost[b]
                    adjust = diff / 2
                    new_cost_a = max(costs[a] - adjust, 0)
                    new_cost_b = costs[b] + adjust
                    if new_cost_a != costs[a] or new_cost_b != costs[b]:
                        costs[a] = new_cost_a
                        costs[b] = new_cost_b
                        violated = True
        if not violated:
            break

    # Step 7: Enforce IR constraints strictly for accepted logs
    # p_a @ w_i - cost_a >= 0
    for _ in range(10):
        violated = False
        for i in accepted_idx:
            a = assigned_actions[i]
            if a == -1:
                continue
            w_i = contracts[i]
            u_i_a = cluster_centers[a] @ w_i - costs[a]
            if u_i_a < -tol:
                costs[a] = max(costs[a] + u_i_a, 0)
                violated = True
        if not violated:
            break

    # Step 8: Normalize cluster_centers again for safety (sum to 1, nonnegative)
    for a in range(n_actions):
        p = cluster_centers[a]
        p = np.clip(p, 0, None)
        s = p.sum()
        if s > 0:
            cluster_centers[a] = p / s
        else:
            cluster_centers[a] = np.ones(m) / m

    costs = np.clip(costs, 0, None)

    agent_setting = np.hstack([cluster_centers, costs.reshape(-1, 1)])
    return agent_setting
```
