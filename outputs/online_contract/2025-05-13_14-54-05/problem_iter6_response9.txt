```python
import numpy as np
from sklearn.cluster import DBSCAN
from sklearn.neighbors import NearestNeighbors

def agent_solver_v2(v: np.ndarray, content: list[dict]) -> np.ndarray:
    """
    Infer a valid agent setting matrix (actions x [probabilities over 5 outcomes + cost])
    that explains all historical interactions under IR and IC constraints.

    Args:
        v: np.ndarray of shape (5,), principal's reward vector for 5 outcomes.
        content: list of dicts, each with keys 'Contract' (list of 5 float payments),
                 'Principal Utility' (float), and 'Agent Action' (1 or -1).

    Returns:
        np.ndarray of shape (n_actions, 6), rows are [p1,...,p5,cost]
    """
    m = v.shape[0]  # number of outcomes (expected 5)

    # Separate accepted and rejected logs
    accepted_logs = [log for log in content if log['Agent Action'] == 1]
    rejected_logs = [log for log in content if log['Agent Action'] == -1]

    # If no accepted logs, return trivial uniform distribution with zero cost
    if not accepted_logs:
        p_uniform = np.ones(m) / m
        return np.array([np.append(p_uniform, 0.0)])

    accepted_contracts = np.array([log['Contract'] for log in accepted_logs])

    # Normalize accepted contracts for clustering: scale each contract to sum=1 to capture outcome pattern
    accepted_contracts_sum = accepted_contracts.sum(axis=1, keepdims=True)
    accepted_contracts_norm = np.divide(
        accepted_contracts,
        accepted_contracts_sum,
        out=np.ones_like(accepted_contracts) / m,
        where=accepted_contracts_sum > 1e-12,
    )

    # Determine eps for DBSCAN via k-distance elbow method (k=3)
    nbrs = NearestNeighbors(n_neighbors=3).fit(accepted_contracts_norm)
    distances, _ = nbrs.kneighbors(accepted_contracts_norm)
    k_distances = np.sort(distances[:, 2])  # 3rd nearest neighbor distances sorted

    # Elbow detection heuristic: max second discrete difference
    if len(k_distances) >= 3:
        second_diff = np.diff(k_distances, n=2)
        elbow_idx = np.argmax(second_diff) + 1  # +1 due to diff length
        eps = k_distances[elbow_idx]
        eps = max(eps, 1e-3)  # enforce minimal eps
    else:
        eps = 0.05  # fallback

    # Run DBSCAN clustering on normalized contracts
    clustering = DBSCAN(eps=eps, min_samples=3, metric='euclidean')
    labels = clustering.fit_predict(accepted_contracts_norm)

    unique_labels = set(labels)
    if -1 in unique_labels:
        unique_labels.remove(-1)  # remove noise label

    n_clusters = len(unique_labels)
    if n_clusters == 0:
        # fallback to single cluster if all noise
        unique_labels = {0}
        labels = np.zeros(len(accepted_contracts_norm), dtype=int)
        n_clusters = 1

    # Compute cluster centers in original payment space (not normalized)
    centers = np.zeros((n_clusters, m))
    for idx, label in enumerate(sorted(unique_labels)):
        members = accepted_contracts[labels == label]
        if len(members) == 0:
            centers[idx] = np.ones(m) / m
        else:
            centers[idx] = members.mean(axis=0)

    # Normalize cluster centers to probability distributions over outcomes
    eps_norm = 1e-12
    ps = []
    for center in centers:
        p = np.maximum(center, 0)
        s = p.sum()
        if s > eps_norm:
            p /= s
        else:
            p = np.ones(m) / m
        ps.append(p)
    ps = np.array(ps)  # shape (actions, m)

    # Assign accepted contracts to closest cluster center by Euclidean distance (on normalized contracts)
    centers_norm = []
    for center in centers:
        s = center.sum()
        if s > eps_norm:
            centers_norm.append(center / s)
        else:
            centers_norm.append(np.ones(m) / m)
    centers_norm = np.array(centers_norm)

    dist_to_centers = np.linalg.norm(accepted_contracts_norm[:, None, :] - centers_norm[None, :, :], axis=2)
    assigned_actions = dist_to_centers.argmin(axis=1)

    # Compute cost per action from IR constraints:
    # For each accepted contract w assigned to action a:
    # agent utility >= 0 => p_a @ w - cost_a >= 0 => cost_a <= p_a @ w
    # So cost_a <= min_{w assigned to a} p_a @ w
    costs = np.zeros(n_clusters)
    for a in range(n_clusters):
        idxs = np.where(assigned_actions == a)[0]
        if idxs.size > 0:
            pay_ins = np.array([ps[a] @ accepted_contracts[i] for i in idxs])
            costs[a] = pay_ins.min()
        else:
            # No accepted contract assigned to action a, set cost to zero initially
            costs[a] = 0.0

    # Enforce IC constraints from rejected contracts:
    # For each rejected contract w, agent utility = max_a (p_a @ w - cost_a) < 0
    # => cost_a > p_a @ w for all a, for that w
    if rejected_logs:
        rejected_contracts = np.array([log['Contract'] for log in rejected_logs])
        rej_utilities = ps @ rejected_contracts.T  # shape (actions, rejected_count)
        max_rej_pa_w = rej_utilities.max(axis=1)
        margin = 1e-8  # small margin for strict inequality
        min_costs_from_rej = max_rej_pa_w + margin
        costs = np.maximum(costs, min_costs_from_rej)

    # Ensure costs are non-negative
    costs = np.maximum(costs, 0.0)

    # Final agent setting matrix: each row [p1, ..., p5, cost]
    agent_setting = np.hstack([ps, costs.reshape(-1, 1)])

    return agent_setting
```
