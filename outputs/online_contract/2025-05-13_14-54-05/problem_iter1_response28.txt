```python
import numpy as np
import pandas as pd
from scipy.optimize import linprog, minimize
from sklearn.cluster import DBSCAN

def agent_solver_v2(v: np.ndarray, content: pd.DataFrame) -> np.ndarray:
    """
    Infer a valid agent setting matrix (actions x (5 outcomes + 1 cost)) that explains all historical logs.
    Uses clustering on accepted contracts' induced outcome distributions and then solves a constrained optimization
    to find costs consistent with IR and IC constraints from both acceptance and rejection logs.

    Parameters:
        v (np.ndarray): Principal's reward vector for 5 outcomes.
        content (pd.DataFrame): Historical logs with columns ['Contract', 'Principal Utility', 'Agent Action'].

    Returns:
        np.ndarray: Agent setting matrix of shape (n_actions, 6), where first 5 cols sum to 1 (probabilities),
                    last col is cost >= 0.
    """

    m_outcomes = v.shape[0]
    logs = content.copy()

    # Extract accepted logs and their contracts
    accepted = logs[logs['Agent Action'] == 1].reset_index(drop=True)
    rejected = logs[logs['Agent Action'] == -1].reset_index(drop=True)

    # Step 1: For each accepted log, infer an outcome distribution p_i s.t.
    # p_i @ 1 = 1, p_i @ v - cost_i >= 0, where cost_i unknown
    # We approximate p_i by solving LP that maximizes p_i @ (w - alpha * v) for some alpha,
    # but since cost unknown, we alternatively approximate p_i by maximizing likelihood of outcomes
    # given contract payments w_i and principal utility u_i.
    #
    # Here, we infer p_i by solving:
    # max_p p @ w_i
    # s.t sum p = 1, p >= 0, p @ v = principal_utility_i + cost_i (unknown)
    # Since cost unknown, approximate p_i by maximizing contract payment normalized:
    # We use a heuristic: p_i proportional to contract payment * v
    # Normalize to sum=1
    
    def infer_p(w):
        # Heuristic: p proportional to w, normalized
        p = np.array(w, dtype=float)
        p = np.clip(p, 1e-8, None)
        p /= p.sum()
        return p

    p_list = []
    for idx, row in accepted.iterrows():
        w = np.array(row['Contract'])
        p = infer_p(w)
        p_list.append(p)
    p_arr = np.vstack(p_list)  # shape (num_accepted, 5)

    # Step 2: Cluster p vectors using DBSCAN to discover a flexible number of agent actions
    clustering = DBSCAN(eps=0.15, min_samples=3).fit(p_arr)
    labels = clustering.labels_

    # Handle case all rejected (-1): fallback to single uniform action with zero cost
    if np.all(labels == -1):
        uniform_p = np.ones(m_outcomes) / m_outcomes
        return np.hstack([uniform_p.reshape(1, -1), np.array([[0.]])])

    # Select clusters with label >=0, build candidate actions as cluster centers
    unique_labels = set(labels)
    unique_labels.discard(-1)  # remove noise

    # If no clusters found but some accepted, fallback to one cluster with mean p
    if len(unique_labels) == 0:
        mean_p = p_arr.mean(axis=0)
        mean_p /= mean_p.sum()
        unique_labels = [0]
        cluster_centers = [mean_p]
    else:
        cluster_centers = []
        for label in unique_labels:
            cluster_centers.append(p_arr[labels == label].mean(axis=0))
        cluster_centers = np.array(cluster_centers)
        # Normalize centers to sum to 1 exactly in case of numeric errors
        cluster_centers /= cluster_centers.sum(axis=1, keepdims=True)

    n_actions = len(cluster_centers)

    # Step 3: Assign each accepted log to nearest cluster center (agent action)
    def assign_action(p):
        dists = np.linalg.norm(cluster_centers - p, axis=1)
        return np.argmin(dists)

    assigns = -np.ones(len(logs), dtype=int)
    for i, row in accepted.iterrows():
        p = infer_p(np.array(row['Contract']))
        assigns[row.name] = assign_action(p)

    # Step 4: Formulate constraints for costs c_a >= 0 for each action a
    # IR constraints for accepted logs:
    # For accepted log i with contract w_i and assigned action a_i: p_a_i @ w_i - c_a_i >= 0
    # => c_a_i <= p_a_i @ w_i

    # IC constraints for accepted logs (between assigned action and all other actions):
    # For accepted log i with contract w_i and assigned action a_i:
    # p_a_i @ w_i - c_a_i >= p_b @ w_i - c_b for all b != a_i
    # => c_b - c_a_i >= p_b @ w_i - p_a_i @ w_i

    # IR constraints for rejected logs:
    # For rejected log j with contract w_j:
    # For all actions a: p_a @ w_j - c_a < 0
    # => c_a > p_a @ w_j

    # We'll encode inequalities as linear constraints and solve for c

    # Variables: c = [c_0, c_1, ..., c_{n_actions-1}] costs >= 0

    # Build constraints matrices for linprog:
    # We want to find costs c that satisfy:
    # 1) For accepted logs i:
    #    c[a_i] <= p_{a_i} @ w_i  (IR)
    # => - c[a_i] >= - p_{a_i} @ w_i

    # 2) For accepted logs i and all b != a_i:
    #    c[b] - c[a_i] >= p_b @ w_i - p_{a_i} @ w_i  (IC)

    # 3) For rejected logs j and all a:
    #    c[a] > p_a @ w_j
    # => -c[a] < -p_a @ w_j
    # We'll relax strict inequality to c[a] >= p_a @ w_j + epsilon

    # 4) c >= 0

    epsilon = 1e-5  # small margin for strict inequalities

    c_vars = n_actions
    A_ub = []
    b_ub = []

    # IR constraints (negated for <= form)
    for i, row in accepted.iterrows():
        a_i = assigns[row.name]
        if a_i == -1:
            # assign fallback to nearest cluster center
            p_i = infer_p(np.array(row['Contract']))
            a_i = assign_action(p_i)
        w_i = np.array(row['Contract'])
        rhs = cluster_centers[a_i] @ w_i
        # -c[a_i] <= -rhs  =>  c[a_i] >= rhs
        vec = np.zeros(c_vars)
        vec[a_i] = -1
        A_ub.append(vec)
        b_ub.append(-rhs)

    # IC constraints
    for i, row in accepted.iterrows():
        a_i = assigns[row.name]
        if a_i == -1:
            p_i = infer_p(np.array(row['Contract']))
            a_i = assign_action(p_i)
        w_i = np.array(row['Contract'])
        for b in range(n_actions):
            if b == a_i:
                continue
            lhs = np.zeros(c_vars)
            lhs[b] = 1
            lhs[a_i] = -1
            rhs = (cluster_centers[b] @ w_i) - (cluster_centers[a_i] @ w_i)
            # lhs @ c >= rhs => -lhs @ c <= -rhs
            A_ub.append(-lhs)
            b_ub.append(-rhs)

    # Rejected logs constraints (c[a] >= p_a @ w_j + epsilon)
    for j, row in rejected.iterrows():
        w_j = np.array(row['Contract'])
        for a in range(n_actions):
            vec = np.zeros(c_vars)
            vec[a] = -1
            rhs = - (cluster_centers[a] @ w_j + epsilon)
            A_ub.append(vec)
            b_ub.append(rhs)

    A_ub = np.array(A_ub)
    b_ub = np.array(b_ub)

    # Bounds c >= 0
    bounds = [(0, None) for _ in range(c_vars)]

    # Objective: minimize sum costs (arbitrary, since any feasible is valid)
    c_obj = np.ones(c_vars)

    # Solve LP
    res = linprog(c=c_obj, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')

    if not res.success:
        # fallback: zero costs (may violate constraints but no feasible found)
        costs = np.zeros(n_actions)
    else:
        costs = res.x

    # Ensure no negative costs (numerical safety)
    costs = np.clip(costs, 0, None)

    # Compose final agent setting matrix
    agent_setting = np.hstack([cluster_centers, costs.reshape(-1,1)])

    return agent_setting
```
