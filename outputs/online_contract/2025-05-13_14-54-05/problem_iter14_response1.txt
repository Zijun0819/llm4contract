```python
import numpy as np
import pandas as pd
from scipy.optimize import linprog
from sklearn.cluster import KMeans

def agent_solver_v2(v: np.ndarray, content: list[dict]) -> np.ndarray:
    """
    Infer a valid agent setting matrix (actions x [probabilities over 5 outcomes + cost])
    that explains all historical interactions under IR and IC constraints.

    Args:
        v: np.ndarray of shape (5,), principal's reward vector for 5 outcomes.
        content: list of dicts, each with keys 'Contract' (list of 5 float payments),
                 'Principal Utility' (float), and 'Agent Action' (1 or -1).

    Returns:
        np.ndarray of shape (n_actions, 6), rows are [p1,...,p5,cost]
    """
    m = v.shape[0]  # number of outcomes (expected 5)
    logs_df = pd.DataFrame(content)

    accept_df = logs_df[logs_df['Agent Action'] == 1]
    reject_df = logs_df[logs_df['Agent Action'] == -1]

    # If no accepted contracts, return trivial uniform distribution with zero cost
    if len(accept_df) == 0:
        p_uniform = np.ones(m) / m
        return np.array([np.append(p_uniform, 0.0)])

    accept_contracts = np.vstack(accept_df['Contract'].to_numpy())
    accept_putils = accept_df['Principal Utility'].to_numpy()
    reject_contracts = np.vstack(reject_df['Contract'].to_numpy()) if len(reject_df) > 0 else np.empty((0, m))

    # Step 1: For each accepted contract, infer a plausible outcome distribution p (prob vector)
    # Solve LP for each accepted contract:
    #   sum p = 1
    #   p @ (v - w) = principal utility
    #   0 <= p <= 1
    # This ensures p explains the observed principal utility given contract w.

    def solve_p_for_accept(w: np.ndarray, pu: float) -> np.ndarray:
        A_eq = np.vstack([np.ones(m), v - w])
        b_eq = np.array([1.0, pu])
        bounds = [(0, 1) for _ in range(m)]
        res = linprog(c=np.zeros(m), A_eq=A_eq, b_eq=b_eq, bounds=bounds, method='highs')
        if res.success:
            p = res.x
            p = np.clip(p, 0, None)
            s = p.sum()
            if s > 0:
                p /= s
            else:
                p = np.ones(m) / m
            return p
        else:
            # fallback uniform distribution if infeasible
            return np.ones(m) / m

    candidate_ps = np.array([solve_p_for_accept(w, pu) for w, pu in zip(accept_contracts, accept_putils)])

    # Step 2: Adaptive clustering with explicit IC-aware initialization and outlier handling
    max_clusters = min(10, len(candidate_ps))
    if max_clusters == 1:
        n_actions = 1
        p_centers = candidate_ps.mean(axis=0, keepdims=True)
        accept_assign = np.zeros(len(candidate_ps), dtype=int)
    else:
        # Robust outlier removal: remove candidate_ps too far from median p by L1 distance
        median_p = np.median(candidate_ps, axis=0)
        dists = np.linalg.norm(candidate_ps - median_p, ord=1, axis=1)
        dist_thresh = np.percentile(dists, 95)  # remove top 5% farthest outliers
        mask = dists <= dist_thresh
        filtered_ps = candidate_ps[mask]
        filtered_weights = np.maximum(accept_putils[mask] - accept_putils.min() + 1e-3, 1e-3)

        # If filtering too aggressive, fallback to all
        if len(filtered_ps) < max(1, 0.7 * len(candidate_ps)):
            filtered_ps = candidate_ps
            filtered_weights = np.maximum(accept_putils - accept_putils.min() + 1e-3, 1e-3)

        inertias = []
        km_models = []
        for k in range(1, max_clusters + 1):
            kmeans = KMeans(n_clusters=k, random_state=0, n_init=20)
            kmeans.fit(filtered_ps, sample_weight=filtered_weights)
            inertias.append(kmeans.inertia_)
            km_models.append(kmeans)
        inertias = np.array(inertias)
        deltas = -np.diff(inertias)  # positive reductions

        if len(deltas) >= 2:
            ratios = deltas[1:] / (deltas[:-1] + 1e-12)
            elbow_candidates = np.where(ratios < 0.5)[0] + 2  # +2 because ratios index starts at 2 clusters
            n_actions = elbow_candidates[0] if len(elbow_candidates) > 0 else max_clusters
        elif len(deltas) == 1:
            n_actions = 1 if deltas[0] < 1e-3 else 2
        else:
            n_actions = 1

        kmeans = km_models[n_actions - 1]
        p_centers = kmeans.cluster_centers_
        accept_assign = kmeans.predict(candidate_ps)

    # Step 3: Remove empty clusters robustly
    unique_clusters, counts = np.unique(accept_assign, return_counts=True)
    nonempty_clusters = unique_clusters[counts > 0]
    if len(nonempty_clusters) < n_actions:
        p_centers = p_centers[nonempty_clusters]
        n_actions = len(nonempty_clusters)
        mapping = {old: new for new, old in enumerate(nonempty_clusters)}
        accept_assign = np.array([mapping[a] for a in accept_assign])

    # Normalize p_centers rows to sum to 1 (numerical safety)
    p_centers = np.clip(p_centers, 0, None)
    row_sums = p_centers.sum(axis=1, keepdims=True)
    row_sums[row_sums == 0] = 1.0
    p_centers /= row_sums

    # Step 4: Solve a constrained QP-like problem (via linprog) to find minimal costs satisfying IR and IC strictly
    # Variables: costs (one per action), costs >= 0
    # Constraints:
    #   For each accepted contract i assigned to action a: p_a @ w_i - cost_a >= margin_IR
    #   For each rejected contract r and each action a: p_a @ w_r - cost_a <= -margin_IC

    margin_IR = 1e-6
    margin_IC = 1e-6

    # Build constraints matrices for linprog:
    # We want to find costs >= 0 minimizing sum costs (or just feasibility)
    # IR: cost_a <= p_a @ w_i - margin_IR  =>  -cost_a <= -p_a @ w_i + margin_IR
    # IC: cost_a >= p_a @ w_r + margin_IC  =>  cost_a - p_a @ w_r >= margin_IC

    # Number of variables: n_actions (costs)
    # Inequality constraints A_ub x <= b_ub

    # IR constraints (one per accepted contract):
    # For accepted contract i assigned to action a:
    # -cost_a <= -p_a @ w_i + margin_IR
    # => coefficient vector for costs: zeros except -1 at a-th pos
    # => b_ub = -p_a @ w_i + margin_IR

    A_ub_list = []
    b_ub_list = []

    for i, a in enumerate(accept_assign):
        p_a = p_centers[a]
        w_i = accept_contracts[i]
        val = np.dot(p_a, w_i)
        row = np.zeros(n_actions)
        row[a] = -1.0
        A_ub_list.append(row)
        b_ub_list.append(-val + margin_IR)

    # IC constraints (for each rejected contract and each action):
    # cost_a >= p_a @ w_r + margin_IC
    # => -cost_a <= -p_a @ w_r - margin_IC
    # => coefficient vector for costs: zeros except -1 at a-th pos
    # => b_ub = -p_a @ w_r - margin_IC

    for w_r in reject_contracts:
        for a in range(n_actions):
            p_a = p_centers[a]
            val = np.dot(p_a, w_r)
            row = np.zeros(n_actions)
            row[a] = -1.0
            A_ub_list.append(row)
            b_ub_list.append(-val - margin_IC)

    A_ub = np.vstack(A_ub_list) if A_ub_list else np.empty((0, n_actions))
    b_ub = np.array(b_ub_list) if b_ub_list else np.empty((0,))

    # Bounds for costs: costs >= 0
    bounds = [(0, None) for _ in range(n_actions)]

    # Objective: minimize sum of costs (to find minimal costs satisfying constraints)
    c = np.ones(n_actions)

    res = linprog(c=c, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')

    if res.success:
        costs = res.x
    else:
        # fallback: for each action, cost = max over (p_a @ rejected contracts) + margin_IC or 0
        costs = np.zeros(n_actions)
        if reject_contracts.shape[0] > 0:
            rej_utils = reject_contracts @ p_centers.T  # (#rej, n_actions)
            max_rej_util = np.max(rej_utils, axis=0)
            costs = np.maximum(0.0, max_rej_util + margin_IC)
        # ensure IR by min payoffs - margin_IR if possible
        for a in range(n_actions):
            idxs = np.where(accept_assign == a)[0]
            if len(idxs) > 0:
                payoffs = accept_contracts[idxs] @ p_centers[a]
                costs[a] = max(costs[a], np.min(payoffs) - margin_IR)
        costs = np.clip(costs, 0, None)

    # Final numerical safety clamp
    costs = np.clip(costs, 0, None)

    # Assemble agent setting matrix: [p1,...,p5, cost]
    agent_setting = np.hstack([p_centers, costs.reshape(-1, 1)])

    return agent_setting
```
