```python
import numpy as np
from scipy.optimize import linprog
from sklearn.cluster import DBSCAN

def agent_solver_v2(v: np.ndarray, content: list[dict]) -> np.ndarray:
    """
    Infer a valid agent setting matrix from historical logs with contracts, principal utilities,
    and agent actions. This version adaptively chooses the number of actions via clustering,
    enforces linear feasibility for agent IR/IC constraints, and robustly handles rejections.
    
    Returns:
        agent_setting: n_actions x (5 + 1) matrix, each row: [p(outcomes), cost]
    """

    # Parse logs into arrays
    contracts = np.array([log['Contract'] for log in content])  # shape (L,5)
    principal_utils = np.array([log['Principal Utility'] for log in content])  # shape (L,)
    actions = np.array([log['Agent Action'] for log in content])  # shape (L,)
    L, m = contracts.shape

    # Step 1: Extract accepted contract logs and their inferred expected outcome distributions.
    # For each accepted contract with principal utility > 0, try to find an agent outcome distribution p
    # satisfying p @ v = principal_utility + agent_cost (unknown), but we don't know agent_cost.
    # Instead, we infer p from accepted logs by reverse-engineering p from contract and principal utility,
    # assuming agent expected utility >=0 and principal utility = contract payout - agent cost.

    # We first guess p by maximizing likelihood they generated observed contracts under assumption:
    # agent picks an action (p,c) so that expected payment p@contract - c >=0,
    # and principal utility = p@v - p@contract

    # Simplification: Try fitting p for accepted logs by solving linear programs that satisfy:
    # p sums to 1, p>=0
    # p@contract >= c (unknown), and p@v - p@contract = principal utility
    # We fix c=0 to get candidate p (relax later by clustering).

    # Get all accepted indices
    accepted_idx = np.where(actions == 1)[0]
    rejected_idx = np.where(actions == -1)[0]

    if len(accepted_idx) == 0:
        # No accepted logs to infer from, return trivial uniform distribution with zero cost
        uniform_p = np.ones(m) / m
        return np.hstack([uniform_p.reshape(1, -1), np.array([[0.0]])])

    # Step 2: For each accepted contract, find a feasible p that satisfies:
    #   sum(p) = 1,
    #   p >= 0,
    #   agent utility = p@contract - cost >= 0, cost unknown, set cost=0 temporarily,
    #   principal utility = p@v - p@contract = principal_utility (known)
    # We use principal_utility = p@v - p@contract -> p@(v - contract) = principal_utility
    # We impose sum(p)=1, p>=0, and p@(v - contract) = principal_utility.

    candidate_ps = []
    for i in accepted_idx:
        w = contracts[i]
        u = principal_utils[i]
        # Solve LP: find p >=0, sum(p)=1, p@(v - w) = u
        # Since linprog supports only inequalities, we turn equality into two inequalities
        A_eq = np.vstack([np.ones(m), v - w])
        b_eq = np.array([1.0, u])
        bounds = [(0, 1)] * m

        # linprog formulation: minimize 0 subject to equalities and bounds
        # Since linprog minimizes c^T x, set c=0 to find any feasible p
        res = linprog(c=np.zeros(m), A_eq=A_eq, b_eq=b_eq, bounds=bounds, method='highs')
        if res.success:
            p = res.x
            candidate_ps.append(p)
        else:
            # If no feasible p found, relax equality constraints to inequalities with tolerance
            tol = 1e-5
            A_ub = np.vstack([np.ones(m), -(v - w)])
            b_ub = np.array([1.0, -u + tol])
            A_lb = -A_ub
            b_lb = -b_ub
            # Combine to inequality constraints A_ub x <= b_ub and A_lb x <= b_lb covers equalities with tolerance
            # This is complex to implement with linprog, so skip for now.
            continue

    if len(candidate_ps) == 0:
        # fallback: uniform distribution
        uniform_p = np.ones(m) / m
        return np.hstack([uniform_p.reshape(1, -1), np.array([[0.0]])])

    candidate_ps = np.array(candidate_ps)

    # Step 3: Cluster candidate_ps to identify distinct agent actions
    # Use DBSCAN to find natural clusters and handle noise adaptively
    clustering = DBSCAN(eps=0.15, min_samples=3).fit(candidate_ps)
    labels = clustering.labels_
    unique_labels = set(labels)
    if -1 in unique_labels:
        unique_labels.remove(-1)  # remove noise label

    if len(unique_labels) == 0:
        # no clusters found, fallback to all points as one cluster
        unique_labels = {0}
        labels = np.zeros(len(candidate_ps), dtype=int)

    # Compute cluster centers as mean of points in cluster
    cluster_centers = []
    for lbl in unique_labels:
        cluster_centers.append(candidate_ps[labels == lbl].mean(axis=0))
    cluster_centers = np.array(cluster_centers)

    n_actions = cluster_centers.shape[0]

    # Step 4: Infer costs per action from accepted logs:
    # For each cluster center p_a, cost_a = min over accepted contracts assigned to cluster a of p_a @ w - agent utility >= 0
    # agent utility >= 0 means p_a @ w - cost_a >= 0 -> cost_a <= p_a @ w
    # We want cost_a as max of these lower bounds to satisfy all accepted logs assigned to that cluster

    costs = np.zeros(n_actions)
    # Assign each accepted p to cluster by label; assign accepted contracts accordingly
    accepted_labels = np.full(len(accepted_idx), -1, dtype=int)
    for i, p in enumerate(candidate_ps):
        # find cluster label index
        lbl = labels[i]
        if lbl == -1:
            continue
        accepted_labels[i] = list(unique_labels).index(lbl)

    for a in range(n_actions):
        # indices of accepted logs assigned to cluster a
        idxs = np.where(accepted_labels == a)[0]
        if len(idxs) == 0:
            costs[a] = 0.0
            continue
        # contracts of these accepted logs
        accepted_contracts_a = contracts[accepted_idx[idxs]]
        # For each contract w, p_a @ w is upper bound on cost_a to keep agent utility >= 0
        p_a = cluster_centers[a]
        upper_bounds = accepted_contracts_a @ p_a
        # cost must be <= min upper bound to satisfy all
        costs[a] = max(0.0, upper_bounds.min())

    # Step 5: Rejection consistency:
    # For each rejected contract w, the agent utility must be < 0 for all actions:
    # p_a @ w - cost_a < 0 for all a
    # If not, increase cost_a to exceed p_a @ w for any rejection to keep rejection consistent

    if len(rejected_idx) > 0:
        rejected_contracts = contracts[rejected_idx]
        for a in range(n_actions):
            p_a = cluster_centers[a]
            vals = rejected_contracts @ p_a
            # find maximum vals among rejected contracts for this action
            max_rej_val = vals.max()
            # cost_a must be strictly greater than max_rej_val to ensure rejection utility < 0
            if costs[a] <= max_rej_val:
                costs[a] = max_rej_val + 1e-6  # small margin

    # Step 6: Normalize cluster_centers to ensure they are valid probability distributions (sum to 1, >=0)
    for a in range(n_actions):
        p = cluster_centers[a]
        p[p < 0] = 0.0
        s = p.sum()
        if s > 0:
            cluster_centers[a] = p / s
        else:
            cluster_centers[a] = np.ones(m) / m  # fallback uniform

    # Step 7: Compose agent setting matrix
    # shape: n_actions x (5 + 1)
    agent_setting = np.hstack([cluster_centers, costs.reshape(-1, 1)])

    return agent_setting
```
