```python
import numpy as np
import pandas as pd
from scipy.optimize import linprog
from sklearn.cluster import KMeans

def agent_solver_v2(v: np.ndarray, content: list[dict]) -> np.ndarray:
    """
    Infer a valid agent setting (actions with outcome distributions and costs)
    consistent with historical interaction logs under IR and IC constraints.

    Parameters:
    - v: np.ndarray, principal's reward vector for 5 outcomes (length 5).
    - content: list of dicts, each with keys:
        'Contract': list of 5 payments,
        'Principal Utility': float,
        'Agent Action': 1 (accept) or -1 (reject).

    Returns:
    - agent_setting: np.ndarray, n_actions x 6 matrix,
      first 5 columns probability distributions over outcomes,
      last column agent cost for that action (>=0).
    """
    m = len(v)
    logs_df = pd.DataFrame(content)

    accept_df = logs_df[logs_df['Agent Action'] == 1]
    reject_df = logs_df[logs_df['Agent Action'] == -1]

    # If no accepted contracts, return trivial uniform distribution with zero cost
    if len(accept_df) == 0:
        uniform_p = np.ones(m) / m
        return np.array([np.append(uniform_p, 0.0)])

    accept_contracts = np.vstack(accept_df['Contract'].to_numpy())  # shape (L_accept, m)
    accept_putils = accept_df['Principal Utility'].to_numpy()       # shape (L_accept,)

    # Step 1: For each accepted contract, solve feasibility LP for outcome distribution p:
    # Constraints:
    #   sum p = 1
    #   p @ v = principal utility (accept_putils[i])
    #   0 <= p <= 1
    # Objective: zero (feasibility)
    def solve_p_for_accept(payout: np.ndarray, pu: float) -> np.ndarray:
        A_eq = np.vstack([np.ones(m), v])
        b_eq = np.array([1.0, pu])
        bounds = [(0, 1) for _ in range(m)]
        res = linprog(c=np.zeros(m), A_eq=A_eq, b_eq=b_eq, bounds=bounds, method='highs')
        if res.success:
            p = np.clip(res.x, 0, 1)
            s = p.sum()
            if s > 0:
                p /= s
            else:
                p = np.ones(m) / m
            return p
        else:
            # fallback uniform distribution
            return np.ones(m) / m

    candidate_ps = np.array([solve_p_for_accept(w, pu) for w, pu in zip(accept_contracts, accept_putils)])

    # Step 2: Cluster candidate_ps to find representative actions
    max_clusters = min(10, len(candidate_ps))
    if max_clusters == 1:
        n_actions = 1
        p_centers = candidate_ps.mean(axis=0, keepdims=True)
        accept_assign = np.zeros(len(candidate_ps), dtype=int)
    else:
        inertias = []
        for k in range(1, max_clusters + 1):
            kmeans = KMeans(n_clusters=k, random_state=0, n_init=10).fit(candidate_ps)
            inertias.append(kmeans.inertia_)
        deltas = np.diff(inertias)
        if len(deltas) == 0:
            n_actions = 1
        else:
            max_delta = np.max(deltas)
            threshold = max_delta * 0.5
            candidates = np.where(deltas < threshold)[0]
            n_actions = candidates[0] + 1 if len(candidates) > 0 else max_clusters
        kmeans = KMeans(n_clusters=n_actions, random_state=0, n_init=20).fit(candidate_ps)
        p_centers = kmeans.cluster_centers_
        accept_assign = kmeans.predict(candidate_ps)

    # Step 3: Setup LP variables: costs c_a >= 0 for each action a in [0, n_actions)
    # Constraints:
    # IR for accepted contracts assigned to action a:
    #   p_a @ w_i - c_a >= 0  =>  c_a <= p_a @ w_i
    # IC for accepted contracts assigned to action a:
    #   For all a' != a: p_a @ w_i - c_a >= p_a' @ w_i - c_a'
    #   => c_a' - c_a >= p_a' @ w_i - p_a @ w_i
    # Rejection constraints for rejected contracts:
    #   For all actions a: p_a @ w_r - c_a < 0
    #   => c_a > p_a @ w_r (strict)
    #   We relax strict by margin eps > 0

    eps = 1e-7
    n = n_actions

    A_ub = []
    b_ub = []

    # IR constraints: c_a <= p_a @ w_i  =>  c_a - (p_a @ w_i) <= 0
    for idx, a_i in enumerate(accept_assign):
        w_i = accept_contracts[idx]
        p_a = p_centers[a_i]
        row = np.zeros(n)
        row[a_i] = 1.0
        A_ub.append(row)
        b_ub.append(p_a @ w_i)

    # IC constraints:
    # For each accepted contract i assigned to a_i, for all a' != a_i:
    # c_{a'} - c_{a_i} >= p_{a'} @ w_i - p_{a_i} @ w_i
    # => -c_{a'} + c_{a_i} <= -(p_{a'} @ w_i - p_{a_i} @ w_i)
    for idx, a_i in enumerate(accept_assign):
        w_i = accept_contracts[idx]
        p_a_i = p_centers[a_i]
        for a_prime in range(n):
            if a_prime == a_i:
                continue
            p_a_prime = p_centers[a_prime]
            row = np.zeros(n)
            row[a_prime] = -1.0
            row[a_i] = 1.0
            rhs = -(p_a_prime @ w_i - p_a_i @ w_i)
            A_ub.append(row)
            b_ub.append(rhs)

    # Rejection constraints:
    # For each rejected contract w_r, for all actions a:
    # p_a @ w_r - c_a < 0  =>  c_a > p_a @ w_r
    # => -c_a < -p_a @ w_r - eps  =>  -c_a <= -p_a @ w_r - eps
    if len(reject_df) > 0:
        reject_contracts = np.vstack(reject_df['Contract'].to_numpy())
        for w_r in reject_contracts:
            for a in range(n):
                p_a = p_centers[a]
                row = np.zeros(n)
                row[a] = -1.0
                A_ub.append(row)
                b_ub.append(-(p_a @ w_r + eps))

    A_ub = np.array(A_ub) if A_ub else None
    b_ub = np.array(b_ub) if b_ub else None

    # Objective: minimize sum of costs (small positive weight) to avoid trivial large costs
    c_obj = np.ones(n) * 1e-8

    bounds = [(0, None) for _ in range(n)]

    res = linprog(c=c_obj, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')

    if res.success:
        costs = res.x
    else:
        # Fallback heuristic if LP fails:
        # Use IR upper bounds if available, else zero
        costs = np.zeros(n)
        for a in range(n):
            assigned_idxs = np.where(accept_assign == a)[0]
            if assigned_idxs.size > 0:
                pay_ins = np.array([p_centers[a] @ accept_contracts[i] for i in assigned_idxs])
                costs[a] = max(pay_ins.min(), 0.0)
            else:
                costs[a] = 0.0
        # Increase costs to satisfy rejection constraints if any
        if len(reject_df) > 0:
            reject_contracts = np.vstack(reject_df['Contract'].to_numpy())
            rej_utilities = reject_contracts @ p_centers.T  # shape (#rej, n)
            rej_max_util = np.max(rej_utilities, axis=0)  # shape (n,)
            costs = np.maximum(costs, rej_max_util + eps)

    # Safety normalization of p_centers rows
    p_centers = np.clip(p_centers, 0, None)
    row_sums = p_centers.sum(axis=1, keepdims=True)
    row_sums[row_sums < 1e-12] = 1.0
    p_centers = p_centers / row_sums

    costs = np.clip(costs, 0, None)

    agent_setting = np.hstack([p_centers, costs.reshape(-1, 1)])

    return agent_setting
```
