```python
import numpy as np
from sklearn.cluster import DBSCAN
from sklearn.preprocessing import normalize
from sklearn.metrics import pairwise_distances
from scipy.optimize import linprog

def agent_solver_v2(v: np.ndarray, content: list[dict]) -> np.ndarray:
    """
    Infer a valid agent setting matrix (actions x [probabilities over 5 outcomes + cost])
    that explains all historical interactions under IR and IC constraints.

    Args:
        v: np.ndarray of shape (5,), principal's reward vector for 5 outcomes.
        content: list of dicts, each with keys 'Contract' (list of 5 float payments),
                 'Principal Utility' (float), and 'Agent Action' (1 or -1).

    Returns:
        np.ndarray of shape (n_actions, 6), rows are [p1,...,p5,cost]
    """
    m = v.shape[0]  # number of outcomes (expected 5)
    L = len(content)

    # Separate accepted and rejected logs
    accepted_logs = [log for log in content if log['Agent Action'] == 1]
    rejected_logs = [log for log in content if log['Agent Action'] == -1]

    # If no accepted logs, return trivial uniform distribution with zero cost
    if not accepted_logs:
        p_uniform = np.ones(m) / m
        return np.array([np.append(p_uniform, 0.0)])

    accepted_contracts = np.array([log['Contract'] for log in accepted_logs])  # shape (N_acc, 5)

    # Normalize accepted contracts to sum to 1 for clustering (L1 norm)
    accepted_norm = normalize(accepted_contracts, norm='l1', axis=1)

    # Adaptive DBSCAN clustering on normalized contracts with L1 distance
    # Use elbow method on eps by scanning eps values, pick eps with stable clusters and reasonable number
    # We want to find clusters that explain accepted contracts well (small within-cluster radius)
    eps_candidates = np.linspace(0.05, 0.5, 10)
    best_eps = None
    best_labels = None
    best_n_clusters = 0
    best_avg_radius = np.inf

    for eps in eps_candidates:
        clustering = DBSCAN(eps=eps, min_samples=2, metric='manhattan')
        labels = clustering.fit_predict(accepted_norm)
        # Ignore noise points (-1 label)
        unique_labels = set(labels)
        unique_labels.discard(-1)
        n_clusters = len(unique_labels)
        if n_clusters == 0:
            continue
        # Compute average cluster radius (mean L1 distance to cluster center)
        avg_radii = []
        for label in unique_labels:
            cluster_points = accepted_norm[labels == label]
            center = cluster_points.mean(axis=0)
            dists = np.abs(cluster_points - center).sum(axis=1)
            avg_radii.append(dists.mean())
        avg_radius = np.mean(avg_radii)
        # We want to minimize avg_radius and have clusters > 0
        if avg_radius < best_avg_radius:
            best_avg_radius = avg_radius
            best_eps = eps
            best_labels = labels.copy()
            best_n_clusters = n_clusters

    # If no clustering found, fallback to one cluster (all accepted contracts)
    if best_labels is None:
        best_labels = np.zeros(len(accepted_contracts), dtype=int)
        best_n_clusters = 1

    # Assign noise points (-1) to nearest cluster by L1 distance to cluster centers
    labels = best_labels
    unique_labels = set(labels)
    unique_labels.discard(-1)
    cluster_centers = []
    for label in unique_labels:
        cluster_points = accepted_norm[labels == label]
        center = cluster_points.mean(axis=0)
        cluster_centers.append(center)
    cluster_centers = np.array(cluster_centers)  # shape (n_clusters, 5)

    noise_idx = np.where(labels == -1)[0]
    if noise_idx.size > 0 and cluster_centers.shape[0] > 0:
        noise_points = accepted_norm[noise_idx]
        dists = pairwise_distances(noise_points, cluster_centers, metric='manhattan')
        nearest_clusters = dists.argmin(axis=1)
        for i, ni in enumerate(noise_idx):
            labels[ni] = list(unique_labels)[nearest_clusters[i]]

    # Prepare final clusters with assigned points
    unique_labels = sorted(set(labels))
    n_actions = len(unique_labels)
    ps = np.zeros((n_actions, m))  # probabilities per action
    accepted_contracts_arr = accepted_contracts
    # Compute cluster centers in original contract space (not normalized)
    for i, label in enumerate(unique_labels):
        cluster_points = accepted_contracts_arr[labels == label]
        if len(cluster_points) == 0:
            # fallback uniform
            ps[i] = np.ones(m) / m
        else:
            center = cluster_points.mean(axis=0)
            # Normalize center to probability distribution (nonnegative, sum to 1)
            p = np.maximum(center, 0)
            s = p.sum()
            if s > 1e-12:
                p = p / s
            else:
                p = np.ones(m) / m
            ps[i] = p

    # Assign each accepted contract to closest cluster center by L1 distance on normalized contracts
    accepted_norm = normalize(accepted_contracts_arr, norm='l1', axis=1)
    cluster_centers_norm = normalize(ps, norm='l1', axis=1)
    dist_accept = pairwise_distances(accepted_norm, cluster_centers_norm, metric='manhattan')
    assigned_actions = dist_accept.argmin(axis=1)

    # Setup LP to solve for costs enforcing IR and IC strictly
    # Variables: costs c_i >= 0 for i in [0, n_actions-1]
    # IR constraints for accepted contracts:
    # For accepted contract j assigned to action a_j:
    # p_a_j @ w_j - c_a_j >= 0  =>  c_a_j <= p_a_j @ w_j
    # IC constraints for rejected contracts:
    # For each rejected contract w:
    # max_a (p_a @ w - c_a) < 0
    # => for all a: c_a > p_a @ w
    # To enforce strict inequality, add small margin delta=1e-6

    delta = 1e-6
    c_dim = n_actions

    # Objective: minimize sum of costs (or zero vector, since we want feasibility)
    c_obj = np.zeros(c_dim)

    # Inequality constraints matrix and vector: A_ub @ c <= b_ub

    # IR constraints: c_a <= p_a @ w_j
    # For each accepted contract j:
    # c_a_j - (p_a_j @ w_j) <= 0
    A_ub_ir = np.zeros((len(accepted_contracts_arr), c_dim))
    b_ub_ir = np.zeros(len(accepted_contracts_arr))
    for j, a_j in enumerate(assigned_actions):
        A_ub_ir[j, a_j] = 1.0
        b_ub_ir[j] = ps[a_j] @ accepted_contracts_arr[j]

    # IC constraints: for each rejected contract w_r and each action a:
    # -c_a + p_a @ w_r < 0  =>  c_a > p_a @ w_r + delta
    # => -c_a + p_a @ w_r <= -delta
    # So for each rejected contract and each action, one inequality row
    if rejected_logs:
        rejected_contracts = np.array([log['Contract'] for log in rejected_logs])
        n_rej = rejected_contracts.shape[0]
        A_ub_ic = np.zeros((n_rej * c_dim, c_dim))
        b_ub_ic = np.zeros(n_rej * c_dim)
        for r in range(n_rej):
            w_r = rejected_contracts[r]
            for a in range(c_dim):
                A_ub_ic[r * c_dim + a, a] = -1.0
                b_ub_ic[r * c_dim + a] = - (ps[a] @ w_r + delta)
        # Combine IR and IC constraints
        A_ub = np.vstack([A_ub_ir, A_ub_ic])
        b_ub = np.concatenate([b_ub_ir, b_ub_ic])
    else:
        A_ub = A_ub_ir
        b_ub = b_ub_ir

    # Bounds for variables: costs >= 0
    bounds = [(0, None) for _ in range(c_dim)]

    # Solve LP for costs
    res = linprog(c=c_obj, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')

    if res.success:
        costs = res.x
    else:
        # If LP fails, fallback: costs = max IR lower bounds and IC margins
        costs = np.zeros(c_dim)
        # IR fallback
        for a in range(c_dim):
            idxs = np.where(assigned_actions == a)[0]
            if idxs.size > 0:
                vals = [ps[a] @ accepted_contracts_arr[j] for j in idxs]
                costs[a] = min(vals)
            else:
                costs[a] = 0.0
        # IC fallback
        if rejected_logs:
            rejected_contracts = np.array([log['Contract'] for log in rejected_logs])
            rej_utilities = ps @ rejected_contracts.T  # shape (actions, rejected_count)
            min_costs_ic = rej_utilities.max(axis=1) + delta
            costs = np.maximum(costs, min_costs_ic)
        costs = np.maximum(costs, 0.0)

    agent_setting = np.hstack([ps, costs.reshape(-1, 1)])

    return agent_setting
```
