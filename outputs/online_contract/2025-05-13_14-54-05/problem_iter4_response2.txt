```python
import numpy as np
import pandas as pd
from scipy.optimize import linprog
from sklearn.cluster import AgglomerativeClustering

def agent_solver_v2(v: np.ndarray, content: list[dict]) -> np.ndarray:
    """
    Infer a valid agent setting matrix (actions x [probabilities over 5 outcomes + cost])
    that explains all historical interactions under IR and IC constraints.

    Args:
        v: np.ndarray of shape (5,), principal's reward vector for 5 outcomes.
        content: list of dicts, each with keys 'Contract' (list of 5 float payments),
                 'Principal Utility' (float), and 'Agent Action' (1 or -1).

    Returns:
        np.ndarray of shape (n_actions, 6), rows are [p1,...,p5,cost]
    """
    m = v.shape[0]  # number of outcomes, expected 5
    logs = pd.DataFrame(content)
    contracts = np.stack(logs['Contract'].values)  # shape (L, 5)
    actions = logs['Agent Action'].values          # shape (L,)
    principal_utils = logs['Principal Utility'].values  # shape (L,)

    accepted_idx = np.where(actions == 1)[0]
    rejected_idx = np.where(actions == -1)[0]

    # If no accepted logs, return trivial uniform distribution with zero cost
    if len(accepted_idx) == 0:
        p_uniform = np.ones(m) / m
        return np.array([np.append(p_uniform, 0.0)])

    accepted_contracts = contracts[accepted_idx]

    # --- Step 1: Clustering accepted contracts with outcome-weighted distance ---
    # Define weighted Euclidean distance with weights proportional to v (principal rewards)
    # to emphasize outcomes with higher principal value.
    # We scale v to sum to 1 to avoid scale issues.
    w_v = v / (v.sum() + 1e-12)
    sqrt_wv = np.sqrt(w_v)  # weights for Euclidean norm: sqrt of weights per dimension

    # Weighted contracts for clustering
    accepted_weighted = accepted_contracts * sqrt_wv

    max_actions = min(10, len(accepted_contracts))
    threshold = 0.03  # tighter threshold on average weighted L2 distance to cluster center

    best_labels = None
    best_n_clusters = None
    best_centers = None

    for n_clusters in range(1, max_actions + 1):
        clustering = AgglomerativeClustering(n_clusters=n_clusters)
        labels = clustering.fit_predict(accepted_weighted)
        centers = np.zeros((n_clusters, m))
        avg_dists = []
        for i in range(n_clusters):
            cluster_points = accepted_weighted[labels == i]
            if cluster_points.shape[0] == 0:
                # Empty cluster, skip
                avg_dists.append(np.inf)
                continue
            center = cluster_points.mean(axis=0)
            centers[i] = center
            dists = np.linalg.norm(cluster_points - center, axis=1)
            avg_dist = np.mean(dists)
            avg_dists.append(avg_dist)
        max_avg_dist = max(avg_dists)
        if max_avg_dist < threshold:
            best_labels = labels
            best_n_clusters = n_clusters
            best_centers = centers
            break
    else:
        # fallback: choose clustering with minimal max average distance
        if max_actions == 1:
            best_labels = np.zeros(len(accepted_contracts), dtype=int)
            best_n_clusters = 1
            best_centers = np.array([accepted_weighted.mean(axis=0)])
        else:
            best_max_avg = np.inf
            for n_clusters in range(1, max_actions + 1):
                clustering = AgglomerativeClustering(n_clusters=n_clusters)
                labels = clustering.fit_predict(accepted_weighted)
                centers = np.zeros((n_clusters, m))
                avg_dists = []
                for i in range(n_clusters):
                    cluster_points = accepted_weighted[labels == i]
                    if cluster_points.shape[0] == 0:
                        avg_dists.append(np.inf)
                        continue
                    center = cluster_points.mean(axis=0)
                    centers[i] = center
                    dists = np.linalg.norm(cluster_points - center, axis=1)
                    avg_dist = np.mean(dists)
                    avg_dists.append(avg_dist)
                max_avg_dist = max(avg_dists)
                if max_avg_dist < best_max_avg:
                    best_max_avg = max_avg_dist
                    best_labels = labels
                    best_n_clusters = n_clusters
                    best_centers = centers

    # --- Step 2: Recover centers in original contract space ---
    # best_centers are weighted means; divide by sqrt_wv to get back to contract space
    centers_unweighted = best_centers / (sqrt_wv + 1e-12)

    # --- Step 3: Normalize centers to valid probability distributions ---
    # Contracts are payments, not probabilities. We want to infer agent's outcome distributions p.
    # Strategy: project centers_unweighted to probability simplex by:
    # - zero negative entries
    # - normalize positive entries to sum to 1
    ps = []
    for i in range(best_n_clusters):
        p_i = centers_unweighted[i].copy()
        p_i = np.maximum(p_i, 0.0)
        s = p_i.sum()
        if s < 1e-12:
            p_i = np.ones(m) / m
        else:
            p_i /= s
        ps.append(p_i)
    ps = np.array(ps)  # shape (n_actions, m)

    # --- Step 4: Assign accepted contracts to closest action by weighted Euclidean distance ---
    # Compute weighted contracts and weighted ps for distance
    weighted_ps = ps * sqrt_wv
    dist_to_actions = np.linalg.norm(accepted_weighted[:, None, :] - weighted_ps[None, :, :], axis=2)
    assigned_actions = dist_to_actions.argmin(axis=1)  # length = number accepted contracts

    n_actions = best_n_clusters

    # --- Step 5: Build LP constraints for IR and IC jointly with rejection constraints ---

    # Variables: costs vector c in R^{n_actions}, c >= 0

    A_ub = []
    b_ub = []

    # IR constraints: for each accepted contract i assigned to a_i:
    # p_{a_i} @ w_i - c_{a_i} >= 0  =>  c_{a_i} <= p_{a_i} @ w_i
    for idx, a_i in zip(accepted_idx, assigned_actions):
        w_i = contracts[idx]
        p_a = ps[a_i]
        row = np.zeros(n_actions)
        row[a_i] = 1.0
        A_ub.append(row)
        b_ub.append(p_a @ w_i)

    # IC constraints: for each accepted contract i assigned to a_i, for all a' != a_i:
    # p_{a_i} @ w_i - c_{a_i} >= p_{a'} @ w_i - c_{a'}
    # => c_{a'} - c_{a_i} >= p_{a'} @ w_i - p_{a_i} @ w_i
    for idx, a_i in zip(accepted_idx, assigned_actions):
        w_i = contracts[idx]
        p_a_i = ps[a_i]
        for a_prime in range(n_actions):
            if a_prime == a_i:
                continue
            p_a_prime = ps[a_prime]
            row = np.zeros(n_actions)
            row[a_prime] = 1.0
            row[a_i] = -1.0
            rhs = (p_a_prime @ w_i) - (p_a_i @ w_i)
            A_ub.append(row)
            b_ub.append(rhs)

    # Rejection constraints: for each rejected contract i, for all actions a:
    # p_a @ w_i - c_a < 0  =>  c_a > p_a @ w_i
    # Write as: -c_a < -p_a @ w_i - epsilon => c_a >= p_a @ w_i + epsilon
    eps = 1e-7
    for idx in rejected_idx:
        w_i = contracts[idx]
        for a in range(n_actions):
            p_a = ps[a]
            row = np.zeros(n_actions)
            row[a] = -1.0
            A_ub.append(row)
            b_ub.append(-(p_a @ w_i + eps))

    A_ub = np.array(A_ub) if A_ub else None
    b_ub = np.array(b_ub) if b_ub else None

    # Objective: minimize sum of costs to keep them small and avoid trivial large costs
    c_obj = np.ones(n_actions) * 1e-8

    bounds = [(0, None) for _ in range(n_actions)]

    # Solve LP for costs
    res = linprog(c=c_obj, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')

    if res.success:
        costs = res.x
    else:
        # If LP fails, fallback to heuristic costs:
        # Use IR upper bounds if available, else zero, and enforce costs >=0
        costs = np.zeros(n_actions)
        # IR upper bounds:
        for a in range(n_actions):
            assigned_idxs = np.where(assigned_actions == a)[0]
            if assigned_idxs.size > 0:
                pay_ins = np.array([ps[a] @ accepted_contracts[i] for i in assigned_idxs])
                costs[a] = max(pay_ins.min(), 0.0)
            else:
                costs[a] = 0.0

    # Final safety: clip ps and costs
    ps = np.clip(ps, 0, None)
    ps_sum = ps.sum(axis=1, keepdims=True)
    ps_sum[ps_sum < 1e-12] = 1.0
    ps = ps / ps_sum
    costs = np.clip(costs, 0, None)

    agent_setting = np.hstack([ps, costs[:, None]])
    return agent_setting
```
