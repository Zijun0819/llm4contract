```python
import numpy as np
from sklearn.cluster import AgglomerativeClustering

def agent_solver(v: np.ndarray, content: list[dict]) -> np.ndarray:
    """
    Infer a valid agent setting matrix (actions x [probabilities over 5 outcomes + cost])
    that explains all historical interactions under IR and IC constraints.

    Args:
        v: np.ndarray of shape (5,), principal's reward vector for 5 outcomes.
        content: list of dicts, each with keys 'Contract' (list of 5 float payments),
                 'Principal Utility' (float), and 'Agent Action' (1 or -1).

    Returns:
        np.ndarray of shape (n_actions, 6), rows are [p1,...,p5,cost]
    """
    m = v.shape[0]  # number of outcomes (expected 5)

    # Separate accepted and rejected logs
    accepted_logs = [log for log in content if log['Agent Action'] == 1]
    rejected_logs = [log for log in content if log['Agent Action'] == -1]

    # If no accepted logs, return trivial uniform distribution with zero cost
    if not accepted_logs:
        p_uniform = np.ones(m) / m
        return np.array([np.append(p_uniform, 0.0)])

    accepted_contracts = np.array([log['Contract'] for log in accepted_logs])
    rejected_contracts = np.array([log['Contract'] for log in rejected_logs]) if rejected_logs else np.empty((0, m))

    # Adaptive clustering of accepted contracts by their payment vectors
    max_clusters = min(10, len(accepted_contracts))
    threshold = 0.045  # max allowed avg cluster radius (Euclidean norm)
    best_labels = None
    best_n_clusters = 1
    best_centers = None

    for n_clusters in range(1, max_clusters + 1):
        if n_clusters == 1:
            labels = np.zeros(len(accepted_contracts), dtype=int)
        else:
            clustering = AgglomerativeClustering(n_clusters=n_clusters)
            labels = clustering.fit_predict(accepted_contracts)

        centers = np.zeros((n_clusters, m))
        max_avg_dist = 0.0
        for i in range(n_clusters):
            cluster_points = accepted_contracts[labels == i]
            center = cluster_points.mean(axis=0)
            centers[i] = center
            avg_dist = np.mean(np.linalg.norm(cluster_points - center, axis=1))
            if avg_dist > max_avg_dist:
                max_avg_dist = avg_dist

        if max_avg_dist <= threshold:
            best_labels = labels
            best_n_clusters = n_clusters
            best_centers = centers
            break

    if best_centers is None:
        # fallback to max_clusters clustering
        if max_clusters == 1:
            best_labels = np.zeros(len(accepted_contracts), dtype=int)
            best_n_clusters = 1
            best_centers = accepted_contracts.mean(axis=0, keepdims=True)
        else:
            clustering = AgglomerativeClustering(n_clusters=max_clusters)
            best_labels = clustering.fit_predict(accepted_contracts)
            best_n_clusters = max_clusters
            best_centers = np.zeros((best_n_clusters, m))
            for i in range(best_n_clusters):
                best_centers[i] = accepted_contracts[best_labels == i].mean(axis=0)

    # Normalize cluster centers to probability distributions over outcomes
    eps = 1e-14
    ps = np.maximum(best_centers, 0)
    row_sums = ps.sum(axis=1, keepdims=True)
    row_sums[row_sums < eps] = 1.0  # avoid division by zero
    ps /= row_sums

    # Assign accepted contracts to closest cluster center by Euclidean distance
    dist_to_centers = np.linalg.norm(accepted_contracts[:, None, :] - best_centers[None, :, :], axis=2)
    assigned_actions = dist_to_centers.argmin(axis=1)

    # Compute costs from IR constraints (agent rationality on accepted contracts)
    # cost_a <= min_i (p_a @ w_i) for accepted contracts i assigned to a
    costs = np.zeros(best_n_clusters)
    for a in range(best_n_clusters):
        idxs = np.where(assigned_actions == a)[0]
        if idxs.size > 0:
            payins = np.array([ps[a] @ accepted_contracts[i] for i in idxs])
            costs[a] = max(0.0, payins.min())
        else:
            costs[a] = 0.0  # no accepted contracts assigned, start at zero cost

    # Enforce IC constraints from rejected contracts:
    # For each rejected contract w_r, agent utility < 0 for all actions a:
    # cost_a > p_a @ w_r for all a and w_r
    if rejected_contracts.shape[0] > 0:
        rej_utils = ps @ rejected_contracts.T  # shape (actions, rejected_count)
        max_rej_util = rej_utils.max(axis=1)  # max over rejected contracts for each action
        # Add margin proportional to scale for strict inequality
        margin = np.maximum(1e-7, 1e-4 * np.maximum(1.0, max_rej_util))
        costs = np.maximum(costs, max_rej_util + margin)

    # Ensure costs non-negative (numerical safety)
    costs = np.maximum(costs, 0.0)

    # Normalize ps rows again to ensure sum to 1 (numerical safety)
    ps = np.clip(ps, 0, None)
    row_sums = ps.sum(axis=1, keepdims=True)
    row_sums[row_sums < eps] = 1.0
    ps /= row_sums

    # Assemble agent setting matrix: [p1,...,p5, cost]
    agent_setting = np.hstack([ps, costs.reshape(-1, 1)])

    return agent_setting
```
