```python
import numpy as np
from scipy.optimize import linprog
from sklearn.cluster import DBSCAN

def agent_solver_v2(v: np.ndarray, content: list[dict]) -> np.ndarray:
    """
    Infer a valid agent setting matrix from historical logs with contracts, principal utilities,
    and agent actions. This version improves IC enforcement, handles noise by nearest cluster assignment,
    and adds margin in costs to ensure rejection consistency.

    Args:
        v (np.ndarray): Principal's reward vector for 5 outcomes (shape (5,))
        content (list[dict]): Historical logs, each dict with keys:
            - 'Contract': 5-dim payment vector
            - 'Principal Utility': scalar utility (0 if rejected)
            - 'Agent Action': 1 (accept) or -1 (reject)

    Returns:
        np.ndarray: n_actions x 6 matrix, each row: [p(outcomes), cost]
            - p(outcomes): 5-dim probability vector summing to 1
            - cost: non-negative scalar cost of the action
    """
    contracts = np.array([log['Contract'] for log in content])  # (L,5)
    principal_utils = np.array([log['Principal Utility'] for log in content])  # (L,)
    agent_actions = np.array([log['Agent Action'] for log in content])  # (L,)
    L, m = contracts.shape

    accepted_idx = np.where(agent_actions == 1)[0]
    rejected_idx = np.where(agent_actions == -1)[0]

    if len(accepted_idx) == 0:
        uniform_p = np.ones(m) / m
        return np.hstack([uniform_p.reshape(1, -1), np.array([[0.0]])])

    candidate_ps = []
    for i in accepted_idx:
        w = contracts[i]
        u = principal_utils[i]
        A_eq = np.vstack([np.ones(m), v - w])
        b_eq = np.array([1.0, u])
        bounds = [(0, 1)] * m

        res = linprog(c=np.zeros(m), A_eq=A_eq, b_eq=b_eq, bounds=bounds, method='highs')
        if res.success:
            p = res.x
            p = np.clip(p, 0, None)
            s = p.sum()
            if s > 0:
                p /= s
            else:
                p = np.ones(m) / m
            candidate_ps.append(p)
        else:
            candidate_ps.append(np.ones(m) / m)
    candidate_ps = np.array(candidate_ps)

    clustering = DBSCAN(eps=0.15, min_samples=3).fit(candidate_ps)
    labels = clustering.labels_
    unique_labels = set(labels)
    noise_label = -1
    if noise_label in unique_labels:
        unique_labels.remove(noise_label)
    if len(unique_labels) == 0:
        unique_labels = {0}
        labels = np.zeros(len(candidate_ps), dtype=int)

    cluster_centers = []
    for lbl in sorted(unique_labels):
        pts = candidate_ps[labels == lbl]
        center = pts.mean(axis=0)
        center = np.clip(center, 0, None)
        s = center.sum()
        if s > 0:
            center /= s
        else:
            center = np.ones(m) / m
        cluster_centers.append(center)
    cluster_centers = np.array(cluster_centers)
    n_actions = cluster_centers.shape[0]

    accepted_labels = np.full(len(accepted_idx), -1, dtype=int)
    for i, p in enumerate(candidate_ps):
        lbl = labels[i]
        if lbl == noise_label:
            dists = np.linalg.norm(cluster_centers - p, ord=1, axis=1)
            assigned = np.argmin(dists)
            accepted_labels[i] = assigned
        else:
            accepted_labels[i] = sorted(unique_labels).index(lbl)

    costs = np.zeros(n_actions)
    for a in range(n_actions):
        idxs = np.where(accepted_labels == a)[0]
        if len(idxs) == 0:
            costs[a] = 0.0
            continue
        accepted_contracts_a = contracts[accepted_idx[idxs]]
        p_a = cluster_centers[a]
        expected_payments = accepted_contracts_a @ p_a
        costs[a] = max(0.0, expected_payments.min())

    if len(rejected_idx) > 0:
        rejected_contracts = contracts[rejected_idx]
        for a in range(n_actions):
            p_a = cluster_centers[a]
            vals = rejected_contracts @ p_a
            max_val = vals.max()
            if costs[a] <= max_val:
                costs[a] = max_val + 1e-5  # slightly larger margin

    # Enforce IC constraints strictly with iterative adjustments
    max_iters = 30
    tol = 1e-10
    for _ in range(max_iters):
        violated = False
        for i in range(len(accepted_idx)):
            a = accepted_labels[i]
            if a == -1:
                continue
            w_i = contracts[accepted_idx[i]]
            u_a = cluster_centers[a] @ w_i - costs[a]
            for b in range(n_actions):
                if b == a:
                    continue
                u_b = cluster_centers[b] @ w_i - costs[b]
                diff = u_b - u_a
                if diff > tol:
                    adjust = diff / 2
                    new_cost_a = max(costs[a] - adjust, 0.0)
                    new_cost_b = costs[b] + adjust
                    if abs(new_cost_a - costs[a]) > tol or abs(new_cost_b - costs[b]) > tol:
                        costs[a] = new_cost_a
                        costs[b] = new_cost_b
                        violated = True
        if not violated:
            break

    # Enforce IR constraints strictly for accepted logs
    for _ in range(20):
        violated = False
        for i in range(len(accepted_idx)):
            a = accepted_labels[i]
            if a == -1:
                continue
            w_i = contracts[accepted_idx[i]]
            u = cluster_centers[a] @ w_i - costs[a]
            if u < -tol:
                costs[a] = max(costs[a] + u, 0.0)
                violated = True
        if not violated:
            break

    # Final normalization of cluster centers
    for a in range(n_actions):
        p = cluster_centers[a]
        p = np.clip(p, 0, None)
        s = p.sum()
        if s > 0:
            cluster_centers[a] = p / s
        else:
            cluster_centers[a] = np.ones(m) / m

    costs = np.clip(costs, 0, None)

    agent_setting = np.hstack([cluster_centers, costs.reshape(-1, 1)])
    return agent_setting
```
