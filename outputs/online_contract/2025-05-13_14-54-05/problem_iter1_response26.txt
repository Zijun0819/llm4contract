```python
import numpy as np
import pandas as pd
from scipy.optimize import linprog
from sklearn.cluster import AgglomerativeClustering


def agent_solver_v2(v: np.ndarray, content: list[dict]) -> np.ndarray:
    """
    Infers a valid agent setting matrix (n_actions x 6) given principal's reward vector v and historical logs.
    Each row: [p_1, ..., p_5, cost], where p_i is outcome probability and cost >= 0.

    Approach:
    - Extract contracts and agent actions from logs.
    - For accepted contracts, solve LP to find plausible (p, cost) pairs explaining acceptance (agent EU >= 0).
    - Cluster these (p) distributions with a hierarchical method to allow adaptive n.
    - For each cluster (action), estimate cost as minimal cost consistent with acceptance and rejection logs.
    - Enforce IR and IC constraints via LP feasibility checks, adjusting costs upward if needed.
    """
    m_outcomes = v.shape[0]
    L = len(content)

    # Parse logs into arrays for convenience
    contracts = np.array([log['Contract'] for log in content])  # shape (L,5)
    agent_actions = np.array([log['Agent Action'] for log in content])  # shape (L,)
    principal_utils = np.array([log['Principal Utility'] for log in content])  # shape (L,)

    # Step 1: For accepted logs, infer candidate outcome distributions p and agent costs c:
    # Solve LP per accepted contract:
    # Variables: p in R^5 (probabilities), cost c >= 0
    # Constraints:
    #   sum(p) = 1
    #   p @ v - c >= 0 (agent acceptance)
    #   c = p @ wage - agent utility >= 0
    # Since agent utility >=0 for acceptance, estimate cost from p @ wage

    accepted_idx = np.where(agent_actions == 1)[0]
    rejected_idx = np.where(agent_actions == -1)[0]

    candidate_ps = []
    candidate_costs = []

    for i in accepted_idx:
        wage = contracts[i]  # payment vector
        # LP to find p: min ||p - uniform||, s.t sum p =1, p @ wage >= cost
        # cost unknown, but agent utility = p @ wage - cost >=0 => cost <= p @ wage
        # We set cost = p @ wage - agent_utility >= 0, but agent utility unknown, only acceptance known.

        # To get a plausible p, solve LP:
        # Variables: p in R^5
        # Constraints:
        #   sum p =1
        #   p >=0
        #   p @ wage >= 0  (agent utility >= 0 since accepted)
        # Objective: minimize distance to uniform distribution (or any convex proxy)

        c_lp = np.zeros(m_outcomes)  # objective: minimize distance to uniform
        uniform = np.ones(m_outcomes) / m_outcomes

        # minimize sum |p - uniform|_1 by linearizing
        # but linprog supports only linear objectives; instead minimize sum p_i * 0 + slack variables?
        # For simplicity, just minimize -p @ v to find a p that explains minimum agent cost (maximize p@v)
        # Alternatively, minimize p @ wage (cost to agent), but cost unknown; we want plausible p

        # We attempt to find p with p@wage >= 0 to satisfy acceptance

        # Set up linprog to find feasible p:
        # min 0 (feasibility problem)
        # s.t sum p=1, p>=0, p @ wage >= 0

        A_eq = [np.ones(m_outcomes)]
        b_eq = [1.0]
        A_ub = [-wage]  # -p@wage <= 0 => p@wage >=0
        b_ub = [0.0]
        bounds = [(0.0, 1.0)] * m_outcomes

        res = linprog(c=np.zeros(m_outcomes), A_ub=A_ub, b_ub=b_ub,
                      A_eq=A_eq, b_eq=b_eq, bounds=bounds, method='highs')

        if res.success:
            p_sol = res.x
            # Estimate cost as minimal cost = p@wage - 0 (agent utility >=0)
            agent_cost_est = p_sol @ wage
            candidate_ps.append(p_sol)
            candidate_costs.append(agent_cost_est)
        else:
            # fallback: use uniform distribution, cost = uniform @ wage
            p_sol = uniform
            agent_cost_est = p_sol @ wage
            candidate_ps.append(p_sol)
            candidate_costs.append(agent_cost_est)

    if len(candidate_ps) == 0:
        # no accepted logs, return trivial uniform action with zero cost
        return np.hstack([np.ones((1, m_outcomes)) / m_outcomes, np.zeros((1,1))])

    candidate_ps = np.array(candidate_ps)  # shape (num_accepted,5)
    candidate_costs = np.array(candidate_costs)  # shape (num_accepted,)

    # Step 2: Cluster candidate_ps into adaptive number of actions
    # Use Agglomerative clustering with distance threshold to adapt n_actions
    cluster_model = AgglomerativeClustering(n_clusters=None, distance_threshold=0.15, linkage='ward')
    cluster_labels = cluster_model.fit_predict(candidate_ps)

    n_actions = cluster_labels.max() + 1

    # Step 3: Aggregate clusters to get representative p and costs
    p_clusters = np.zeros((n_actions, m_outcomes))
    cost_clusters = np.zeros(n_actions)

    for a in range(n_actions):
        idxs = np.where(cluster_labels == a)[0]
        ps_a = candidate_ps[idxs]
        costs_a = candidate_costs[idxs]
        # Representative p: centroid (mean), then normalize to sum=1 and nonnegative
        p_mean = np.mean(ps_a, axis=0)
        p_mean = np.clip(p_mean, 0, None)
        if p_mean.sum() == 0:
            p_mean = np.ones(m_outcomes) / m_outcomes
        else:
            p_mean /= p_mean.sum()
        p_clusters[a] = p_mean
        # Cost: conservative max cost among cluster to ensure IR hold
        cost_clusters[a] = max(costs_a.max(), 0)

    # Step 4: Enforce IR constraints (agent utility >=0 on accepted contracts)
    # For each accepted contract i assigned to some action, check if p_clusters[a] @ wage >= cost_clusters[a]
    # If violated, increase cost_clusters[a] downward to minimal feasible

    # Assign each accepted contract to best explaining action (max p@wage - cost)
    assignments = np.full(len(candidate_ps), -1, dtype=int)
    for i, p_cand in enumerate(candidate_ps):
        wage = contracts[accepted_idx[i]]
        utilities = p_clusters @ wage - cost_clusters
        assignments[i] = int(np.argmax(utilities))

    # For each action, recompute minimal cost feasible with accepted contracts assigned
    for a in range(n_actions):
        idxs = np.where(assignments == a)[0]
        if len(idxs) == 0:
            # no assigned contracts, cost=0 minimal
            cost_clusters[a] = 0.0
            continue

        wages_assigned = contracts[accepted_idx[idxs]]  # shape (num_assigned,5)
        p_a = p_clusters[a]

        # Costs must satisfy p_a @ wage >= cost, so cost <= min_i p_a @ wage_i
        costs_candidate = wages_assigned @ p_a  # shape (num_assigned,)
        cost_max = costs_candidate.min()
        cost_clusters[a] = max(cost_clusters[a], 0, cost_max)

    # Step 5: Enforce rejection constraints (agent rejects contracts with negative utility)
    # For each rejected contract j, ensure for all actions a: p_a @ wage_j - cost_a < 0
    # If violated, increase cost_a minimally to maintain rejection

    if len(rejected_idx) > 0:
        wages_rejected = contracts[rejected_idx]  # shape (num_rejected,5)
        for a in range(n_actions):
            p_a = p_clusters[a]
            utilities_rej = wages_rejected @ p_a - cost_clusters[a]
            max_util = utilities_rej.max()
            if max_util >= 0:
                # Increase cost to just above max_util
                cost_clusters[a] += (max_util + 1e-8)

    # Step 6: Final normalization and output
    # Ensure each p sums to 1 and cost >=0
    for a in range(n_actions):
        p = p_clusters[a]
        p = np.clip(p, 0, None)
        if p.sum() == 0:
            p = np.ones(m_outcomes) / m_outcomes
        else:
            p /= p.sum()
        p_clusters[a] = p
        cost_clusters[a] = max(cost_clusters[a], 0)

    agent_setting = np.hstack([p_clusters, cost_clusters[:, None]])
    return agent_setting
```
