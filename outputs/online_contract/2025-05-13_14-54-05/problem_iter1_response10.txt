```python
import numpy as np
import pandas as pd
from scipy.optimize import linprog
from sklearn.cluster import DBSCAN


def agent_solver_v2(v: np.ndarray, content: list[dict]) -> np.ndarray:
    """
    Infer a valid agent setting (actions as outcome distributions + costs) consistent with historical logs.

    Args:
        v: Principal reward vector (length 5).
        content: List of logs, each with keys:
            - 'Contract': 5-dim payment vector
            - 'Principal Utility': scalar utility for principal (0 if agent rejects)
            - 'Agent Action': 1 (accept) or -1 (reject)

    Returns:
        ndarray (n_actions x 6): Each row = [p(outcome_1..5), cost], p sums to 1, cost >= 0.
    """
    m = len(v)
    L = len(content)

    # Extract data arrays for convenience
    contracts = np.array([log['Contract'] for log in content])  # (L, m)
    principal_utils = np.array([log['Principal Utility'] for log in content])  # (L,)
    agent_actions = np.array([log['Agent Action'] for log in content])  # (L,)

    accept_idx = np.where(agent_actions == 1)[0]
    reject_idx = np.where(agent_actions == -1)[0]

    # Step 1: Infer agent outcome distributions for accepted contracts via LP
    # For accepted logs, find p s.t.
    #  sum(p) = 1
    #  p >= 0
    #  p @ w - cost >= 0  => agent accepts contract with expected utility >= 0
    # But cost unknown, so solve p that explains principal utility (p@v - p@w = principal util + cost)
    # Instead, approximate p that maximizes alignment with observed contract payments.

    inferred_ps = []
    for i in accept_idx:
        w = contracts[i]
        u_p = principal_utils[i]
        # Goal: find p s.t. p @ w = cost + agent cost and p @ v - cost = u_p
        # We don't know cost; so just find p with sum=1, p>=0, that explain contract payments best.
        # We solve a feasibility LP: find p with sum=1, p>=0 that matches contract payment pattern.
        # Minimize ||w - p|| to get a plausible distribution (heuristic)
        # Or just solve a LP: maximize p @ w s.t sum(p)=1, p>=0 to get dominant outcome distribution

        c = -w  # maximize p@w => minimize -p@w
        A_eq = [np.ones(m)]
        b_eq = [1]
        bounds = [(0, 1) for _ in range(m)]
        res = linprog(c, A_eq=A_eq, b_eq=b_eq, bounds=bounds, method='highs')
        p = res.x if res.success else np.ones(m) / m
        inferred_ps.append(p)

    if len(inferred_ps) == 0:
        # fallback: single uniform action with zero cost
        return np.hstack([np.ones((1, m)) / m, np.zeros((1, 1))])

    inferred_ps = np.array(inferred_ps)

    # Step 2: Cluster inferred_ps with DBSCAN to find natural agent actions number
    # DBSCAN can find number of clusters adaptively, ignoring noise
    clustering = DBSCAN(eps=0.2, min_samples=3, metric='cosine').fit(inferred_ps)
    labels = clustering.labels_
    unique_labels = set(labels)
    if -1 in unique_labels:  # noise points
        unique_labels.remove(-1)

    if len(unique_labels) == 0:
        # all noise points fallback to one cluster
        unique_labels = {0}
        labels = np.zeros(len(inferred_ps), dtype=int)

    # For each cluster, get centroid (mean p)
    p_clusters = []
    for label in unique_labels:
        cluster_ps = inferred_ps[labels == label]
        centroid = cluster_ps.mean(axis=0)
        centroid /= centroid.sum()
        p_clusters.append(centroid)
    p_clusters = np.array(p_clusters)

    n_actions = len(p_clusters)

    # Step 3: Estimate agent costs using IR and IC constraints

    # Initialize costs vector
    costs = np.zeros(n_actions)

    # Map each accepted log to nearest cluster based on cosine similarity
    def cosine_sim(a, b):
        return np.dot(a, b) / (np.linalg.norm(a) * np.linalg.norm(b) + 1e-12)

    assigned_actions = np.full(L, -1, dtype=int)
    for i in accept_idx:
        p = inferred_ps[np.where(accept_idx == i)[0][0]]
        sims = np.array([cosine_sim(p, c) for c in p_clusters])
        assigned_actions[i] = np.argmax(sims)

    # For each action, estimate cost as min over accepted contracts assigned to it of (p@w - 0)
    # Since agent utility = p@w - cost >=0 => cost <= p@w, cost minimal consistent is cost = min p@w for that action
    for a in range(n_actions):
        idxs = np.where(assigned_actions == a)[0]
        if len(idxs) == 0:
            costs[a] = 0.0
        else:
            p = p_clusters[a]
            contract_ws = contracts[idxs]
            payments = contract_ws @ p  # shape (len(idxs),)
            costs[a] = np.minimum(payments).clip(min=0)

    # Step 4: Ensure rejection consistency: each rejected contract must have utility <0 for all actions
    # agent utility = p@w - cost < 0 for rejected contracts
    # If violated, increase costs to satisfy IR constraints
    if len(reject_idx) > 0:
        contract_ws_rej = contracts[reject_idx]  # (num_rej, m)
        for a in range(n_actions):
            p = p_clusters[a]
            utilities = contract_ws_rej @ p - costs[a]
            viol = utilities >= 0
            if np.any(viol):
                # raise cost to largest violating utility + epsilon
                costs[a] = max(costs[a], np.max(utilities[viol]) + 1e-4)

    # Step 5: Post-process: ensure probabilities sum to 1 and costs >=0
    p_clusters = np.clip(p_clusters, 1e-12, None)
    p_clusters /= p_clusters.sum(axis=1, keepdims=True)
    costs = np.clip(costs, 0, None)

    # Compose final agent setting matrix: [p_0,...,p_4, cost]
    agent_setting = np.hstack([p_clusters, costs[:, None]])
    return agent_setting
```
