```python
import numpy as np
from sklearn.cluster import AgglomerativeClustering
from scipy.optimize import linprog

def agent_solver_v2(v: np.ndarray, content: list[dict]) -> np.ndarray:
    """
    Infer a valid agent setting matrix (actions x [probabilities over 5 outcomes + cost])
    that explains all historical interactions under IR and IC constraints.

    Args:
        v: np.ndarray of shape (5,), principal's reward vector for 5 outcomes.
        content: list of dicts, each with keys 'Contract' (list of 5 float payments),
                 'Principal Utility' (float), and 'Agent Action' (1 or -1).

    Returns:
        np.ndarray of shape (n_actions, 6), rows are [p1,...,p5,cost]
    """
    m = v.shape[0]
    eps_prob = 1e-14

    # Separate accepted and rejected logs
    accepted_logs = [log for log in content if log['Agent Action'] == 1]
    rejected_logs = [log for log in content if log['Agent Action'] == -1]

    # If no accepted logs, return trivial uniform distribution with zero cost
    if not accepted_logs:
        p_uniform = np.ones(m) / m
        return np.array([np.append(p_uniform, 0.0)])

    accepted_contracts = np.array([log['Contract'] for log in accepted_logs])
    n_accepted = len(accepted_contracts)

    # Adaptive clustering of accepted contracts to identify agent actions
    max_clusters = min(10, n_accepted)
    threshold = 0.07  # max average cluster radius (Euclidean)
    best_labels = None
    best_n_clusters = 1
    best_centers = None

    for n_clusters in range(1, max_clusters + 1):
        if n_clusters == 1:
            labels = np.zeros(n_accepted, dtype=int)
        else:
            clustering = AgglomerativeClustering(n_clusters=n_clusters)
            labels = clustering.fit_predict(accepted_contracts)

        centers = np.zeros((n_clusters, m))
        max_avg_dist = 0.0
        for i in range(n_clusters):
            cluster_points = accepted_contracts[labels == i]
            if cluster_points.shape[0] == 0:
                center = np.ones(m) / m
            else:
                center = cluster_points.mean(axis=0)
            centers[i] = center
            if cluster_points.shape[0] > 0:
                avg_dist = np.mean(np.linalg.norm(cluster_points - center, axis=1))
            else:
                avg_dist = 0.0
            if avg_dist > max_avg_dist:
                max_avg_dist = avg_dist

        if max_avg_dist <= threshold:
            best_labels = labels
            best_n_clusters = n_clusters
            best_centers = centers
            break

    # If no clustering met threshold, fallback to clustering with max_clusters
    if best_centers is None:
        if max_clusters == 1:
            best_labels = np.zeros(n_accepted, dtype=int)
            best_n_clusters = 1
            best_centers = accepted_contracts.mean(axis=0, keepdims=True)
        else:
            clustering = AgglomerativeClustering(n_clusters=max_clusters)
            best_labels = clustering.fit_predict(accepted_contracts)
            best_n_clusters = max_clusters
            best_centers = np.zeros((best_n_clusters, m))
            for i in range(best_n_clusters):
                cluster_points = accepted_contracts[best_labels == i]
                if cluster_points.shape[0] == 0:
                    best_centers[i] = np.ones(m) / m
                else:
                    best_centers[i] = cluster_points.mean(axis=0)

    # Normalize cluster centers robustly to probability distributions over outcomes
    ps = []
    for center in best_centers:
        p = np.maximum(center, 0)
        s = p.sum()
        if s > eps_prob:
            p /= s
        else:
            p = np.ones(m) / m
        ps.append(p)
    ps = np.array(ps)  # shape (actions, m)

    # Assign accepted contracts to closest cluster center by Euclidean distance
    dist_to_centers = np.linalg.norm(accepted_contracts[:, None, :] - best_centers[None, :, :], axis=2)
    assigned_actions = dist_to_centers.argmin(axis=1)

    # Compute initial costs from IR constraints:
    # cost_a <= min_{w assigned to a} p_a @ w
    costs = np.zeros(best_n_clusters)
    for a in range(best_n_clusters):
        idxs = np.where(assigned_actions == a)[0]
        if idxs.size > 0:
            pay_ins = np.array([ps[a] @ accepted_contracts[i] for i in idxs])
            costs[a] = pay_ins.min()
        else:
            costs[a] = 0.0

    # Prepare rejected contracts array if any
    if rejected_logs:
        rejected_contracts = np.array([log['Contract'] for log in rejected_logs])
    else:
        rejected_contracts = np.empty((0, m))

    # Enforce IC constraints from rejected contracts via LP:
    # For each rejected contract w_r, agent utility = max_a (p_a @ w_r - cost_a) < 0
    # => cost_a > p_a @ w_r for all a, for that w_r
    # Also keep IR constraints for accepted contracts
    n_actions = best_n_clusters
    n_rej = rejected_contracts.shape[0]
    n_acc = n_accepted

    # Construct constraints:
    # Variables: costs for each action (length n_actions), bounds: cost >= 0
    # IR constraints: cost_a <= p_a @ w_i for each accepted contract i assigned to a
    # => cost_a - p_a @ w_i <= 0
    # IC constraints: cost_a - p_a @ w_r >= margin > 0 for each rejected contract w_r and action a
    # => -cost_a + p_a @ w_r <= -margin

    margin_ir = 1e-8
    margin_ic = 1e-8

    n_constraints = n_acc + n_rej * n_actions
    if n_constraints == 0:
        # No constraints, just return current ps and costs (non-negative)
        costs = np.maximum(costs, 0.0)
        agent_setting = np.hstack([ps, costs.reshape(-1, 1)])
        return agent_setting

    A_ub = np.zeros((n_constraints, n_actions))
    b_ub = np.zeros(n_constraints)

    # IR constraints (cost_a - p_a @ w_i <= -margin_ir)
    # We'll write as: cost_a <= p_a @ w_i - margin_ir
    # So: cost_a - p_a @ w_i <= -margin_ir
    for i in range(n_acc):
        a = assigned_actions[i]
        w_i = accepted_contracts[i]
        val = ps[a] @ w_i
        A_ub[i, a] = 1.0
        b_ub[i] = val - margin_ir

    # IC constraints (-cost_a + p_a @ w_r <= -margin_ic)
    row = n_acc
    for r_idx in range(n_rej):
        w_r = rejected_contracts[r_idx]
        for a in range(n_actions):
            val = ps[a] @ w_r
            A_ub[row, a] = -1.0
            b_ub[row] = -val - margin_ic
            row += 1

    bounds = [(0, None) for _ in range(n_actions)]
    c = np.ones(n_actions)  # minimize sum of costs to keep costs small and feasible

    res = linprog(c=c, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')

    if res.success:
        costs = res.x
    else:
        # Retry with zero margins if infeasible
        margin_ir = 0.0
        margin_ic = 0.0
        for i in range(n_acc):
            a = assigned_actions[i]
            w_i = accepted_contracts[i]
            val = ps[a] @ w_i
            A_ub[i, a] = 1.0
            b_ub[i] = val - margin_ir
        row = n_acc
        for r_idx in range(n_rej):
            w_r = rejected_contracts[r_idx]
            for a in range(n_actions):
                val = ps[a] @ w_r
                A_ub[row, a] = -1.0
                b_ub[row] = -val - margin_ic
                row += 1
        res2 = linprog(c=c, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')
        if res2.success:
            costs = res2.x
        else:
            # Fallback: keep initial costs but ensure non-negative
            costs = np.maximum(costs, 0.0)

    costs = np.maximum(costs, 0.0)

    # Final normalization of ps rows to ensure probability distributions
    ps = np.clip(ps, 0, None)
    row_sums = ps.sum(axis=1, keepdims=True)
    row_sums[row_sums == 0] = 1.0
    ps /= row_sums

    agent_setting = np.hstack([ps, costs.reshape(-1, 1)])

    return agent_setting
```
