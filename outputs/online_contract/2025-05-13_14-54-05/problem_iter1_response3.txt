```python
import numpy as np
from scipy.optimize import linprog
from sklearn.cluster import AgglomerativeClustering


def agent_solver(v: np.ndarray, content: list[dict]) -> np.ndarray:
    """
    Infer a valid agent setting (distribution over outcomes + cost) from historical logs.

    Parameters:
        v: np.ndarray shape (5,) - principal's reward per outcome
        content: list of dicts with keys:
            'Contract': list of 5 payments,
            'Principal Utility': float,
            'Agent Action': 1 (accept) or -1 (reject)

    Returns:
        np.ndarray shape (n_actions, 6):
            first 5 cols: outcome distributions (sum to 1),
            last col: cost (≥0)
    """

    m = len(v)  # number of outcomes
    L = len(content)

    # Extract contracts, utilities, and agent actions
    contracts = np.array([log['Contract'] for log in content])  # shape (L, m)
    principal_utils = np.array([log['Principal Utility'] for log in content])  # shape (L,)
    agent_actions = np.array([log['Agent Action'] for log in content])  # shape (L,)

    # Step 1: Infer candidate outcome distributions p for accepted contracts
    # For each accepted contract, solve LP:
    # find p in simplex s.t. p·w = principal utility + agent cost (unknown),
    # but cost unknown => we approximate p that "explains" contract and utility
    # We use the logic: agent utility = p·w - cost ≥ 0 if accepted,
    # principal utility = v·p - p·w,
    # rearranged: cost = p·w - agent utility ≥ 0
    # We cannot get cost directly but want to find p consistent with contract and principal utility.

    # We'll fix agent utility ≥ 0 since accepted
    # For each accepted contract, we try to find p in simplex maximizing p·v close to principal utility + p·w

    accepted_idx = np.where(agent_actions == 1)[0]
    rejected_idx = np.where(agent_actions == -1)[0]

    candidate_ps = []
    candidate_costs = []

    # We formulate a quadratic problem for each accepted contract to find p:
    # Minimize |v·p - (principal_utility + p·w)|^2 subject to p in simplex
    # But no quadratic solver allowed here; we use linear approx:
    # Instead, try to find p in simplex s.t. principal_utility = v·p - p·w approx

    # We'll solve:
    # p·(v - w) ≈ principal_utility
    # with p ∈ simplex

    # We'll solve a LP minimizing absolute deviation between lhs and principal_utility by splitting into two LPs.

    def find_p(contract, principal_u):
        # We want p·(v - contract) = principal_u with p in simplex
        # Constraints: sum p_i = 1, p_i ≥0
        # Objective: minimize |p·(v - contract) - principal_u|
        # We do two LPs:
        # LP1: p·(v - contract) ≥ principal_u
        # minimize 0 (feasibility)
        # LP2: p·(v - contract) ≤ principal_u
        # minimize 0 (feasibility)
        # Take p with minimal deviation

        c_vec = v - contract  # shape (m,)
        # LP1: p·c_vec ≥ principal_u
        A_ub1 = -c_vec[np.newaxis, :]  # -p·c_vec ≤ -principal_u
        b_ub1 = -np.array([principal_u])
        A_eq = [np.ones(m)]
        b_eq = [1.0]
        bounds = [(0, 1)] * m

        res1 = linprog(c=np.zeros(m), A_ub=A_ub1, b_ub=b_ub1,
                       A_eq=A_eq, b_eq=b_eq, bounds=bounds, method='highs')
        if res1.success:
            p1 = res1.x
            dev1 = abs(p1 @ c_vec - principal_u)
        else:
            p1 = None
            dev1 = np.inf

        # LP2: p·c_vec ≤ principal_u
        A_ub2 = c_vec[np.newaxis, :]  # p·c_vec ≤ principal_u
        b_ub2 = np.array([principal_u])

        res2 = linprog(c=np.zeros(m), A_ub=A_ub2, b_ub=b_ub2,
                       A_eq=A_eq, b_eq=b_eq, bounds=bounds, method='highs')
        if res2.success:
            p2 = res2.x
            dev2 = abs(p2 @ c_vec - principal_u)
        else:
            p2 = None
            dev2 = np.inf

        if dev1 < dev2 and p1 is not None:
            return p1, dev1
        elif p2 is not None:
            return p2, dev2
        else:
            return None, np.inf

    for idx in accepted_idx:
        w = contracts[idx]
        u = principal_utils[idx]
        p, dev = find_p(w, u)
        if p is not None and dev < 1e-3:
            candidate_ps.append(p)

    if len(candidate_ps) == 0:
        # fallback: all accepted contracts => uniform p
        candidate_ps = [np.ones(m) / m]

    candidate_ps = np.array(candidate_ps)  # shape (N_acc, m)

    # Step 2: Cluster candidate_ps to get n_actions representative p's
    # Use AgglomerativeClustering with dynamic number of clusters by threshold
    max_clusters = min(10, len(candidate_ps))
    if len(candidate_ps) == 1:
        p_actions = candidate_ps
    else:
        clustering = AgglomerativeClustering(n_clusters=None, distance_threshold=0.05)
        clustering.fit(candidate_ps)
        labels = clustering.labels_
        n_actions = labels.max() + 1
        p_actions = np.zeros((n_actions, m))
        for k in range(n_actions):
            p_actions[k] = candidate_ps[labels == k].mean(axis=0)

    # Normalize p_actions (numerical stability)
    p_actions = np.clip(p_actions, 0, None)
    p_actions /= p_actions.sum(axis=1, keepdims=True)

    n_actions = p_actions.shape[0]

    # Step 3: Infer costs for each action:
    # IR constraint for accepted contracts:
    # For each contract accepted to action a, agent utility = p_a·w - c_a ≥ 0 => c_a ≤ p_a·w
    # For each contract rejected:
    # For all actions a, agent utility = p_a·w - c_a < 0 => c_a > p_a·w

    # Assign accepted contracts to nearest action by maximizing p_a·w (agent expected wage)
    assigns = np.full(L, -1)
    for i in accepted_idx:
        w = contracts[i]
        # Agent picks action with max expected wage p_a·w
        exp_wages = p_actions @ w
        assigns[i] = np.argmax(exp_wages)

    # Compute upper bounds on costs from accepted contracts (cost ≤ p_a·w)
    cost_ub = np.full(n_actions, np.inf)
    for a in range(n_actions):
        idxs = np.where(assigns == a)[0]
        if len(idxs) > 0:
            p = p_actions[a]
            costs_candidates = p @ contracts[idxs].T  # shape (len(idxs),)
            cost_ub[a] = costs_candidates.min()
        else:
            # No acceptance assigned to this action => no upper bound from acceptances
            cost_ub[a] = np.inf

    # Compute lower bounds on costs from rejected contracts (cost > p_a·w for all rejected w)
    cost_lb = np.zeros(n_actions)
    if len(rejected_idx) > 0:
        w_rej = contracts[rejected_idx]  # shape (num_rej, m)
        # For each action a, lower bound: cost_a > max_{rejected_w} p_a·w
        for a in range(n_actions):
            p = p_actions[a]
            exp_wages_rej = w_rej @ p
            cost_lb[a] = exp_wages_rej.max()
    else:
        cost_lb[:] = 0

    # Final cost satisfies: cost_lb < c ≤ cost_ub, c ≥ 0
    # Choose costs in feasible intervals, if empty, relax constraints slightly

    costs = np.zeros(n_actions)
    for a in range(n_actions):
        lb = max(cost_lb[a] + 1e-5, 0)
        ub = cost_ub[a]
        if lb <= ub:
            costs[a] = (lb + ub) / 2
        else:
            # Infeasible interval, relax by taking max of lb and 0
            costs[a] = lb

    # Step 4: Validate IR and IC constraints
    # IR: For each accepted contract i assigned to a, p_a·w_i - c_a ≥ 0
    for i in accepted_idx:
        a = assigns[i]
        p = p_actions[a]
        w = contracts[i]
        agent_util = p @ w - costs[a]
        if agent_util < -1e-6:
            # Adjust cost down to satisfy IR
            costs[a] = p @ w

    # IC: For each accepted contract i assigned to a, no other action a' gives higher utility
    for i in accepted_idx:
        a = assigns[i]
        w = contracts[i]
        for a2 in range(n_actions):
            if a2 == a:
                continue
            util_a2 = p_actions[a2] @ w - costs[a2]
            util_a = p_actions[a] @ w - costs[a]
            if util_a2 > util_a + 1e-6:
                # Increase cost of a2 to enforce IC: cost_a2 ≥ p_a2·w - util_a
                costs[a2] = max(costs[a2], p_actions[a2] @ w - util_a)

    # Step 5: Ensure rejecting contracts are indeed rejected by all actions
    for i in rejected_idx:
        w = contracts[i]
        for a in range(n_actions):
            util = p_actions[a] @ w - costs[a]
            if util >= 0:
                # Increase cost to force rejection
                costs[a] = max(costs[a], p_actions[a] @ w + 1e-4)

    # Clip costs to ≥0
    costs = np.clip(costs, 0, None)

    # Final agent setting matrix: n_actions x (m + 1)
    agent_setting = np.hstack([p_actions, costs[:, None]])
    return agent_setting
```
