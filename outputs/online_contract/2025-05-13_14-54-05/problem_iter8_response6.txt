```python
import numpy as np
from sklearn.cluster import AgglomerativeClustering

def agent_solver_v2(v: np.ndarray, content: list[dict]) -> np.ndarray:
    """
    Infer a valid agent setting matrix (actions x [probabilities over 5 outcomes + cost])
    that explains all historical interactions under IR and IC constraints.

    Args:
        v: np.ndarray of shape (5,), principal's reward vector for 5 outcomes.
        content: list of dicts, each with keys 'Contract' (list of 5 float payments),
                 'Principal Utility' (float), and 'Agent Action' (1 or -1).

    Returns:
        np.ndarray of shape (n_actions, 6), rows are [p1,...,p5,cost]
    """
    m = v.shape[0]  # number of outcomes (expected 5)

    # Separate accepted and rejected logs
    accepted_logs = [log for log in content if log['Agent Action'] == 1]
    rejected_logs = [log for log in content if log['Agent Action'] == -1]

    # If no accepted logs, return trivial uniform distribution with zero cost
    if not accepted_logs:
        p_uniform = np.ones(m) / m
        return np.array([np.append(p_uniform, 0.0)])

    accepted_contracts = np.array([log['Contract'] for log in accepted_logs])
    n_accepted = len(accepted_contracts)

    # Adaptive clustering parameters
    max_clusters = min(10, n_accepted)
    # Start with a tight threshold, relax if no clusterings found feasible
    base_threshold = 0.025
    threshold_step = 0.01
    max_threshold = 0.1

    best_solution = None  # Tuple (agent_setting, n_clusters)
    best_n_clusters = None

    # Try clustering with increasing threshold and cluster counts
    threshold = base_threshold
    while threshold <= max_threshold and best_solution is None:
        for n_clusters in range(1, max_clusters + 1):
            if n_clusters == 1:
                labels = np.zeros(n_accepted, dtype=int)
                centers = accepted_contracts.mean(axis=0, keepdims=True)
            else:
                clustering = AgglomerativeClustering(n_clusters=n_clusters)
                labels = clustering.fit_predict(accepted_contracts)
                centers = np.zeros((n_clusters, m))
                for i in range(n_clusters):
                    cluster_points = accepted_contracts[labels == i]
                    if cluster_points.shape[0] == 0:
                        centers[i] = np.ones(m) / m
                    else:
                        centers[i] = cluster_points.mean(axis=0)

            # Compute max average cluster radius to check threshold
            max_avg_dist = 0.0
            for i in range(n_clusters):
                cluster_points = accepted_contracts[labels == i]
                if cluster_points.shape[0] == 0:
                    avg_dist = 0.0
                else:
                    avg_dist = np.mean(np.linalg.norm(cluster_points - centers[i], axis=1))
                if avg_dist > max_avg_dist:
                    max_avg_dist = avg_dist
            if max_avg_dist > threshold:
                continue  # too loose clusters, try smaller n_clusters or larger threshold

            # Normalize cluster centers to probability distributions over outcomes
            ps = []
            eps = 1e-14
            for center in centers:
                p = np.maximum(center, 0)
                s = p.sum()
                if s > eps:
                    p /= s
                else:
                    p = np.ones(m) / m
                ps.append(p)
            ps = np.array(ps)  # shape (n_clusters, m)

            # Assign accepted contracts to closest cluster center by Euclidean distance
            dist_to_centers = np.linalg.norm(accepted_contracts[:, None, :] - centers[None, :, :], axis=2)
            assigned_actions = dist_to_centers.argmin(axis=1)

            # Compute cost per action from IR constraints:
            # cost_a <= min_{w assigned to a} p_a @ w
            costs = np.zeros(n_clusters)
            feasible = True
            for a in range(n_clusters):
                idxs = np.where(assigned_actions == a)[0]
                if idxs.size > 0:
                    pay_ins = np.array([ps[a] @ accepted_contracts[i] for i in idxs])
                    min_payin = pay_ins.min()
                    if min_payin < 0:
                        # Negative agent utility on accepted contract impossible, reject
                        feasible = False
                        break
                    costs[a] = min_payin
                else:
                    # No accepted contract assigned to this action, set cost zero tentatively
                    costs[a] = 0.0
            if not feasible:
                continue

            # Enforce IC constraints from rejected contracts:
            # For each rejected contract w: max_a (p_a @ w - cost_a) < 0
            if rejected_logs:
                rejected_contracts = np.array([log['Contract'] for log in rejected_logs])
                rej_utilities = ps @ rejected_contracts.T  # shape (n_clusters, n_rejected)
                # For each action a, cost_a > max rejected p_a @ w
                min_costs_from_rej = rej_utilities.max(axis=1) + 1e-10  # tiny margin for strict inequality

                # Check if costs satisfy this:
                if np.any(costs <= min_costs_from_rej):
                    # Increase costs to satisfy IC constraints
                    costs = np.maximum(costs, min_costs_from_rej)

            # Ensure costs non-negative and consistent with IR
            costs = np.maximum(costs, 0.0)

            # Verify all accepted contracts satisfy IR: p_a @ w - cost_a >= 0
            for i, w in enumerate(accepted_contracts):
                a = assigned_actions[i]
                if (ps[a] @ w - costs[a]) < -1e-12:
                    feasible = False
                    break
            if not feasible:
                continue

            # Verify all rejected contracts satisfy IC: max_a (p_a @ w - cost_a) < 0
            if rejected_logs:
                for w in rejected_contracts:
                    util = ps @ w - costs
                    if np.max(util) >= -1e-12:
                        feasible = False
                        break
                if not feasible:
                    continue

            # Found a feasible solution
            best_solution = np.hstack([ps, costs.reshape(-1, 1)])
            best_n_clusters = n_clusters
            break

        threshold += threshold_step

    # If no feasible solution found, fallback to single action uniform distribution zero cost
    if best_solution is None:
        p_uniform = np.ones(m) / m
        best_solution = np.array([np.append(p_uniform, 0.0)])
        best_n_clusters = 1

    return best_solution
```
