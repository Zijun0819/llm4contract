```python
import numpy as np
from sklearn.cluster import DBSCAN
from scipy.optimize import linprog

def agent_solver_v2(v: np.ndarray, content: list[dict]) -> np.ndarray:
    """
    Infer a valid agent setting matrix from historical logs with contracts, principal utilities,
    and agent actions. This improved version:
      - Infers candidate agent outcome distributions (p) per accepted contract via feasibility LP,
      - Clusters inferred p's with DBSCAN adaptively handling noise,
      - Assigns accepted contracts to clusters (agent actions),
      - Initializes costs from IR constraints,
      - Enforces IC constraints from rejected contracts early,
      - Iteratively refines costs to satisfy IR and IC constraints robustly,
      - Returns n_actions x (5 + 1) matrix: each row [p(outcomes), cost].
    Args:
        v: np.ndarray, shape (5,), principal's reward vector for 5 outcomes.
        content: list of dicts, each with keys 'Contract' (list of 5 floats),
                 'Principal Utility' (float), and 'Agent Action' (1 or -1).
    Returns:
        np.ndarray of shape (n_actions, 6), rows are [p1,...,p5,cost].
    """
    contracts = np.array([log['Contract'] for log in content])  # (L,5)
    principal_utils = np.array([log['Principal Utility'] for log in content])  # (L,)
    actions = np.array([log['Agent Action'] for log in content])  # (L,)
    L, m = contracts.shape

    accepted_idx = np.where(actions == 1)[0]
    rejected_idx = np.where(actions == -1)[0]

    # If no accepted contracts, fallback uniform distribution with zero cost
    if len(accepted_idx) == 0:
        uniform_p = np.ones(m) / m
        return np.hstack([uniform_p.reshape(1, -1), np.array([[0.0]])])

    # Step 1: Infer candidate p for each accepted contract by solving feasibility LP:
    # sum(p) = 1, p >= 0, p@(v - w) = principal_utility
    candidate_ps = []
    accepted_indices_for_ps = []
    tol = 1e-8
    for i in accepted_idx:
        w = contracts[i]
        u = principal_utils[i]

        # Equality constraints matrix and rhs
        A_eq = np.vstack([np.ones(m), v - w])
        b_eq = np.array([1.0, u])
        bounds = [(0, 1)] * m

        res = linprog(c=np.zeros(m), A_eq=A_eq, b_eq=b_eq, bounds=bounds, method='highs')
        if not res.success:
            # Relax equalities to inequalities Â±tol
            A_ub = np.vstack([
                np.ones(m),
                -np.ones(m),
                v - w,
                -(v - w)
            ])
            b_ub = np.array([1.0 + tol, -1.0 + tol, u + tol, -u + tol])
            res = linprog(c=np.zeros(m), A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')
            if not res.success:
                # Skip infeasible accepted contract
                continue

        p = res.x
        p = np.clip(p, 0, None)
        s = p.sum()
        if s > 0:
            p /= s
        else:
            p = np.ones(m) / m
        candidate_ps.append(p)
        accepted_indices_for_ps.append(i)

    if len(candidate_ps) == 0:
        # fallback uniform p, zero cost
        uniform_p = np.ones(m) / m
        return np.hstack([uniform_p.reshape(1, -1), np.array([[0.0]])])

    candidate_ps = np.array(candidate_ps)
    accepted_indices_for_ps = np.array(accepted_indices_for_ps)

    # Step 2: Cluster candidate_ps with DBSCAN adaptively to find agent actions
    # Adaptive eps search to reduce noise fraction
    eps = 0.15
    min_samples = 3
    max_eps = 0.5
    while True:
        clustering = DBSCAN(eps=eps, min_samples=min_samples).fit(candidate_ps)
        labels = clustering.labels_
        noise_fraction = np.mean(labels == -1)
        if noise_fraction <= 0.1 or eps >= max_eps:
            break
        eps = min(eps * 1.5, max_eps)

    unique_labels = set(labels)
    if -1 in unique_labels:
        unique_labels.remove(-1)

    if len(unique_labels) == 0:
        # No clusters found, treat all as one cluster
        unique_labels = {0}
        labels = np.zeros(len(candidate_ps), dtype=int)

    # Assign noise points to nearest cluster center by Euclidean distance
    cluster_centers = []
    for lbl in sorted(unique_labels):
        members = candidate_ps[labels == lbl]
        center = members.mean(axis=0)
        center = np.clip(center, 0, None)
        s = center.sum()
        if s > 0:
            center /= s
        else:
            center = np.ones(m) / m
        cluster_centers.append(center)
    cluster_centers = np.array(cluster_centers)
    n_actions = cluster_centers.shape[0]

    noise_mask = (labels == -1)
    if np.any(noise_mask):
        noise_points = candidate_ps[noise_mask]
        from scipy.spatial.distance import cdist
        dist_noise_to_centers = cdist(noise_points, cluster_centers)
        nearest_clusters = dist_noise_to_centers.argmin(axis=1)
        # Assign noise points to clusters and update cluster centers
        for idx, cluster_idx in enumerate(nearest_clusters):
            cluster_centers[cluster_idx] = (
                (cluster_centers[cluster_idx] + noise_points[idx]) / 2
            )
            # Re-normalize
            p = cluster_centers[cluster_idx]
            p = np.clip(p, 0, None)
            s = p.sum()
            if s > 0:
                cluster_centers[cluster_idx] = p / s
            else:
                cluster_centers[cluster_idx] = np.ones(m) / m

    # Step 3: Assign each accepted contract to cluster by label
    accepted_labels = np.full(len(accepted_idx), -1, dtype=int)
    label_to_idx = {lbl: idx for idx, lbl in enumerate(sorted(unique_labels))}
    for i, lbl in enumerate(labels):
        if lbl == -1:
            continue
        cluster_idx = label_to_idx[lbl]
        accepted_labels[np.where(accepted_idx == accepted_indices_for_ps[i])[0][0]] = cluster_idx

    # Step 4: Initialize costs per action from IR constraints:
    # cost_a <= p_a @ w for all accepted contracts w assigned to a
    costs = np.zeros(n_actions)
    for a in range(n_actions):
        assigned_accepted = np.where(accepted_labels == a)[0]
        if len(assigned_accepted) == 0:
            costs[a] = 0.0
            continue
        p_a = cluster_centers[a]
        assigned_contracts = contracts[accepted_idx[assigned_accepted]]
        upper_bounds = assigned_contracts @ p_a
        costs[a] = max(0.0, upper_bounds.min())

    # Step 5: Enforce rejection consistency (IC):
    # For each rejected contract w, agent utility < 0 for all actions:
    # p_a @ w - cost_a < 0 => cost_a > p_a @ w
    if len(rejected_idx) > 0:
        rejected_contracts = contracts[rejected_idx]
        epsilon = 1e-6
        for a in range(n_actions):
            p_a = cluster_centers[a]
            vals = rejected_contracts @ p_a
            max_rej_val = vals.max()
            if costs[a] <= max_rej_val:
                costs[a] = max_rej_val + epsilon

    # Step 6: Iteratively refine costs to satisfy IR and IC constraints robustly
    max_iter = 30
    for _ in range(max_iter):
        updated = False
        # IR check: accepted contracts utility >= 0
        for i, a in enumerate(accepted_labels):
            if a == -1:
                continue
            p_a = cluster_centers[a]
            cost_a = costs[a]
            w = contracts[accepted_idx[i]]
            util = p_a @ w - cost_a
            if util < -1e-14:
                new_cost = p_a @ w
                if new_cost > cost_a + 1e-14:
                    costs[a] = new_cost
                    updated = True

        # IC check: rejected contracts utility < 0 for all actions
        for i in rejected_idx:
            w = contracts[i]
            for a in range(n_actions):
                p_a = cluster_centers[a]
                cost_a = costs[a]
                util = p_a @ w - cost_a
                if util >= -1e-14:
                    new_cost = p_a @ w + 1e-6
                    if new_cost > cost_a + 1e-14:
                        costs[a] = new_cost
                        updated = True

        if not updated:
            break

    # Step 7: Final normalization and safety clip of cluster centers
    for a in range(n_actions):
        p = cluster_centers[a]
        p = np.clip(p, 0, None)
        s = p.sum()
        if s > 0:
            cluster_centers[a] = p / s
        else:
            cluster_centers[a] = np.ones(m) / m

    # Ensure costs non-negative
    costs = np.maximum(costs, 0.0)

    agent_setting = np.hstack([cluster_centers, costs.reshape(-1, 1)])
    return agent_setting
```
