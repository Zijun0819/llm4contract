```python
import numpy as np
import pandas as pd
from scipy.optimize import linprog
from sklearn.cluster import AgglomerativeClustering, KMeans

def agent_solver(v: np.ndarray, content: pd.DataFrame) -> np.ndarray:
    """
    Infer a valid agent setting matrix (actions x [probabilities over outcomes + cost])
    explaining the historical principal-agent logs under IR and IC constraints.
    
    Parameters:
    - v: (5,) array, principal's reward vector for outcomes.
    - content: DataFrame with columns:
       'Contract': list of 5 payments,
       'Principal Utility': scalar,
       'Agent Action': 1 (accept) or -1 (reject).
       
    Returns:
    - agent_setting: (n_actions, 6) array where each row is
      [p_1,...,p_5 (sum to 1), cost >=0]
    """
    m = v.shape[0]
    logs = content.copy()
    
    # Separate accepted and rejected logs
    accepted = logs[logs['Agent Action'] == 1].reset_index(drop=True)
    rejected = logs[logs['Agent Action'] == -1].reset_index(drop=True)
    
    # Step 1: Infer candidate outcome distributions 'p' for accepted contracts
    # For accepted contracts, agent utility >= 0:
    # agent utility = E_p[w] - cost >= 0
    # principal utility = E_v[w] - E_p[w] = principal_utility from logs.
    # => E_p[w] = E_v[w] - principal_utility
    
    # For each accepted contract:
    # solve for p:
    #   p >= 0, sum p = 1
    #   E_p[w] = scalar (fixed)
    # Minimize ||p - uniform|| to find a plausible distribution
    
    candidate_ps = []
    utilities_p = []  # E_p[w] from above
    W_acc = []
    for i, row in accepted.iterrows():
        w = np.array(row['Contract'])
        pu = row['Principal Utility']  # = E_v[w] - E_p[w]
        Evw = v @ w
        Epw = Evw - pu  # E_p[w]
        W_acc.append(w)
        
        # Solve LP:
        # find p:  sum p =1, p >=0, v.w.p = Epw
        # Minimize ||p - u||_2 where u=uniform
        # Use linprog to find feasible p with equality constraints
        # We'll use LP by converting to two inequalities for equality of E_p[w]
        
        # Objective: minimize distance to uniform (approx) => use LP with auxiliary variables
        # Since linprog is linear, minimize c^T p with c = 0 (any feasible p)
        # We first find a feasible point p0 with constraints:
        # sum p = 1
        # p >=0
        # w.p = Epw
        
        # We'll solve with scipy linprog with these 2 equality constraints:
        # To handle equality of w.p=Epw, turn into two inequalities: w.p <= Epw + tol, w.p >= Epw - tol
        tol = 1e-8
        A_eq = [np.ones(m)]
        b_eq = [1.0]
        bounds = [(0,1)]*m
        # We'll solve feasibility with w.p in [Epw - tol, Epw + tol]
        
        # linprog does not support inequality constraints directly, so we create A_ub, b_ub:
        A_ub = np.vstack([w, -w])
        b_ub = np.array([Epw + tol, -Epw + tol])
        
        # We want feasible p minimizing sum(|p - 1/m|) approx -> minimize c^T p with c=0
        c = np.zeros(m)
        res = linprog(c, A_ub=A_ub, b_ub=b_ub, A_eq=A_eq, b_eq=b_eq,
                      bounds=bounds, method='highs')
        if res.success:
            candidate_ps.append(res.x)
            utilities_p.append(Epw)
        else:
            # fallback: project uniform distribution onto constraints
            # uniform p
            p0 = np.ones(m)/m
            # project onto constraints sum p=1, w.p=Epw with nonnegativity approx
            # Simple heuristic: adjust p0 linearly:
            # Solve for alpha, beta: p = p0 + alpha*1 + beta*w, s.t sum p=1, w.p=Epw
            # sum p0 + alpha*m + beta*sum w =1 => alpha*m + beta*sum w =0
            # w.p0 + alpha*sum w + beta*sum w^2 = Epw
            # system:
            S_w = w.sum()
            S_w2 = (w**2).sum()
            A = np.array([[m, S_w],
                          [S_w, S_w2]])
            b = np.array([1 - p0.sum(),
                          Epw - w @ p0])
            try:
                sol = np.linalg.solve(A, b)
                p_proj = p0 + sol[0]*np.ones(m) + sol[1]*w
                p_proj = np.clip(p_proj, 0, 1)
                p_proj /= p_proj.sum()
                candidate_ps.append(p_proj)
                utilities_p.append(Epw)
            except:
                # if failed, skip
                pass
    
    if len(candidate_ps) == 0:
        raise ValueError("No feasible accepted contract distributions found.")
    
    candidate_ps = np.array(candidate_ps)
    utilities_p = np.array(utilities_p)
    W_acc = np.array(W_acc)
    
    # Step 2: Cluster candidate_ps with AgglomerativeClustering to adaptively select n actions
    # Choose n actions between 3 and 10, pick the n minimizing inertia-like metric (approx)
    # We'll try n=3..8 clusters and pick the best silhouette score
    from sklearn.metrics import silhouette_score
    best_n = 3
    best_score = -1
    best_labels = None
    best_model = None
    for k in range(3,9):
        cluster = AgglomerativeClustering(n_clusters=k)
        labels = cluster.fit_predict(candidate_ps)
        if len(set(labels))==1:
            continue
        try:
            score = silhouette_score(candidate_ps, labels)
            if score > best_score:
                best_score = score
                best_n = k
                best_labels = labels
                best_model = cluster
        except:
            continue
    # fallback
    if best_labels is None:
        best_labels = np.zeros(candidate_ps.shape[0], dtype=int)
        best_n = 1
    
    n_actions = best_n
    
    # Step 3: Determine action representatives: mean p of each cluster
    p_actions = np.zeros((n_actions, m))
    for aid in range(n_actions):
        members = candidate_ps[best_labels == aid]
        if members.shape[0] == 0:
            p_actions[aid] = np.ones(m)/m
        else:
            p_actions[aid] = members.mean(axis=0)
            # normalize to sum to 1 exactly
            p_actions[aid] = np.clip(p_actions[aid], 0, None)
            if p_actions[aid].sum() == 0:
                p_actions[aid] = np.ones(m)/m
            else:
                p_actions[aid] /= p_actions[aid].sum()
    
    # Step 4: Infer costs c for each action (non-negative)
    # For an accepted contract w_i assigned to action a:
    #   agent utility >= 0: p_a.dot(w_i) - c_a >= 0  =>  c_a <= p_a.dot(w_i)
    # For a rejected contract w_j:
    #   agent utility < 0 for all actions: p_a.dot(w_j) - c_a < 0  => c_a > p_a.dot(w_j)
    # 
    # We optimize costs c_a >=0 to satisfy all above constraints:
    # c_a <= min_{accepted assigned a} p_a.dot(w_i)
    # c_a > max_{rejected} p_a.dot(w_j)
    #
    # Also enforce IR: c_a >=0
    
    # Step 5: Assign each accepted contract to closest action by p_a.dot(w_i)
    assigns_acc = np.zeros(len(accepted), dtype=int)
    W_acc = np.array([np.array(w) for w in accepted['Contract']])
    for i, w_i in enumerate(W_acc):
        # pick action maximizing p_a.dot(w_i)
        val = p_actions @ w_i
        assigns_acc[i] = np.argmax(val)
    
    # Step 6: Compute bounds on costs
    c_upper = np.full(n_actions, np.inf)
    c_lower = np.zeros(n_actions)
    # Accepted constraints (upper bound)
    for a in range(n_actions):
        inds = np.where(assigns_acc == a)[0]
        if len(inds) > 0:
            vals = [p_actions[a].dot(W_acc[i]) for i in inds]
            c_upper[a] = min(vals)
        else:
            c_upper[a] = np.inf  # no accepted contracts assigned
    
    # Rejected constraints (lower bound)
    if len(rejected) > 0:
        W_rej = np.array([np.array(w) for w in rejected['Contract']])
        for a in range(n_actions):
            vals = p_actions[a].dot(W_rej.T)
            c_lower[a] = max(vals) + 1e-8  # strictly greater than max for rejection
    
    # Step 7: Combine bounds with feasibility check
    # feasibility: c_lower[a] <= c_upper[a], c_lower[a]>=0
    c_final = np.zeros(n_actions)
    for a in range(n_actions):
        low = max(c_lower[a], 0)
        up = c_upper[a]
        if low <= up:
            # pick cost as midpoint for numerical stability (or low if infinity)
            if np.isfinite(up):
                c_final[a] = (low + up)/2
            else:
                c_final[a] = low
        else:
            # infeasible: relax rejection constraints slightly (lower c_lower)
            c_final[a] = low  # best effort
    
    # Step 8: Check IR for all accepted contracts and IC for rejection
    # If violated, push c_final up minimally to satisfy IR for accepted
    for a in range(n_actions):
        inds = np.where(assigns_acc == a)[0]
        if len(inds) > 0:
            vals = np.array([p_actions[a].dot(W_acc[i]) for i in inds])
            min_utility = vals.min() - c_final[a]
            if min_utility < 0:
                c_final[a] = vals.min()
    
    # Step 9: Normalize p_actions rows to sum 1 and non-negative
    p_actions = np.clip(p_actions, 1e-12, None)
    p_actions /= p_actions.sum(axis=1, keepdims=True)
    
    # Step 10: Construct final agent_setting matrix: [p_1,...p_5, cost]
    agent_setting = np.hstack([p_actions, c_final[:, None]])
    
    return agent_setting
```
