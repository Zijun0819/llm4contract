```python
import numpy as np
import pandas as pd
from scipy.optimize import linprog, minimize
from sklearn.cluster import DBSCAN


def agent_solver_v2(v: np.ndarray, content: pd.DataFrame) -> np.ndarray:
    """
    Infer a valid agent setting matrix from historical logs.

    Args:
        v: Principal value vector for 5 outcomes, shape (5,)
        content: pd.DataFrame with columns ['Contract', 'Principal Utility', 'Agent Action']

    Returns:
        agent_setting: np.ndarray shape (n_actions, 6),
                       first 5 cols = outcome prob vector,
                       last col = agent cost (≥0)
    """
    contracts = np.array(content['Contract'].tolist())  # shape (L,5)
    utilities = np.array(content['Principal Utility'].tolist())  # shape (L,)
    actions = np.array(content['Agent Action'].tolist())  # shape (L,)
    L, m = contracts.shape

    # Step 1: Separate accepted and rejected logs
    accept_mask = actions == 1
    reject_mask = actions == -1

    contracts_accept = contracts[accept_mask]
    utils_accept = utilities[accept_mask]
    n_accept = contracts_accept.shape[0]

    contracts_reject = contracts[reject_mask]
    n_reject = contracts_reject.shape[0]

    # If no accepted contracts, fallback trivial agent (uniform dist, zero cost)
    if n_accept == 0:
        uniform_p = np.ones(m) / m
        return np.hstack([uniform_p.reshape(1, -1), np.array([[0.0]])])

    # Step 2: Infer candidate outcome distributions from accepted logs
    # For each accepted contract, solve LP for p: maximize p@w - c ≥ 0, p sums to 1
    # We use the fact that principal utility = p@v - payment@p = p@v - contract@p
    # We want to find p s.t. p@contract = cost + agent utility, but u_agent≥0, cost unknown yet.
    # Instead, invert: try to find p that matches observed principal utilities:
    # principal utility = p@v - p@contract
    # => p@(v - contract) = principal utility
    # Try to find p that satisfies p>=0, sum=1, and p@(v - contract) = principal utility.
    # This defines a feasible polytope of p for each accepted contract.

    def feasible_p(w, u_p):
        """Solve for p≥0, sum=1, p@(v-w)=u_p"""
        A_eq = np.vstack([np.ones(m), v - w])
        b_eq = np.array([1.0, u_p])
        bounds = [(0, 1)] * m
        res = linprog(np.zeros(m), A_eq=A_eq, b_eq=b_eq, bounds=bounds, method="highs")
        if res.success:
            return res.x
        else:
            # fallback: uniform p
            return np.ones(m) / m

    p_candidates = np.array([feasible_p(contracts_accept[i], utils_accept[i]) for i in range(n_accept)])

    # Step 3: Cluster p_candidates adaptively using DBSCAN to find distinct actions
    # DBSCAN eps and min_samples tuned to find meaningful clusters
    clustering = DBSCAN(eps=0.05, min_samples=3).fit(p_candidates)
    labels = clustering.labels_

    # Filter out noise points (-1 label) by assigning them to nearest cluster center (if any),
    # else create singleton clusters for them
    unique_labels = set(labels)
    if -1 in unique_labels:
        noise_idx = np.where(labels == -1)[0]
        non_noise_idx = np.where(labels != -1)[0]
        if len(non_noise_idx) > 0:
            cluster_centers = np.array([p_candidates[labels == lb].mean(axis=0) for lb in unique_labels if lb != -1])
            for ni in noise_idx:
                dists = np.linalg.norm(cluster_centers - p_candidates[ni], axis=1)
                labels[ni] = list(unique_labels - {-1})[np.argmin(dists)]
        else:
            # All noise: treat each as its own cluster
            labels = np.arange(n_accept)

    unique_labels = np.unique(labels)
    n_actions = len(unique_labels)

    # Step 4: Compute each cluster center p_a as normalized mean of assigned p
    p_actions = np.zeros((n_actions, m))
    for i, lbl in enumerate(unique_labels):
        cluster_ps = p_candidates[labels == lbl]
        p_actions[i] = cluster_ps.mean(axis=0)
        p_actions[i] = np.clip(p_actions[i], 0, None)
        p_actions[i] /= p_actions[i].sum()

    # Step 5: Determine agent costs c_a for each action a
    # Constraints:
    # (a) IR for accepted logs of that cluster: p_a @ w_i - c_a ≥ 0
    # (b) IC for accepted logs assigned to other clusters: p_a @ w_i - c_a ≥ p_b @ w_i - c_b ∀b≠a
    # (c) For rejected contracts: max_a (p_a @ w_j - c_a) < 0

    # Assign each accepted log to closest cluster action by p_a @ w_i
    accept_indices = np.where(accept_mask)[0]
    assign_accept = np.zeros(n_accept, dtype=int)
    for i in range(n_accept):
        w_i = contracts_accept[i]
        vals = p_actions @ w_i
        assign_accept[i] = np.argmax(vals)

    # Prepare LP variables: costs c = [c_0,...,c_{n_actions-1}] ≥ 0
    # We minimize sum of costs to keep costs small and feasible

    # Build constraints matrices:
    # For accepted logs assigned to a: p_a @ w_i - c_a ≥ 0  => c_a ≤ p_a @ w_i
    # For accepted logs assigned to a and other actions b≠a:
    #   p_a @ w_i - c_a ≥ p_b @ w_i - c_b
    #   => c_b - c_a ≥ p_b @ w_i - p_a @ w_i
    # For rejected logs j: max_a (p_a @ w_j - c_a) < 0
    #   => p_a @ w_j - c_a < 0 for all a
    #   => c_a > p_a @ w_j for all a and all j rejected

    c_num = n_actions
    A_ub = []
    b_ub = []

    # (a) IR constraints: for accepted logs assigned to a: c_a ≤ p_a @ w_i
    # represented as c_a - p_a@w_i ≤ 0 => -c_a + 0 ≤ -p_a@w_i
    for i, idx_log in enumerate(accept_indices):
        a = assign_accept[i]
        val = p_actions[a] @ contracts[idx_log]
        constr = np.zeros(c_num)
        constr[a] = 1  # c_a
        A_ub.append(constr)
        b_ub.append(val)

    # (b) IC constraints: for accepted logs i assigned to a,
    # for all b ≠ a: c_b - c_a ≥ p_b @ w_i - p_a @ w_i
    #  => -c_b + c_a ≤ -(p_b @ w_i - p_a @ w_i)
    for i, idx_log in enumerate(accept_indices):
        a = assign_accept[i]
        w_i = contracts[idx_log]
        for b in range(n_actions):
            if b == a:
                continue
            lhs = np.zeros(c_num)
            lhs[a] = 1
            lhs[b] = -1
            rhs = -(p_actions[b] @ w_i - p_actions[a] @ w_i)
            A_ub.append(lhs)
            b_ub.append(rhs)

    # (c) Rejection IR: for rejected logs j, for all a:
    # p_a @ w_j - c_a < 0 => c_a > p_a @ w_j
    # Inequality form for LP: -c_a ≤ -p_a@w_j - ε with small ε>0 to ensure strictness
    epsilon = 1e-5
    for idx_log in np.where(reject_mask)[0]:
        w_j = contracts[idx_log]
        for a in range(n_actions):
            lhs = np.zeros(c_num)
            lhs[a] = -1
            rhs = -(p_actions[a] @ w_j) - epsilon
            A_ub.append(lhs)
            b_ub.append(rhs)

    A_ub = np.array(A_ub)
    b_ub = np.array(b_ub)

    # Costs ≥ 0
    bounds = [(0, None)] * c_num

    # Objective: minimize sum of costs for parsimonious solution
    c_obj = np.ones(c_num)

    res = linprog(c_obj, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method="highs")

    if not res.success:
        # fallback: use min p@w_i among assigned contracts as cost (relaxed)
        c_vals = np.zeros(c_num)
        for a in range(n_actions):
            idxs = [accept_indices[i] for i in range(n_accept) if assign_accept[i] == a]
            if len(idxs) > 0:
                vals = [p_actions[a] @ contracts[i] for i in idxs]
                c_vals[a] = min(vals)
            else:
                c_vals[a] = 0.0
    else:
        c_vals = res.x

    # Post-processing: clip costs at zero minimum
    c_vals = np.maximum(0, c_vals)

    # Final agent setting matrix
    agent_setting = np.hstack([p_actions, c_vals.reshape(-1, 1)])

    return agent_setting
```
