```python
import numpy as np
import pandas as pd
from scipy.optimize import linprog
from sklearn.cluster import DBSCAN, KMeans


def agent_solver_v2(v: np.ndarray, content: list[dict]) -> np.ndarray:
    """
    Infer a valid agent setting (probabilistic actions + costs) consistent with historical logs
    using joint clustering over contract-response pairs and LP feasibility checks to satisfy IR and IC constraints.
    
    Args:
        v: Principal's reward vector for 5 outcomes (5-dimensional).
        content: List of dict logs with keys 'Contract', 'Principal Utility', 'Agent Action'.
    
    Returns:
        agent_setting: n_actions x 6 array where
          - first 5 cols: probability distributions over outcomes`,
          - last col: nonnegative cost of performing the action.
    """
    L = len(content)
    m = v.shape[0]

    # Extract data arrays
    contracts = np.array([log['Contract'] for log in content])  # (L,5)
    p_utils = np.array([log['Principal Utility'] for log in content])  # (L,)
    agent_actions = np.array([log['Agent Action'] for log in content])  # (L,)

    # Helper function: check if (p, c) explains all logs under IR and IC
    def check_feasibility(candidate_ps, candidate_cs):
        # candidate_ps: (n,5), candidate_cs: (n,)
        n = candidate_ps.shape[0]
        # We must assign each accepted log to some action that yields agent utility >=0 
        # and assigned p matches max expected agent payoff (IC)
        for i in range(L):
            w = contracts[i]
            A_act = agent_actions[i]
            if A_act == 1:
                # Find all candidate actions a s.t. agent utility >=0: p_a * w >= c_a
                utility_ok = candidate_ps @ w - candidate_cs >= -1e-8
                if not np.any(utility_ok):
                    return False  # impossible to rationalize acceptance
                # Among them pick subset candidates with max agent payoff (IC)
                max_agent_payoff = np.max(candidate_ps @ w - candidate_cs)
                # Agent only picks actions that max payoff with tolerance
                chosen = np.where(np.abs(candidate_ps @ w - candidate_cs - max_agent_payoff) < 1e-7)[0]
                if chosen.size == 0:
                    return False
            elif A_act == -1:
                # Agent rejects = means no candidate action yields utility >=0
                if np.any(candidate_ps @ w - candidate_cs >= -1e-8):
                    return False
        return True

    # Step 1: Preselect plausible actions by clustering accepted logs' contracts and utilities

    # Construct feature vector for clustering: 
    # Contract payments + scaled principal utility + agent utility proxy:
    # Agent utility proxy is unknown, we use principal utility as proxy and contract payments
    accept_mask = (agent_actions == 1)
    accept_contracts = contracts[accept_mask]
    accept_pu = p_utils[accept_mask][:, None]

    # Normalize contracts for geometric scale and concatenate
    contract_norm = accept_contracts / (accept_contracts.max(axis=0, keepdims=True) + 1e-6)
    cluster_features = np.hstack([contract_norm, accept_pu / (np.abs(accept_pu).max() + 1e-6)])

    # Use DBSCAN with small eps to detect compact groups, fall back to KMeans 
    # if DBSCAN finds too few
    clustering = DBSCAN(eps=0.17, min_samples=3).fit(cluster_features)
    labels_unique = set(clustering.labels_)
    labels_unique.discard(-1)

    if len(labels_unique) < 2:
        # DBSCAN failed or too few clusters: run KMeans for 5~10 clusters
        n_clusters = min(10, max(2, len(accept_contracts)//15))
        clustering = KMeans(n_clusters=n_clusters, random_state=435).fit(cluster_features)
        labels_unique = set(range(n_clusters))
        labels = clustering.labels_
    else:
        labels = clustering.labels_

    clusters = []
    for label in labels_unique:
        idx = np.where(labels == label)[0]
        if len(idx) < 1:
            continue
        # For each cluster, average contract and estimate agent cost with LP
        
        cluster_contracts = accept_contracts[idx]  # shape (~cluster_size,5)

        # Step 2: Find an agent outcome distribution p and cost c for this cluster
        # Use LP to find p that can rationalize at least min agent utility >= 0

        # LP variables: p over 5 outcomes (p >=0, sum=1), and c>=0 (wrapper via search)
        # For each contract w_i in cluster: ensure agent utility p @ w_i - c >= 0
        # We fix c as the minimum p @ w_i over cluster contracts

        def solve_p_cost(cluster_ws):
            # Maximize min agent payoff = min_i p@w_i - c with constraints p>=0 sum=1
            # Use constrained max-min LP reformulated by epigraph trick:
            # max t
            # s.t. for all i: p @ w_i - c >= t and c>=0
            # Since c = min_i p@w_i - t, c>=0 => min_i p@w_i >= t >=0
            # Equivalently, for fixed p, c = min_i p@w_i
            # So try to find p maximizing min_i p @ w_i s.t p in simplex.
            W = cluster_ws.T  # (5,N)
            n_c = cluster_ws.shape[0]

            # Formulate LP to maximize t subject to for all i: p@w_i >= t, sum p=1 , p>=0
            # Variables: p (5 dims), t (scalar)
            # Converted to standard form:
            # maximize t = min_i p@w_i 
            # => constraints p@w_i >= t

            c_lp = np.zeros(m + 1)
            c_lp[-1] = -1  # maximize t <=> minimize -t

            # Constraints:
            # For each i: p@w_i - t >= 0  => p@w_i >= t
            # => -p@w_i + t <= 0
            A_ub = np.hstack([-cluster_ws, np.ones((n_c, 1))])
            b_ub = np.zeros(n_c)

            A_eq = np.zeros((1, m + 1))
            A_eq[0, :m] = 1
            b_eq = np.array([1.0])

            bounds = [(0, 1)] * m + [(None, None)]

            res = linprog(c_lp, A_ub=A_ub, b_ub=b_ub,
                          A_eq=A_eq, b_eq=b_eq, bounds=bounds, method='highs')
            if res.success:
                p = res.x[:m]
                t = res.x[-1]
                # cost c = minimum agent payoff across cluster contracts - t
                cost = t
                cost = max(0.0, cost)  # Must be non-negative cost as IR
                return p, cost
            else:
                return None, None

        p_c = solve_p_cost(cluster_contracts)
        if p_c[0] is not None:
            clusters.append(p_c)
        else:
            # fallback: uniform p, cost =0
            clusters.append((np.ones(m) / m, 0.0))

    # Step 3: Remove duplicate or very similar actions via cosine similarity threshold
    def cos_sim(a, b):
        an = a / np.linalg.norm(a)
        bn = b / np.linalg.norm(b)
        return np.clip(np.dot(an, bn), -1, 1)

    filtered_clusters = []
    for pc in clusters:
        p, c = pc
        # Skip if p close to any in filtered_clusters
        if any(cos_sim(p, fc[0]) > 0.996 and abs(c - fc[1]) < 1e-5 for fc in filtered_clusters):
            continue
        filtered_clusters.append(pc)

    # Fallback if filtered is empty, add uniform action with 0 cost
    if len(filtered_clusters) == 0:
        filtered_clusters.append((np.ones(m) / m, 0.0))

    ps_arr = np.array([pc[0] for pc in filtered_clusters])
    cs_arr = np.array([pc[1] for pc in filtered_clusters])

    n_actions = ps_arr.shape[0]

    # Step 4: Verify global feasibility via check_feasibility; if fails, amplify costs slightly
    if not check_feasibility(ps_arr, cs_arr):
        # Increase costs slightly to ensure rejected contracts yield <0 utility
        cs_arr = np.copy(cs_arr)
        for j in range(n_actions):
            cost = cs_arr[j]
            # Enforce that for all rejected logs: p_j@w - c_j < 0
            for i in range(L):
                if agent_actions[i] == -1:
                    cnd_utility = ps_arr[j] @ contracts[i] - cost
                    if cnd_utility >= -1e-9:
                        # Raise cost just above that utility plus margin
                        cost_candidate = ps_arr[j] @ contracts[i] + 1e-4
                        if cost_candidate > cost:
                            cost = cost_candidate
            cs_arr[j] = cost

        # Final feasibility check raises error if still unfeasible
        if not check_feasibility(ps_arr, cs_arr):
            raise ValueError("Cannot find feasible agent setting consistent with all logs.")

    # Step 5: Normalize all ps to sum to 1 (robustness)
    ps_arr = np.clip(ps_arr, 1e-12, None)
    ps_arr /= ps_arr.sum(axis=1, keepdims=True)

    agent_setting = np.hstack([ps_arr, cs_arr[:, None]])

    return agent_setting
```
