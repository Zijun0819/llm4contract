```python
import numpy as np
from sklearn.cluster import AgglomerativeClustering
from scipy.optimize import linprog

def agent_solver_v2(v: np.ndarray, content: list[dict]) -> np.ndarray:
    """
    Infer a valid agent setting (actions = outcome distributions + cost)
    consistent with historical interaction logs under IR, IC, and rejection constraints,
    using global LP enforcement, weighted clustering, dummy actions for unexplained contracts,
    and precise normalization.

    Parameters:
    - v: np.ndarray, shape (5,), principal's value vector for the 5 outcomes
    - content: list of dicts, each dict with keys:
        'Contract' (list of 5 floats),
        'Principal Utility' (float),
        'Agent Action' (1 for accept, -1 for reject)

    Returns:
    - agent_setting: np.ndarray, shape (n_actions, 6),
      with first 5 columns as outcome probabilities summing to 1,
      and last column as nonnegative agent cost for that action.
    """
    m_outcomes = v.size
    L = len(content)
    if L == 0:
        # No logs: single uniform action with zero cost
        p_uniform = np.ones(m_outcomes) / m_outcomes
        return np.hstack([p_uniform.reshape(1, -1), np.array([[0.]])])

    # Extract arrays
    contracts = np.array([log['Contract'] for log in content], dtype=np.float64)  # (L,5)
    ag_actions = np.array([log['Agent Action'] for log in content], dtype=int)   # (L,)
    p_util = np.array([log['Principal Utility'] for log in content], dtype=np.float64)  # (L,)

    accepted_ix = np.where(ag_actions == 1)[0]
    rejected_ix = np.where(ag_actions == -1)[0]

    # If no accepted contracts, return trivial uniform action with zero cost
    if accepted_ix.size == 0:
        p_uniform = np.ones(m_outcomes) / m_outcomes
        return np.hstack([p_uniform.reshape(1, -1), np.array([[0.]])])

    accepted_w = contracts[accepted_ix]

    # Normalize accepted contracts to simplex for clustering with safeguard
    norm_w = accepted_w / (accepted_w.sum(axis=1, keepdims=True) + 1e-12)

    # Adaptive clusters: min(10, sqrt(#accepted), #accepted), at least 1
    n_accepted = accepted_ix.size
    n_clusters = max(1, min(10, int(np.sqrt(n_accepted)), n_accepted))

    clustering = AgglomerativeClustering(n_clusters=n_clusters, linkage='average')
    labels = clustering.fit_predict(norm_w)

    p_candidates = []
    costs_lb = []

    # Weighted cluster centroids with weights from principal utilities (shifted positive)
    for c in range(n_clusters):
        cluster_mask = (labels == c)
        if not np.any(cluster_mask):
            continue

        cluster_idx = accepted_ix[cluster_mask]
        cluster_w = contracts[cluster_idx]

        # Positive weights: principal utilities shifted to >=1
        cluster_pu = p_util[cluster_idx]
        wgt = cluster_pu - cluster_pu.min() + 1.0
        wgt_sum = wgt.sum()
        if wgt_sum < 1e-12:
            wgt = np.ones_like(wgt) / wgt.size
        else:
            wgt = wgt / wgt_sum

        avg_w = np.average(cluster_w, axis=0, weights=wgt)

        # Project avg_w to simplex: clip negatives and normalize
        p_vec = np.clip(avg_w, 0, None)
        s = p_vec.sum()
        if s < 1e-12:
            p_vec = np.ones(m_outcomes) / m_outcomes
        else:
            p_vec /= s
        p_candidates.append(p_vec)

        # Cost lower bound for IR: minimal expected payment over cluster contracts
        costs_cluster = np.array([p_vec @ contracts[i] for i in cluster_idx])
        costs_lb.append(costs_cluster.min())

    p_candidates = np.array(p_candidates)
    costs_lb = np.array(costs_lb)

    # Handle rejected contracts constraints: cost > max_a p_a @ w_r for each action a
    if rejected_ix.size > 0:
        rejected_w = contracts[rejected_ix]
        p_w_rej = p_candidates @ rejected_w.T  # shape (n_actions, n_rejected)
        costs_rej_min = p_w_rej.max(axis=1) + 1e-6
    else:
        costs_rej_min = np.zeros(len(p_candidates))

    # Initial costs satisfying IR and rejection constraints
    costs = np.maximum(costs_lb, costs_rej_min)
    costs = np.maximum(costs, 0)

    # Check if an accepted contract is rationalized by any action
    def rationalizes(w_i):
        util = p_candidates @ w_i - costs
        valid = np.where(util >= -1e-8)[0]
        return valid if valid.size > 0 else np.array([], dtype=int)

    # Add dummy actions exactly matching unexplained accepted contracts
    unexplained_ix = [i for i in accepted_ix if rationalizes(contracts[i]).size == 0]
    for i in unexplained_ix:
        w_i = contracts[i]
        p_new = np.clip(w_i, 0, None)
        s = p_new.sum()
        if s < 1e-12:
            p_new = np.ones(m_outcomes) / m_outcomes
        else:
            p_new /= s
        c_new = p_new @ w_i
        p_candidates = np.vstack([p_candidates, p_new])
        costs = np.append(costs, c_new)

    # After adding dummy actions, re-check rejection constraints and increase costs if needed
    if rejected_ix.size > 0:
        rejected_w = contracts[rejected_ix]
        p_w_rej = p_candidates @ rejected_w.T  # shape (n_actions, n_rejected)
        for a in range(len(costs)):
            max_rej = p_w_rej[a].max()
            if costs[a] < max_rej + 1e-8:
                costs[a] = max_rej + 1e-4

    # Formulate LP to globally enforce rejection constraints and minimize sum(costs)
    # Variables: costs (nonnegative)
    # Constraints:
    #   For each rejected contract r and action a: cost_a >= p_a @ w_r + epsilon
    # Accepted constraints are non-convex (max over actions) and handled by dummy actions above

    n_actions = len(p_candidates)
    c_obj = np.zeros(n_actions)  # zero objective, just feasibility
    epsilon = 1e-5

    A_ub = []
    b_ub = []

    if rejected_ix.size > 0:
        for a in range(n_actions):
            p_a = p_candidates[a]
            for r in rejected_ix:
                val = p_a @ contracts[r] + epsilon
                row = np.zeros(n_actions)
                row[a] = -1
                A_ub.append(row)
                b_ub.append(-val)

        A_ub = np.array(A_ub)
        b_ub = np.array(b_ub)
    else:
        A_ub = None
        b_ub = None

    bounds = [(0, None)] * n_actions

    # Solve LP to refine costs with rejection constraints
    if A_ub is not None:
        res = linprog(c=c_obj, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')
        if res.success:
            costs = res.x
        else:
            # Fall back to previous costs if LP fails
            costs = np.maximum(costs, 0)
    else:
        costs = np.maximum(costs, 0)

    # Final normalization of p_candidates to valid probability distributions
    p_candidates = np.clip(p_candidates, 0, None)
    sums = p_candidates.sum(axis=1, keepdims=True)
    sums[sums < 1e-12] = 1.0
    p_candidates /= sums

    costs = np.maximum(costs, 0)

    agent_setting = np.hstack([p_candidates, costs[:, None]])
    return agent_setting
```
