```python
import numpy as np
from sklearn.cluster import AgglomerativeClustering

def agent_solver_v2(v: np.ndarray, content: list[dict]) -> np.ndarray:
    """
    Infer a valid agent setting (actions = outcome distributions + cost)
    consistent with historical contract logs under IR and IC constraints.

    Parameters:
        v (np.ndarray): Principal reward vector of length 5.
        content (list[dict]): Each dict contains:
            'Contract' (list of 5 floats),
            'Principal Utility' (float),
            'Agent Action' (1 for accept, -1 for reject).

    Returns:
        np.ndarray: n_actions x 6 array, each row is (p_1,...,p_5,cost)
                    where p_i >= 0, sum p_i = 1, cost >= 0.
    """
    m_outcomes = v.size
    L = len(content)

    # Extract arrays from content
    contracts = np.array([log['Contract'] for log in content], dtype=np.float64)  # shape (L,5)
    principal_utils = np.array([log['Principal Utility'] for log in content], dtype=np.float64)  # shape (L,)
    agent_actions = np.array([log['Agent Action'] for log in content], dtype=int)  # shape (L,)

    accepted_ix = np.where(agent_actions == 1)[0]
    rejected_ix = np.where(agent_actions == -1)[0]

    # If no accepted contracts, return trivial uniform action with zero cost
    if accepted_ix.size == 0:
        uniform_p = np.ones(m_outcomes) / m_outcomes
        return np.hstack([uniform_p.reshape(1, -1), np.zeros((1,1))])

    accepted_contracts = contracts[accepted_ix]

    # Normalize accepted contracts (sum to 1) for clustering, handle zeros safely
    accepted_sums = accepted_contracts.sum(axis=1, keepdims=True)
    accepted_sums[accepted_sums < 1e-12] = 1.0
    normalized_accepted = accepted_contracts / accepted_sums

    # Adaptive number of clusters: sqrt scaling limited by accepted count and max 10
    n_accepted = accepted_ix.size
    n_max = min(10, n_accepted, max(1, int(np.sqrt(n_accepted))))
    if n_max == 0:
        n_max = 1

    # Stable clustering with average linkage
    clustering = AgglomerativeClustering(n_clusters=n_max, linkage='average')
    labels = clustering.fit_predict(normalized_accepted)

    p_candidates = []
    costs_lower_bounds = []

    # Build candidate actions per cluster by weighted averaging contracts with shifted principal utilities
    for cluster_id in range(n_max):
        cluster_mask = (labels == cluster_id)
        cluster_indices = accepted_ix[cluster_mask]
        if cluster_indices.size == 0:
            continue
        cluster_contracts = contracts[cluster_indices]
        cluster_principal_utils = principal_utils[cluster_indices]

        # Shift principal utilities to positive weights (min to zero + 1)
        w_min = cluster_principal_utils.min()
        weights = cluster_principal_utils - w_min + 1.0

        # Weighted average contract vector
        avg_w = np.average(cluster_contracts, axis=0, weights=weights)

        # Project avg_w onto simplex: clip negatives and renormalize
        p = np.clip(avg_w, 0, None)
        p_sum = p.sum()
        if p_sum < 1e-12:
            p = np.ones(m_outcomes) / m_outcomes
        else:
            p = p / p_sum

        p_candidates.append(p)

        # Cost lower bound from acceptance IR: cost â‰¤ p @ w_i for all accepted i in cluster
        costs_cluster = np.array([np.dot(p, contracts[i]) for i in cluster_indices])
        min_cost = costs_cluster.min()
        costs_lower_bounds.append(min_cost)

    if len(p_candidates) == 0:
        # fallback: uniform distribution with zero cost
        uniform_p = np.ones(m_outcomes) / m_outcomes
        return np.hstack([uniform_p.reshape(1, -1), np.zeros((1,1))])

    p_candidates = np.array(p_candidates)  # shape (n_max, m_outcomes)
    costs_lower_bounds = np.array(costs_lower_bounds)  # shape (n_max,)

    # Rejection constraints: cost must exceed max agent utility on rejected contracts
    if rejected_ix.size > 0:
        rejected_contracts = contracts[rejected_ix]  # shape (R,5)
        # Shape (n_actions, R)
        p_w_rejections = p_candidates @ rejected_contracts.T  # shape (n_max, R)
        rejection_cost_min = p_w_rejections.max(axis=1) + 1e-6
    else:
        rejection_cost_min = np.zeros_like(costs_lower_bounds)

    # Final costs satisfy costs >= max(IR lower bound, rejection lower bound), and costs >=0
    costs = np.maximum(costs_lower_bounds, rejection_cost_min)
    costs = np.maximum(costs, 0.0)

    def explains_acceptance(w_i: np.ndarray) -> int | None:
        """
        Returns index of action that rationalizes acceptance of contract w_i
        (agent utility >= 0 within tolerance), else None.
        """
        for a_idx, (p, c) in enumerate(zip(p_candidates, costs)):
            util = np.dot(p, w_i) - c
            if util >= -1e-8:
                return a_idx
        return None

    # Add new actions for any accepted contracts not explained by existing actions
    for i in accepted_ix:
        w_i = contracts[i]
        if explains_acceptance(w_i) is None:
            # Create action with distribution = contract payments normalized
            p_new = w_i.copy()
            p_sum = p_new.sum()
            if p_sum < 1e-12:
                p_new = np.ones(m_outcomes) / m_outcomes
            else:
                p_new = p_new / p_sum
            cost_new = np.dot(p_new, w_i)  # minimal cost to make utility exactly 0
            p_candidates = np.vstack([p_candidates, p_new])
            costs = np.append(costs, cost_new)

    # Re-check rejection constraints after adding new actions, adjust costs upward if needed
    if rejected_ix.size > 0:
        rejected_contracts = contracts[rejected_ix]
        p_w_rejections = p_candidates @ rejected_contracts.T  # shape (n_actions, R)
        for a in range(p_candidates.shape[0]):
            max_rej_util = p_w_rejections[a].max()
            if costs[a] < max_rej_util + 1e-8:
                costs[a] = max_rej_util + 1e-4

    # Normalize probabilities robustly again
    p_candidates = np.clip(p_candidates, 0, None)
    sums = p_candidates.sum(axis=1, keepdims=True)
    sums[sums < 1e-12] = 1.0
    p_candidates /= sums

    # Assemble final agent setting matrix (p_1,...,p_5, cost)
    agent_setting = np.hstack([p_candidates, costs[:, None]])

    return agent_setting
```
