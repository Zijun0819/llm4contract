```python
import numpy as np
from sklearn.cluster import KMeans
from scipy.optimize import linprog

def agent_solver_v2(v: np.ndarray, content: list[dict]) -> np.ndarray:
    """
    Infer a valid agent setting matrix (n_actions x 6) where each row is:
    [probabilities over 5 outcomes (sum to 1), cost ≥ 0].

    Inputs:
    - v: np.ndarray of shape (5,), principal's reward vector over outcomes.
    - content: list of dicts with keys:
        'Contract': list/array of length 5 (payment vector),
        'Principal Utility': float,
        'Agent Action': 1 (accept) or -1 (reject).

    Returns:
    - agent_setting: np.ndarray shape (n_actions, 6) with each row:
      [p_1,...,p_5, cost], p_i ≥ 0, sum p_i=1, cost ≥ 0.
    """
    np.random.seed(42)
    m = len(v)
    L = len(content)

    # Parse logs
    contracts = np.array([log['Contract'] for log in content], dtype=np.float64)  # (L,m)
    agent_actions = np.array([log['Agent Action'] for log in content], dtype=int)
    principal_utils = np.array([log['Principal Utility'] for log in content], dtype=np.float64)

    accepted_idx = np.where(agent_actions == 1)[0]
    rejected_idx = np.where(agent_actions == -1)[0]

    # If no accepted contracts, fallback trivial
    if len(accepted_idx) == 0:
        uniform_p = np.ones(m) / m
        return np.hstack([uniform_p.reshape(1, -1), np.array([[0.0]])])

    accepted_contracts = contracts[accepted_idx]

    # Adaptive max clusters based on data size
    max_K = min(8, max(2, len(accepted_idx)//10))
    if max_K < 2:
        max_K = 2

    eps = 1e-5
    max_attempts = 5
    attempt = 0

    while attempt < max_attempts and max_K >= 1:
        try:
            # Cluster accepted contracts using kmeans on payment vectors
            kmeans = KMeans(n_clusters=max_K, random_state=0, n_init=20).fit(accepted_contracts)
        except Exception:
            # If clustering fails (e.g. too few points), reduce clusters
            max_K -= 1
            attempt += 1
            continue

        centers_w = kmeans.cluster_centers_  # (max_K, m)

        # Infer p_k for each cluster center w_k by LP: maximize p @ w_k s.t p≥0 sum p=1
        p_candidates = np.zeros((max_K, m), dtype=np.float64)
        feasible_p_found = True
        for k in range(max_K):
            w_k = centers_w[k]
            # LP: max p·w_k == min -p·w_k s.t sum p=1, p≥0
            res = linprog(
                c=-w_k,
                A_eq=[np.ones(m)],
                b_eq=[1.0],
                bounds=[(0, 1)] * m,
                method='highs',
            )
            if not res.success:
                # fallback: place all mass on max coordinate of w_k
                p = np.zeros(m)
                max_idx = np.argmax(w_k)
                p[max_idx] = 1.0
                p_candidates[k] = p
            else:
                p_candidates[k] = res.x

        # Assign each accepted contract to a cluster
        assigned_clusters = kmeans.predict(accepted_contracts)

        # Build IR constraints (accepted contracts):
        # For each accepted contract i assigned to cluster k:
        # p_k·contract_i - cost_k >= 0  =>  cost_k <= p_k·contract_i
        accepted_rows = []
        accepted_bounds = []
        for idx_i, cluster_k in zip(accepted_idx, assigned_clusters):
            row = np.zeros(max_K, dtype=np.float64)
            row[cluster_k] = -1.0  # -cost_k
            bound = -np.dot(p_candidates[cluster_k], contracts[idx_i])
            accepted_rows.append(row)
            accepted_bounds.append(bound)
        if accepted_rows:
            accepted_rows = np.array(accepted_rows)
            accepted_bounds = np.array(accepted_bounds)
        else:
            accepted_rows = np.empty((0, max_K))
            accepted_bounds = np.array([])

        # Build rejection constraints:
        # For each rejected contract j and each cluster k:
        # p_k·contract_j - cost_k < 0 => cost_k > p_k·contract_j
        # Approximate strict inequality with small epsilon:
        # -cost_k <= -p_k·contract_j - eps
        rejected_rows = []
        rejected_bounds = []
        for idx_j in rejected_idx:
            contract_j = contracts[idx_j]
            for k in range(max_K):
                row = np.zeros(max_K, dtype=np.float64)
                row[k] = -1.0  # -cost_k
                bound = -(np.dot(p_candidates[k], contract_j) + eps)
                rejected_rows.append(row)
                rejected_bounds.append(bound)
        if rejected_rows:
            rejected_rows = np.array(rejected_rows)
            rejected_bounds = np.array(rejected_bounds)
        else:
            rejected_rows = np.empty((0, max_K))
            rejected_bounds = np.array([])

        # Combine all inequality constraints
        A_ub = np.vstack([accepted_rows, rejected_rows]) if accepted_rows.size or rejected_rows.size else np.empty((0, max_K))
        b_ub = np.hstack([accepted_bounds, rejected_bounds]) if accepted_bounds.size or rejected_bounds.size else np.array([])

        # Bounds on costs: costs ≥ 0
        bounds_costs = [(0, None)] * max_K

        # Objective: minimize sum of costs (parsimony)
        c_obj = np.ones(max_K, dtype=np.float64)

        res_cost = linprog(
            c=c_obj,
            A_ub=A_ub if A_ub.size else None,
            b_ub=b_ub if b_ub.size else None,
            bounds=bounds_costs,
            method='highs',
        )

        if res_cost.success:
            costs = res_cost.x
            # Validate costs
            if np.any(costs < 0) or not np.all(np.isfinite(costs)):
                max_K -= 1
                attempt += 1
                continue

            # Filter out any cluster with cost or p invalid (numerical safety)
            valid_mask = np.isfinite(costs) & (costs >= 0)
            if not np.any(valid_mask):
                max_K -= 1
                attempt += 1
                continue

            costs = costs[valid_mask]
            p_candidates = p_candidates[valid_mask]

            # Normalize p_candidates rows to simplex and clip small negatives
            for i in range(p_candidates.shape[0]):
                p = p_candidates[i]
                p = np.maximum(p, 0)
                s = p.sum()
                if s <= 0:
                    p = np.ones(m) / m
                else:
                    p /= s
                p_candidates[i] = p

            costs = np.maximum(costs, 0)

            # Enforce strict rejection constraints by bumping costs if needed
            if len(rejected_idx) > 0:
                slack = 1e-5
                for i in range(len(costs)):
                    max_rej_util = max((p_candidates[i] @ contracts[j]) for j in rejected_idx)
                    if costs[i] <= max_rej_util:
                        costs[i] = max_rej_util + slack

            agent_setting = np.hstack([p_candidates, costs.reshape(-1, 1)])
            return agent_setting

        else:
            # Infeasible, try reducing clusters for simpler model
            max_K -= 1
            attempt += 1

    # Fallback: single uniform action with empirical distribution over accepted contracts' best outcomes
    outcome_counts = np.zeros(m, dtype=np.float64)
    for idx_i in accepted_idx:
        # Use contract payment vector to find best outcome (max payment)
        best_outcome = np.argmax(contracts[idx_i])
        outcome_counts[best_outcome] += 1
    if outcome_counts.sum() > 0:
        empirical_p = outcome_counts / outcome_counts.sum()
    else:
        empirical_p = np.ones(m) / m
    return np.hstack([empirical_p.reshape(1, -1), np.array([[0.0]])])
```
