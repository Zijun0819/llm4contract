```python
import numpy as np
from sklearn.cluster import KMeans
from scipy.optimize import linprog

def agent_solver_v2(v: np.ndarray, content: list[dict]) -> np.ndarray:
    """
    Infer a valid agent setting matrix from historical contract interactions.

    Each action row: [p_1, p_2, p_3, p_4, p_5, cost],
    where p_i >=0, sum p_i=1, cost >=0.

    Parameters:
    - v: np.ndarray shape (5,), principal reward vector (not used directly here).
    - content: list of dicts with keys:
        'Contract': list or np.ndarray shape (5,)
        'Principal Utility': float (ignored for inference)
        'Agent Action': int (1 accepted, -1 rejected)

    Returns:
    - agent_setting: np.ndarray shape (n_actions, 6)
    """
    np.random.seed(42)
    m = v.size
    L = len(content)
    contracts = np.array([entry['Contract'] for entry in content], dtype=np.float64)  # shape (L,5)
    agent_actions = np.array([entry['Agent Action'] for entry in content], dtype=int)  # shape (L,)

    accepted_idx = np.where(agent_actions == 1)[0]
    rejected_idx = np.where(agent_actions == -1)[0]

    # If no accepted contracts, fallback uniform zero-cost action
    if len(accepted_idx) == 0:
        uniform_p = np.ones(m) / m
        return np.hstack([uniform_p.reshape(1, -1), np.array([[0.0]])])

    accepted_contracts = contracts[accepted_idx]

    # Adaptive cluster count: roughly one cluster per ~10 accepted contracts, bounded [1..8]
    # Ensure at least 1 cluster and at most number of accepted contracts
    max_K = min(max(1, len(accepted_idx) // 10), 8)
    max_K = min(max_K, len(accepted_idx))
    if max_K < 1:
        max_K = 1

    eps = 1e-7
    attempt = 0
    max_attempts = 6

    while attempt < max_attempts and max_K >= 1:
        # Cluster accepted contracts (contract payment vectors)
        try:
            kmeans = KMeans(n_clusters=max_K, random_state=0, n_init=20)
            kmeans.fit(accepted_contracts)
            centers_w = kmeans.cluster_centers_
            assigned_clusters = kmeans.predict(accepted_contracts)
        except Exception:
            # fallback: treat all accepted as one cluster if clustering fails
            centers_w = np.mean(accepted_contracts, axis=0).reshape(1, -1)
            assigned_clusters = np.zeros(len(accepted_idx), dtype=int)
            max_K = 1

        # For each cluster center w_k: find p_k maximizing p_k @ w_k s.t. p_k in simplex
        p_candidates = []
        for w_k in centers_w:
            # Solve max p @ w_k --> min -p @ w_k s.t sum p=1, p>=0
            res = linprog(
                c=-w_k,
                A_eq=[np.ones(m)],
                b_eq=[1.0],
                bounds=[(0, 1)] * m,
                method='highs',
            )
            if res.success and res.x is not None:
                p = res.x
                # Numerical correction
                p = np.maximum(p, 0)
                s = p.sum()
                if s <= 0:
                    p = np.ones(m) / m
                else:
                    p = p / s
                p_candidates.append(p)
            else:
                # fallback: put all mass on max coordinate of w_k
                p = np.zeros(m)
                p[np.argmax(w_k)] = 1.0
                p_candidates.append(p)
        p_candidates = np.array(p_candidates)  # shape (max_K, m)

        # Constraints on costs c_k (one per action k):
        # For accepted contracts i assigned to cluster k:
        # IR: c_k ≤ p_k @ w_i   ->   -c_k ≤ -p_k @ w_i (<= b_ub)
        accepted_rows = []
        accepted_bounds = []
        for idx_i, k in zip(accepted_idx, assigned_clusters):
            row = np.zeros(max_K)
            row[k] = -1.0  # coefficient for c_k: -c_k
            bound = -np.dot(p_candidates[k], contracts[idx_i])  # ≤ bound
            accepted_rows.append(row)
            accepted_bounds.append(bound)
        if accepted_rows:
            accepted_rows = np.array(accepted_rows)
            accepted_bounds = np.array(accepted_bounds)
        else:
            accepted_rows = np.empty((0, max_K))
            accepted_bounds = np.array([])

        # For rejected contracts j, for all k actions:
        # IC rejection: agent rejects contract → for all k, c_k > p_k @ w_j
        # => -c_k ≤ -(p_k @ w_j) - eps
        rejected_rows = []
        rejected_bounds = []
        for idx_j in rejected_idx:
            w_j = contracts[idx_j]
            for k in range(max_K):
                row = np.zeros(max_K)
                row[k] = -1.0
                bound = -(np.dot(p_candidates[k], w_j) + eps)
                rejected_rows.append(row)
                rejected_bounds.append(bound)
        if rejected_rows:
            rejected_rows = np.array(rejected_rows)
            rejected_bounds = np.array(rejected_bounds)
        else:
            rejected_rows = np.empty((0, max_K))
            rejected_bounds = np.array([])

        # Combine all inequality constraints
        if accepted_rows.size > 0 and rejected_rows.size > 0:
            A_ub = np.vstack([accepted_rows, rejected_rows])
            b_ub = np.hstack([accepted_bounds, rejected_bounds])
        elif accepted_rows.size > 0:
            A_ub = accepted_rows
            b_ub = accepted_bounds
        elif rejected_rows.size > 0:
            A_ub = rejected_rows
            b_ub = rejected_bounds
        else:
            A_ub = None
            b_ub = None

        bounds_c = [(0, None)] * max_K  # costs ≥ 0
        obj = np.ones(max_K)  # minimize total costs to encourage parsimony

        res_c = linprog(
            c=obj,
            A_ub=A_ub,
            b_ub=b_ub,
            bounds=bounds_c,
            method='highs',
        )

        if res_c.success and res_c.x is not None:
            costs = res_c.x
            # Filter out infinite or negative costs (shouldn't occur due to bounds)
            valid_mask = np.isfinite(costs) & (costs >= 0)
            if not np.any(valid_mask):
                max_K -= 1
                attempt += 1
                continue
            # Keep only valid actions
            costs = costs[valid_mask]
            p_candidates = p_candidates[valid_mask]

            # Normalize p_candidates rows (clip negatives)
            for i in range(len(p_candidates)):
                p = p_candidates[i]
                p = np.maximum(p, 0)
                s = p.sum()
                if s <= 0:
                    p = np.ones(m) / m
                else:
                    p /= s
                p_candidates[i] = p

            costs = np.maximum(costs, 0)

            agent_setting = np.hstack([p_candidates, costs.reshape(-1, 1)])

            # Verify IC and IR approximately for accepted contracts:
            # For each accepted contract i, agent must have acceptance action:
            # max_k p_k @ w_i - c_k >= 0
            for idx_i in accepted_idx:
                w_i = contracts[idx_i]
                utilities = p_candidates @ w_i - costs
                if np.max(utilities) < -eps:
                    # Add new action exactly explaining this acceptance:
                    p_new = np.maximum(w_i, 0)
                    s = p_new.sum()
                    if s <= 0:
                        p_new = np.ones(m) / m
                    else:
                        p_new /= s
                    cost_new = max(np.dot(p_new, w_i), 0)
                    agent_setting = np.vstack([agent_setting, np.hstack([p_new, cost_new])])
                    p_candidates = np.vstack([p_candidates, p_new])
                    costs = np.append(costs, cost_new)

            # Enforce rejection constraints strictly: no rejected contract yields utility ≥ 0
            if len(rejected_idx) > 0:
                rej_contracts = contracts[rejected_idx]
                utilities_rej = p_candidates @ rej_contracts.T - costs[:, None]  # shape (actions, rejected)
                violated = utilities_rej >= -eps
                if violated.any():
                    # Increase costs minimally to fix violations
                    for a in range(agent_setting.shape[0]):
                        if np.any(utilities_rej[a] >= -eps):
                            incr = np.max(utilities_rej[a]) + eps
                            agent_setting[a, -1] += incr
                            costs[a] = agent_setting[a, -1]

            # Final normalization and clipping
            p_matrix = np.maximum(agent_setting[:, :m], 0)
            row_sums = p_matrix.sum(axis=1, keepdims=True)
            row_sums[row_sums == 0] = 1.0
            p_matrix /= row_sums
            cost_vec = np.clip(agent_setting[:, m], 0, None)
            agent_setting = np.hstack([p_matrix, cost_vec[:, None]])
            return agent_setting

        else:
            # LP failed, reduce clusters and retry
            max_K -= 1
            attempt += 1

    # Final fallback: single uniform zero-cost action or empirical distribution over accepted max outcomes
    empirical_counts = np.zeros(m)
    for idx_i in accepted_idx:
        w_i = contracts[idx_i]
        max_outcome_idx = np.argmax(w_i)
        empirical_counts[max_outcome_idx] += 1
    if empirical_counts.sum() > 0:
        empirical_p = empirical_counts / empirical_counts.sum()
    else:
        empirical_p = np.ones(m) / m
    return np.hstack([empirical_p.reshape(1, -1), np.array([[0.0]])])
```
