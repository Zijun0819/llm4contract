```python
import numpy as np
from sklearn.cluster import KMeans
from scipy.optimize import linprog

def agent_solver_v2(v: np.ndarray, content: list[dict]) -> np.ndarray:
    """
    Infer a valid agent setting (n_actions x 6) matrix from historical logs.

    Each action row: [p1, p2, p3, p4, p5, cost],
    where p_i ≥ 0, sum p_i = 1, cost ≥ 0.

    Parameters:
    - v: np.ndarray shape (5,), principal reward vector.
    - content: list of dicts with keys 'Contract' (list/array 5),
      'Principal Utility' (float), and 'Agent Action' (1 or -1).

    Returns:
    - agent_setting: np.ndarray shape (n_actions, 6).
    """
    np.random.seed(42)
    m = v.size
    L = len(content)

    contracts = np.array([log['Contract'] for log in content])  # (L,5)
    agent_actions = np.array([log['Agent Action'] for log in content])  # (L,)
    accepted_idx = np.where(agent_actions == 1)[0]
    rejected_idx = np.where(agent_actions == -1)[0]

    # When no accepted contracts, fallback uniform zero-cost action
    if len(accepted_idx) == 0:
        uniform_p = np.ones(m) / m
        return np.hstack([uniform_p.reshape(1, -1), np.array([[0.0]])])

    accepted_contracts = contracts[accepted_idx]

    # Adaptive cluster count: roughly one cluster per ~10 accepted contracts, bounded [2..8]
    max_K = max(2, min(8, len(accepted_idx) // 10))
    if max_K > len(accepted_idx):
        max_K = len(accepted_idx)
    if max_K < 1:
        max_K = 1

    eps = 1e-5
    attempt = 0
    max_attempts = 5

    while attempt < max_attempts and max_K >= 1:
        # Cluster accepted contracts by contract payments ("wage vectors")
        kmeans = KMeans(n_clusters=max_K, random_state=0, n_init=20)
        try:
            kmeans.fit(accepted_contracts)
        except Exception:
            # fallback if clustering fails (e.g. all identical points)
            kmeans = None

        # Candidate distributions p_k per cluster center
        p_candidates = []
        if kmeans is None:
            # No clustering: treat all accepted contracts as one cluster
            centers_w = np.mean(accepted_contracts, axis=0).reshape(1, -1)
            max_K = 1
        else:
            centers_w = kmeans.cluster_centers_

        for w_k in centers_w:
            # Solve LP: max p @ w_k s.t p in simplex
            res = linprog(
                c=-w_k,
                A_eq=[np.ones(m)],
                b_eq=[1.0],
                bounds=[(0, 1)] * m,
                method='highs',
            )
            if res.success and res.x is not None:
                p_candidates.append(res.x)
            else:
                # fallback: put all mass on max w_k coordinate
                p = np.zeros(m)
                p[np.argmax(w_k)] = 1.0
                p_candidates.append(p)
        p_candidates = np.array(p_candidates)  # (max_K, 5)

        # Assign accepted contracts to clusters
        if kmeans is None:
            assigned_clusters = np.zeros(len(accepted_idx), dtype=int)
        else:
            assigned_clusters = kmeans.predict(accepted_contracts)

        # Build constraints on costs c_k (one cost per action k):
        # IR for accepted contracts: c_k ≤ p_k @ contract_i
        accepted_rows = []
        accepted_bounds = []
        for i, k in zip(accepted_idx, assigned_clusters):
            row = np.zeros(max_K)
            row[k] = -1.0  # -c_k
            bound = -np.dot(p_candidates[k], contracts[i])  # ≤ bound
            accepted_rows.append(row)
            accepted_bounds.append(bound)
        if accepted_rows:
            accepted_rows = np.array(accepted_rows)
            accepted_bounds = np.array(accepted_bounds)
        else:
            accepted_rows = np.empty((0, max_K))
            accepted_bounds = np.array([])

        # IC for rejected contracts: agent rejects all contracts -> for all k,
        # c_k > p_k @ contract_j → -c_k ≤ -(p_k @ contract_j) - eps
        rejected_rows = []
        rejected_bounds = []
        for j in rejected_idx:
            c_j = contracts[j]
            for k in range(max_K):
                row = np.zeros(max_K)
                row[k] = -1.0  # -c_k
                bound = -(np.dot(p_candidates[k], c_j) + eps)
                rejected_rows.append(row)
                rejected_bounds.append(bound)
        if rejected_rows:
            rejected_rows = np.array(rejected_rows)
            rejected_bounds = np.array(rejected_bounds)
        else:
            rejected_rows = np.empty((0, max_K))
            rejected_bounds = np.array([])

        # Combine constraints
        A_ub = np.vstack([accepted_rows, rejected_rows]) if (accepted_rows.size > 0 or rejected_rows.size > 0) else None
        b_ub = np.hstack([accepted_bounds, rejected_bounds]) if (accepted_bounds.size > 0 or rejected_bounds.size > 0) else None

        # Bounds: costs >= 0
        bounds_c = [(0, None)] * max_K

        # Objective: minimize sum of costs for parsimony
        obj = np.ones(max_K)

        # Solve LP for costs
        res_c = linprog(
            c=obj,
            A_ub=A_ub,
            b_ub=b_ub,
            bounds=bounds_c,
            method='highs',
        )

        if res_c.success and res_c.x is not None:
            costs = res_c.x
            # Filter out invalid costs (should not happen due to bounds)
            valid_mask = np.isfinite(costs) & (costs >= 0)
            if not np.any(valid_mask):
                max_K -= 1
                attempt += 1
                continue
            costs = costs[valid_mask]
            p_candidates = p_candidates[valid_mask]

            # Normalize p_candidates rows to sum to 1, clip negatives numerically
            for i in range(len(p_candidates)):
                p = p_candidates[i]
                p = np.maximum(p, 0)
                s = p.sum()
                if s <= 0:
                    p = np.ones(m) / m
                else:
                    p /= s
                p_candidates[i] = p

            costs = np.maximum(costs, 0)

            agent_setting = np.hstack([p_candidates, costs.reshape(-1, 1)])

            return agent_setting

        else:
            # LP infeasible or failed, reduce cluster count and retry
            max_K -= 1
            attempt += 1

    # Final fallback: single uniform zero-cost action,
    # use empirical distribution of accepted contracts' max outcomes if possible
    empirical_counts = np.zeros(m)
    for i in accepted_idx:
        contract = contracts[i]
        max_outcome = np.argmax(contract)
        empirical_counts[max_outcome] += 1
    if empirical_counts.sum() > 0:
        empirical_p = empirical_counts / empirical_counts.sum()
    else:
        empirical_p = np.ones(m) / m

    return np.hstack([empirical_p.reshape(1, -1), np.array([[0.0]])])
```
