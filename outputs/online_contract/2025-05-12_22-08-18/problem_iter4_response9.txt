```python
import numpy as np
from sklearn.cluster import AgglomerativeClustering

def agent_solver_v2(v: np.ndarray, content: list[dict]) -> np.ndarray:
    """
    Improved inference of a valid agent setting (actions = distributions + cost)
    consistent with historical contract logs.

    Params:
        v (np.ndarray): Principal's value vector (length 5)
        content (list[dict]): each dict has keys: 'Contract' (list of 5),
                              'Principal Utility' (float),
                              'Agent Action' (1 or -1)
    Returns:
        np.ndarray: n_actions x 6 (5 probabilities + 1 cost)
    """
    m_outcomes = v.size
    L = len(content)

    # Prepare arrays
    contracts = np.array([log['Contract'] for log in content])  # shape (L,5)
    ag_actions = np.array([log['Agent Action'] for log in content])  # shape (L,)
    p_util = np.array([log['Principal Utility'] for log in content])  # shape (L,)

    accepted_ix = np.where(ag_actions == 1)[0]
    rejected_ix = np.where(ag_actions == -1)[0]

    # If no accepted contracts, return trivial uniform action with zero cost
    if accepted_ix.size == 0:
        p_uniform = np.ones(m_outcomes) / m_outcomes
        return np.hstack([p_uniform.reshape(1, -1), np.array([[0.0]])])

    accepted_w = contracts[accepted_ix]
    accepted_util = p_util[accepted_ix]

    # Normalize accepted contracts to sum 1 for clustering (avoid zero-sum issues)
    norm_w = accepted_w / (accepted_w.sum(axis=1, keepdims=True) + 1e-12)

    # Adaptive number of clusters:
    # min among 10, len(accepted_ix), and int(sqrt(len(accepted_ix))) but at least 1
    n_clusters = max(1, min(10, len(accepted_ix), int(np.sqrt(len(accepted_ix)))))
    if n_clusters > 1:
        clustering = AgglomerativeClustering(n_clusters=n_clusters, linkage='average')
        labels = clustering.fit_predict(norm_w)
    else:
        labels = np.zeros(len(accepted_ix), dtype=int)

    p_candidates = []
    costs_lower_bound = []

    # For each cluster, compute a robust p and estimate cost lower bound
    for c in range(n_clusters):
        cluster_indices = accepted_ix[labels == c]
        if cluster_indices.size == 0:
            continue
        cluster_w = contracts[cluster_indices]
        cluster_util = accepted_util[labels == c]

        # Weight accepted contracts within cluster by (util - min_util + 1) to favor better contracts
        min_util = cluster_util.min()
        weights = cluster_util - min_util + 1
        weights_sum = weights.sum()
        if weights_sum < 1e-12:
            weights = np.ones_like(weights)  # fallback uniform weights
            weights_sum = weights.sum()
        weights = weights / weights_sum

        # Weighted average contract vector (not necessarily summing to 1)
        avg_w = np.average(cluster_w, axis=0, weights=weights)

        # Project avg_w to probability simplex (clip negatives, renormalize)
        p = np.clip(avg_w, 0, None)
        psum = p.sum()
        if psum < 1e-12:
            p = np.ones(m_outcomes) / m_outcomes
        else:
            p = p / psum

        p_candidates.append(p)

        # Agent cost must be <= p @ w_i for accepted contracts in cluster (IR)
        # Use min of p @ w_i to not overestimate cost (tighter lower bound)
        costs_cluster = np.array([p @ contracts[i] for i in cluster_indices])
        cost_lb = costs_cluster.min()
        costs_lower_bound.append(cost_lb)

    p_candidates = np.array(p_candidates)
    costs_lower_bound = np.array(costs_lower_bound)

    # Handle rejected contracts: agent utility < 0 for all actions
    if rejected_ix.size > 0:
        reject_w = contracts[rejected_ix]  # (#rej,5)
        # Compute p_a @ w_j for all actions and rejected contracts: shape (n_actions, #rej)
        p_w_rej = p_candidates @ reject_w.T
        # Cost must be strictly > max over rejected contracts of p_a @ w_j to guarantee rejection
        c_rej_min = p_w_rej.max(axis=1) + 1e-7  # small margin
    else:
        c_rej_min = np.zeros(len(p_candidates))

    # Final agent cost lower bound is max of accepted IR lower bounds and rejection lower bounds
    costs = np.maximum(costs_lower_bound, c_rej_min)
    costs = np.maximum(costs, 0)

    # Function to check if contract w_i is rationalized by some action (p,c)
    def valid_action_for_contract(w_i):
        utilities = p_candidates @ w_i - costs
        valid_actions = np.where(utilities >= -1e-9)[0]
        if valid_actions.size > 0:
            return valid_actions[0]
        else:
            return None

    # Add new actions for any accepted contract not explained by current candidates
    for i in accepted_ix:
        w_i = contracts[i]
        if valid_action_for_contract(w_i) is None:
            # New action p = normalized contract vector w_i (clip and normalize)
            p_new = np.clip(w_i, 0, None)
            s = p_new.sum()
            if s < 1e-12:
                p_new = np.ones(m_outcomes) / m_outcomes
            else:
                p_new = p_new / s
            c_new = p_new @ w_i  # exact agent cost to accept this contract
            p_candidates = np.vstack([p_candidates, p_new])
            costs = np.append(costs, c_new)

    # After adding new actions, re-validate rejection constraints and increase costs if needed
    if rejected_ix.size > 0:
        reject_w = contracts[rejected_ix]
        p_w_rej = p_candidates @ reject_w.T
        for a in range(len(p_candidates)):
            max_rej_util = p_w_rej[a].max()
            if costs[a] < max_rej_util + 1e-9:
                costs[a] = max_rej_util + 1e-4  # small safety margin

    # Final normalization to ensure valid probability distributions (nonnegative and sum to 1)
    p_candidates = np.clip(p_candidates, 0, None)
    psums = p_candidates.sum(axis=1, keepdims=True)
    psums[psums < 1e-12] = 1.0  # avoid div by zero
    p_candidates /= psums

    # Ensure costs are nonnegative
    costs = np.maximum(costs, 0)

    # Assemble final agent setting matrix: [p vector | cost]
    agent_setting = np.hstack([p_candidates, costs[:, None]])

    return agent_setting
```
