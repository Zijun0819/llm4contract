```python
import numpy as np
import pandas as pd
from scipy.optimize import linprog
from sklearn.cluster import DBSCAN


def agent_solver_v2(v: np.ndarray, content: list[dict]) -> np.ndarray:
    """
    Infer a valid agent setting (probability distributions over outcomes with costs)
    that rationalizes the historical logs of contract offers, principal utility, and
    agent acceptance/rejection.

    This version uses a custom clustering approach (DBSCAN) to find diverse agent actions,
    enforces IC and IR via a convex feasibility linear program for each cluster,
    and accounts for rejection logs to separate feasible vs infeasible agent utilities.
    """
    m = len(v)         # number of outcomes (should be 5)
    L = len(content)   # number of logs

    # Parse logs into arrays for convenience
    contracts = np.array([log['Contract'] for log in content])   # shape (L, m)
    utilities = np.array([log['Principal Utility'] for log in content])  # shape (L,)
    actions = np.array([log['Agent Action'] for log in content]) # shape (L,)

    # Step 1: Construct agent expected utilities for accepted contracts
    # agent utility under contract w and action (p,c) is p @ w - c >= 0 iff accepted (1)
    # rejected contracts yield agent utility < 0

    # We'll extract candidate agent distributions p from accepted logs via normalization:
    # Since accepted means p @ w - c >= 0 for some c ≥ 0,
    # the agent distribution p can be approximated by normalizing the contract payments
    # by their total (proxy since p is a prob distribution).
    # This is a heuristic to seed the clustering.

    accepted_idx = np.where(actions == 1)[0]
    rejected_idx = np.where(actions == -1)[0]

    if len(accepted_idx) == 0:
        # fallback: single uniform agent type with zero cost
        uniform_p = np.ones(m) / m
        return np.hstack([uniform_p, np.zeros(1)])

    # Normalize accepted contracts to probability distributions as initial agent action candidates
    p_candidates = []
    for i in accepted_idx:
        w = contracts[i]
        total = w.sum()
        # avoid division by zero and very small sum, normalize if sum > small threshold
        if total > 1e-8:
            p_cand = w / total
            p_candidates.append(p_cand)
    p_candidates = np.array(p_candidates)
    if len(p_candidates) == 0:
        # fallback
        uniform_p = np.ones(m) / m
        return np.hstack([uniform_p, np.zeros(1)])

    # Step 2: Cluster candidate distributions to get distinct agent types
    # Use DBSCAN to detect groups of similar point-cloud agent types with noise outliers
    clustering = DBSCAN(eps=0.15, min_samples=3, metric='euclidean')
    labels = clustering.fit_predict(p_candidates)
    unique_labels = np.unique(labels[labels >= 0])  # ignore noise points labeled -1

    # If DBSCAN fails to find clusters, fallback to use all as single cluster
    if len(unique_labels) == 0:
        unique_labels = np.array([0])
        labels = np.zeros(len(p_candidates), dtype=int)

    # For each cluster, compute centroid p (projection onto simplex to ensure probs)
    def project_to_simplex(y):
        """Projects y onto the simplex sum(y)==1, y>=0."""
        sorted_y = np.sort(y)[::-1]
        tmpsum = 0.0
        t_hat = 0.0
        for i in range(len(y)):
            tmpsum += sorted_y[i]
            t_temp = (tmpsum - 1) / (i + 1)
            if i == len(y) - 1 or t_temp >= sorted_y[i + 1]:
                t_hat = t_temp
                break
        x = np.maximum(y - t_hat, 0)
        return x

    agent_ps = []
    for lab in unique_labels:
        cluster_points = p_candidates[labels == lab]
        mean_p = cluster_points.mean(axis=0)
        agent_ps.append(project_to_simplex(mean_p))
    agent_ps = np.array(agent_ps)

    n_agents = len(agent_ps)

    # Step 3: For each agent (consisting of p), find minimal cost c by LP ensuring:
    # For all accepted contracts i with Agent Action=1, p_a @ w_i - c >= 0  (IR)
    # For all rejected contracts i with Agent Action=-1, p_a @ w_i - c < 0  (IR)
    # and IC: accepted contract expected utility ≥ expected utility of any other cluster action a'
    # i.e., for accepted contracts assigned to action a:
    #    p_a @ w_i - c_a >= p_j @ w_i - c_j   for all j ≠ a

    # We don't know assignments of accepted logs to agent types precisely,
    # so we approximate assignments by max utility under types ignoring costs at first.
    utilities_mat = contracts @ agent_ps.T  # shape (L, n_agents)

    # Initial assignment: For accepted contracts, assign agent type maximizing expected utility (without cost)
    assigned_actions = np.full(L, -1, dtype=int)
    for i in accepted_idx:
        assigned_actions[i] = int(np.argmax(utilities_mat[i]))

    # For rejected contracts, no assignment; they enforce utilities < 0 for all types

    # Step 4: Formulate LP to find minimal costs c_a per agent action a satisfying:
    # For each accepted i assigned to a:
    #   p_a @ w_i - c_a >= 0            (IR)
    #   p_a @ w_i - c_a >= p_j @ w_i - c_j  for all j != a  (IC)
    # For each rejected i:
    #   p_a @ w_i - c_a < 0   for all a

    # The LP variables: c = [c_0, c_1, ..., c_{n_agents-1}] costs, all >= 0

    # We'll formulate constraints:
    # For each accepted i (assigned to a):
    #   c_a <= p_a @ w_i
    #   c_a - c_j >= p_a @ w_i - p_j @ w_i for all j != a
    # For each rejected i and each agent a:
    #   c_a > p_a @ w_i (strict). 
    # Since LP cannot handle strict inequalities, use c_a >= p_a @ w_i + epsilon with small epsilon

    epsilon = 1e-6

    from scipy.optimize import linprog

    # Objective: minimize sum of costs to encourage minimal costs
    c_obj = np.ones(n_agents)

    # Build constraint matrices A_ub x <= b_ub, A_eq x = b_eq

    A_ub_list = []
    b_ub_list = []
    # c_a <= p_a @ w_i -> c_a - t <= 0 where t = p_a @ w_i
    # equivalently -c_a <= -t

    for a in range(n_agents):
        # accepted assigned to a:
        accepted_idxs = np.where(assigned_actions == a)[0]
        for i in accepted_idxs:
            pay = np.dot(agent_ps[a], contracts[i])
            # c_a <= pay
            row = np.zeros(n_agents)
            row[a] = -1  # -c_a <= -pay
            A_ub_list.append(row)
            b_ub_list.append(-pay)

    # IC constraints:
    # For accepted i assigned to a and for all j != a:
    #   (c_a - c_j) >= (p_a - p_j) @ w_i  <=>  (c_j - c_a) <= -(p_a - p_j) @ w_i
    for a in range(n_agents):
        accepted_idxs = np.where(assigned_actions == a)[0]
        for i in accepted_idxs:
            pay_a = np.dot(agent_ps[a], contracts[i])
            for j in range(n_agents):
                if j == a:
                    continue
                pay_j = np.dot(agent_ps[j], contracts[i])
                val = -(pay_a - pay_j)  # RHS
                row = np.zeros(n_agents)
                row[j] = 1
                row[a] = -1
                A_ub_list.append(row)
                b_ub_list.append(val)

    # Rejection constraints:
    # For all rejected i and all agents a:
    #   p_a @ w_i - c_a < 0  =>  c_a > p_a @ w_i  =>  c_a >= p_a @ w_i + epsilon
    #   -c_a <= -p_a @ w_i - epsilon
    for i in rejected_idx:
        for a in range(n_agents):
            pay = np.dot(agent_ps[a], contracts[i])
            row = np.zeros(n_agents)
            row[a] = -1
            A_ub_list.append(row)
            b_ub_list.append(-pay - epsilon)

    # Costs >= 0
    bounds = [(0, None)] * n_agents

    A_ub = np.array(A_ub_list)
    b_ub = np.array(b_ub_list)
    # No equality constraints
    res = linprog(c=c_obj, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')

    if not res.success:
        # fallback: zero costs (possibly infeasible) but ensure non-neg cost
        costs = np.zeros(n_agents)
    else:
        costs = res.x
        costs = np.maximum(costs, 0)

    # Final agent setting matrix of shape (n_agents, m+1)
    agent_setting = np.hstack([agent_ps, costs[:, None]])

    return agent_setting
```
