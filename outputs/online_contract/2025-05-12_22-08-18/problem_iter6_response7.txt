```python
import numpy as np
from sklearn.cluster import AgglomerativeClustering

def agent_solver_v2(v: np.ndarray, content: list[dict]) -> np.ndarray:
    """
    Infer a valid agent setting matrix from historical contract interactions,
    satisfying IR and IC constraints for agent actions, consistent with data.

    Params:
        v (np.ndarray): Principal's value vector of length 5.
        content (list[dict]): Historical logs with keys:
            'Contract' (list of 5 floats),
            'Principal Utility' (float),
            'Agent Action' (1 or -1).

    Returns:
        np.ndarray: n_actions x 6 matrix, each row:
            first 5 entries = outcome probabilities (sum to 1),
            last entry = nonnegative cost.
    """
    m = v.size
    L = len(content)

    # Parse logs
    contracts = np.array([log['Contract'] for log in content], dtype=np.float64)  # (L,5)
    ag_actions = np.array([log['Agent Action'] for log in content], dtype=int)   # (L,)
    p_utils = np.array([log['Principal Utility'] for log in content], dtype=np.float64)  # (L,)

    accepted_idx = np.where(ag_actions == 1)[0]
    rejected_idx = np.where(ag_actions == -1)[0]

    # If no accepted contracts, return trivial uniform action with zero cost
    if accepted_idx.size == 0:
        p_uniform = np.ones(m) / m
        return np.hstack([p_uniform, [0.0]]).reshape(1, -1)

    accepted_contracts = contracts[accepted_idx]  # (Na, 5)
    accepted_utils = p_utils[accepted_idx]

    # Normalize accepted contracts by their sum (to cluster in simplex)
    sums = accepted_contracts.sum(axis=1, keepdims=True)
    sums[sums < 1e-12] = 1.0
    norm_contracts = accepted_contracts / sums

    # Adaptive number of clusters
    n_accepted = accepted_idx.size
    max_clusters = min(10, n_accepted)
    n_clusters = max(1, int(np.sqrt(n_accepted)))
    n_clusters = min(n_clusters, max_clusters)

    clustering = AgglomerativeClustering(n_clusters=n_clusters, linkage='average')
    cluster_labels = clustering.fit_predict(norm_contracts)

    p_actions = []
    costs_lb = []

    # For each cluster, compute weighted average vector and cost lower bound
    for c in range(n_clusters):
        cluster_mask = (cluster_labels == c)
        if not np.any(cluster_mask):
            continue
        cluster_contracts = accepted_contracts[cluster_mask]
        cluster_utils = accepted_utils[cluster_mask]

        # Weights: shift utilities to be positive +1 to favor better contracts
        wts = cluster_utils - cluster_utils.min() + 1.0

        avg_w = np.average(cluster_contracts, axis=0, weights=wts)
        avg_w = np.clip(avg_w, 0, None)
        s = avg_w.sum()
        if s < 1e-12:
            p_cand = np.ones(m) / m
        else:
            p_cand = avg_w / s

        p_actions.append(p_cand)

        # Cost lower bound: agent utility >= 0 => cost <= p @ w_i for accepted contracts in cluster
        p_dot_w = cluster_contracts @ p_cand  # (cluster_size,)
        cost_lb = p_dot_w.min()  # minimal p@w in cluster (lower bound on cost)
        costs_lb.append(cost_lb)

    if len(p_actions) == 0:
        # fallback uniform action zero cost
        p_actions = [np.ones(m) / m]
        costs_lb = [0.0]

    p_actions = np.vstack(p_actions)  # (n_actions, 5)
    costs_lb = np.array(costs_lb)

    # For rejected contracts: cost must be strictly greater than max p@w over rejects
    if rejected_idx.size > 0:
        rejected_contracts = contracts[rejected_idx]  # (#rej,5)
        p_dot_rej = p_actions @ rejected_contracts.T  # (n_actions, #rej)
        c_rej_min = p_dot_rej.max(axis=1) + 1e-6
    else:
        c_rej_min = np.zeros(len(p_actions), dtype=np.float64)

    # Final cost = max (cost lower bound on accepted, cost lower bound on rejects), clipped >= 0
    costs = np.maximum(costs_lb, c_rej_min)
    costs = np.clip(costs, 0, None)

    # Function to check if an accepted contract w_i can be rationalized by any existing action
    def is_explained(w_i: np.ndarray):
        utils = p_actions @ w_i - costs  # (n_actions,)
        return np.any(utils >= -1e-8)

    # Add precise actions for any accepted contract not explained
    for i in accepted_idx:
        w_i = contracts[i]
        if not is_explained(w_i):
            p_new = w_i.copy()
            s = p_new.sum()
            if s < 1e-12:
                p_new = np.ones(m) / m
            else:
                p_new = p_new / s
            c_new = max(p_new @ w_i, 0.0)
            p_actions = np.vstack([p_actions, p_new])
            costs = np.append(costs, c_new)

    # After augmentation, recheck rejection constraints and fix costs if violated
    if rejected_idx.size > 0:
        rejected_contracts = contracts[rejected_idx]
        p_dot_rej = p_actions @ rejected_contracts.T  # (n_actions, #rej)
        for a in range(len(costs)):
            max_rej_util = p_dot_rej[a].max()
            if costs[a] < max_rej_util + 1e-8:
                costs[a] = max_rej_util + 1e-4  # small margin

    # Normalize p_actions to simplex (clip and renormalize)
    p_actions = np.clip(p_actions, 0, None)
    row_sums = p_actions.sum(axis=1, keepdims=True)
    row_sums[row_sums < 1e-12] = 1.0
    p_actions /= row_sums

    costs = np.clip(costs, 0, None)

    agent_setting = np.hstack([p_actions, costs[:, None]])
    return agent_setting
```
