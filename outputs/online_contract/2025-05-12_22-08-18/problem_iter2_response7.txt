```python
import numpy as np
from sklearn.cluster import KMeans
from scipy.optimize import linprog

def agent_solver_v2(v: np.ndarray, content: list[dict]) -> np.ndarray:
    """
    Infer a valid agent setting matrix given principal reward vector v and historical interaction logs content.
    The inference:
    - Find a minimal set of agent actions (distributions over outcomes + costs) that rationalize accept/reject logs.
    - Leverage clustering and constrained LP optimization for IR and IC constraints simultaneously.

    Parameters:
    - v: np.ndarray, shape (5,), principal reward vector per outcome.
    - content: list of dicts with keys 'Contract', 'Principal Utility', 'Agent Action'.

    Returns:
    - agent_setting: np.ndarray, shape (n_actions, 6), each row [p1, p2, p3, p4, p5, cost].
    """
    contracts = np.array([log['Contract'] for log in content])  # L x 5
    agent_actions = np.array([log['Agent Action'] for log in content])  # L,
    # principal_utils = np.array([log['Principal Utility'] for log in content])  # Not directly used here

    L = len(content)
    m = v.size

    accepted_indices = np.where(agent_actions == 1)[0]
    rejected_indices = np.where(agent_actions == -1)[0]

    # If no accepted contracts, fallback with one uniform action zero cost
    if len(accepted_indices) == 0:
        p_uniform = np.ones(m) / m
        return np.hstack([p_uniform.reshape(1, -1), np.array([[0.0]])])

    accepted_contracts = contracts[accepted_indices]

    max_candidates = min(8, len(accepted_indices))  # heuristic cap on number of actions

    # Cluster accepted contracts to identify candidate actions
    kmeans = KMeans(n_clusters=max_candidates, random_state=42, n_init=15)
    assigns = kmeans.fit_predict(accepted_contracts)  # length == accepted contracts count

    n = max_candidates

    # Helper indexing functions for variable vector x
    # Variables x layout: [p_0_0,...p_0_m-1, p_1_0,...p_1_m-1, ..., p_n-1_0,...p_n-1_m-1, c_0,...,c_n-1]
    def idx_p(a, outcome): return a * m + outcome
    def idx_c(a): return n * m + a

    A_ub = []
    b_ub = []

    # IR constraints for accepted contracts:
    # For each accepted contract i assigned to cluster a:
    # p_a @ w_i - c_a >= 0  --> -p_a @ w_i + c_a <= 0
    for idx_i, a in enumerate(assigns):
        i = accepted_indices[idx_i]
        w = contracts[i]
        row = np.zeros(n * m + n)
        for o in range(m):
            row[idx_p(a, o)] = -w[o]
        row[idx_c(a)] = 1.0
        A_ub.append(row)
        b_ub.append(0.0)

    # IC constraints for rejected contracts:
    # For each rejected contract j and each action a:
    # p_a @ w_j - c_a <= -epsilon  with small epsilon>0
    epsilon = 1e-4
    for j in rejected_indices:
        w = contracts[j]
        for a in range(n):
            row = np.zeros(n * m + n)
            for o in range(m):
                row[idx_p(a, o)] = w[o]
            row[idx_c(a)] = -1.0
            A_ub.append(row)
            b_ub.append(-epsilon)

    A_ub = np.array(A_ub) if A_ub else None
    b_ub = np.array(b_ub) if b_ub else None

    # Equality constraints: for each action a, sum_o p_a[o] == 1
    A_eq = np.zeros((n, n * m + n))
    b_eq = np.ones(n)
    for a in range(n):
        for o in range(m):
            A_eq[a, idx_p(a, o)] = 1.0

    # Bounds: p_a[o] in [0,1], c_a >= 0
    bounds = [(0, 1)] * (n * m) + [(0, None)] * n

    # Objective: minimize sum of costs to prefer minimal agent costs
    c_obj = np.zeros(n * m + n)
    c_obj[n * m:] = 1.0

    # Solve LP
    res = linprog(
        c=c_obj,
        A_ub=A_ub,
        b_ub=b_ub,
        A_eq=A_eq,
        b_eq=b_eq,
        bounds=bounds,
        method='highs',
    )

    # If LP fails, fallback: uniform p, zero cost for accepted clusters, no reject consistency
    if not (res.success and res.x is not None):
        p_uniform = np.ones(m) / m
        fallback_actions = min(3, n)
        agent_setting = np.vstack([np.append(p_uniform, 0.0) for _ in range(fallback_actions)])
        return agent_setting

    x = res.x
    p_mat = x[: n * m].reshape(n, m)
    c_vec = x[n * m: n * m + n]

    # Simplex projection helper to correct minor numerical violations
    def project_simplex(vec):
        """Project vector onto probability simplex."""
        u = np.sort(vec)[::-1]
        cssv = np.cumsum(u)
        rho = np.nonzero(u + (1.0 - cssv) / np.arange(1, len(vec) + 1) > 0)[0]
        if len(rho) == 0:
            # fallback uniform if no positive rho found
            return np.ones_like(vec) / len(vec)
        rho = rho[-1]
        theta = (cssv[rho] - 1) / (rho + 1)
        w = np.maximum(vec - theta, 0)
        return w

    for i in range(n):
        p_mat[i] = project_simplex(p_mat[i])
        if c_vec[i] < 0:
            c_vec[i] = 0.0

    agent_setting = np.hstack([p_mat, c_vec[:, None]])
    return agent_setting
```
