```python
import numpy as np
import pandas as pd
from sklearn.cluster import KMeans
from scipy.optimize import linprog

def agent_solver_v2(v: np.ndarray, content: list[dict]) -> np.ndarray:
    """
    Infer a valid agent setting matrix [p1,...p5,cost] from historical contract logs,
    satisfying IR (individual rationality) and IC (incentive compatibility) constraints.

    Args:
        v: Principal's reward vector for 5 outcomes, shape (5,)
        content: List of logs, each a dict with keys:
            'Contract': list of 5 payments,
            'Principal Utility': float,
            'Agent Action': int (1 for accept, -1 for reject)

    Returns:
        agent_setting: n_actions x 6 matrix, each row = [p1,...p5,cost]
          where p_i form a probability distribution and cost >= 0.
    """
    # Prepare data
    logs = pd.DataFrame(content)
    contracts = np.vstack(logs['Contract'].values)  # L x 5
    princ_utils = logs['Principal Utility'].values  # L
    agent_actions = logs['Agent Action'].values     # L
    L, m = contracts.shape

    # Masks for accepted and rejected contracts
    accept_mask = agent_actions == 1
    reject_mask = agent_actions == -1

    contracts_accept = contracts[accept_mask]
    princ_utils_accept = princ_utils[accept_mask]

    contracts_reject = contracts[reject_mask] if np.any(reject_mask) else np.empty((0, m))

    n_accept = contracts_accept.shape[0]
    n_reject = contracts_reject.shape[0]

    # -------------------------------
    # Step 1: Infer candidate outcome distributions p for accepted contracts
    # For each accepted contract w, solve LP:
    #   max_p p·w s.t sum p =1, p>=0
    # This finds a distribution maximizing expected payment => proxy for agent's preferred outcome distribution
    def solve_max_p(w: np.ndarray) -> np.ndarray:
        c_obj = -w  # minimize -p·w = maximize p·w
        A_eq = np.ones((1, m))
        b_eq = np.array([1.0])
        bounds = [(0, 1)] * m
        res = linprog(c_obj, A_eq=A_eq, b_eq=b_eq, bounds=bounds, method='highs')
        if res.success:
            return res.x
        else:
            # fallback uniform distribution if LP failed
            return np.ones(m) / m

    pseudo_ps = np.array([solve_max_p(w) for w in contracts_accept])

    # In rare case no accepted contracts, fallback to one uniform action
    if n_accept == 0:
        return np.hstack([np.ones((1, m)) / m, np.array([[0.0]])])

    # -------------------------------
    # Step 2: Cluster candidate distributions into representative agent actions
    max_actions = min(10, max(1, n_accept // 8))  # heuristic cap on number of actions
    if n_accept < max_actions:
        max_actions = n_accept  # no more clusters than accepted contracts

    # Use KMeans clustering for stable, fast clustering
    try:
        kmeans = KMeans(n_clusters=max_actions, random_state=42, n_init=20)
        clusters = kmeans.fit_predict(pseudo_ps)
        p_actions = kmeans.cluster_centers_
    except Exception:
        # fallback: single cluster average
        p_actions = np.mean(pseudo_ps, axis=0, keepdims=True)
        clusters = np.zeros(n_accept, dtype=int)

    # Normalize clusters' centroids to ensure valid probability distributions
    p_actions = np.clip(p_actions, 0, None)
    p_actions /= np.maximum(p_actions.sum(axis=1, keepdims=True), 1e-12)
    n_actions = p_actions.shape[0]

    # -------------------------------
    # Step 3: Assign each accepted contract to the action maximizing agent expected utility ignoring cost
    assigns = np.zeros(n_accept, dtype=int)
    for i, w in enumerate(contracts_accept):
        expected_utils = p_actions @ w  # shape: (n_actions,)
        assigns[i] = np.argmax(expected_utils)

    # -------------------------------
    # Step 4: Set up LP to infer minimal costs c_a >=0 for each action a
    # Constraints:
    # - IR on accepted contracts assigned to a: c_a <= p_a · w_i
    # - IC on rejected contracts: for all a, c_a > p_a · w_j (strict)
    # Relax strict inequality by epsilon

    eps = 1e-7
    n_vars = n_actions  # c_0,...,c_{n_actions-1}

    # Objective: minimize sum of costs (to keep costs as low as possible)
    c_obj = np.ones(n_vars)

    A_ub = []
    b_ub = []

    # IR constraints: c_a <= p_a · w_i  =>  c_a - (p_a·w_i) <= 0
    for i, a in enumerate(assigns):
        row = np.zeros(n_vars)
        row[a] = 1
        rhs = np.dot(p_actions[a], contracts_accept[i])
        A_ub.append(row)
        b_ub.append(rhs)

    # IC constraints: for each rejected contract w_j and action a:
    # c_a > p_a · w_j  =>  -c_a < -p_a · w_j  =>  -c_a <= -p_a · w_j - eps
    # => add constraint: -c_a <= -p_a·w_j - eps
    for w_j in contracts_reject:
        for a in range(n_actions):
            row = np.zeros(n_vars)
            row[a] = -1
            rhs = -np.dot(p_actions[a], w_j) - eps
            A_ub.append(row)
            b_ub.append(rhs)

    A_ub = np.array(A_ub) if len(A_ub) > 0 else None
    b_ub = np.array(b_ub) if len(b_ub) > 0 else None

    bounds = [(0, None) for _ in range(n_vars)]

    res = linprog(
        c=c_obj,
        A_ub=A_ub,
        b_ub=b_ub,
        bounds=bounds,
        method='highs',
        options={'presolve': True}
    )

    # If LP fails, try relaxing IC constraints (reject constraints)
    if not res.success:
        # Remove IC constraints (the last n_reject*n_actions constraints)
        if A_ub is not None and n_reject > 0:
            n_ir_constraints = n_accept
            A_ub_relaxed = A_ub[:n_ir_constraints] if n_ir_constraints > 0 else None
            b_ub_relaxed = b_ub[:n_ir_constraints] if n_ir_constraints > 0 else None
        else:
            A_ub_relaxed = None
            b_ub_relaxed = None

        res = linprog(
            c=c_obj,
            A_ub=A_ub_relaxed,
            b_ub=b_ub_relaxed,
            bounds=bounds,
            method='highs',
            options={'presolve': True}
        )

        if not res.success:
            # fail-safe: zero costs
            costs = np.zeros(n_vars)
        else:
            costs = np.clip(res.x, 0, None)
    else:
        costs = np.clip(res.x, 0, None)

    # -------------------------------
    # Step 5: Postprocessing
    # (a) Ensure p_actions sum to 1 and nonnegative
    p_actions = np.clip(p_actions, 0, None)
    p_actions /= np.maximum(p_actions.sum(axis=1, keepdims=True), 1e-12)

    # (b) Ensure costs non-negative and bounded below by zero
    costs = np.maximum(costs, 0.0)

    # -------------------------------
    # Step 6: Compose agent setting matrix: shape (n_actions, 6)
    # Each row: [p1,...p5, cost]
    agent_setting = np.hstack([p_actions, costs[:, None]])

    return agent_setting
```
