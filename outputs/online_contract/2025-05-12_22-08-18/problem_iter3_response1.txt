```python
import numpy as np
from sklearn.cluster import AgglomerativeClustering
from scipy.optimize import linprog

def agent_solver_v2(v: np.ndarray, content: list[dict]) -> np.ndarray:
    """
    Infer a valid agent setting (actions = distributions over outcomes + cost)
    consistent with historical contract logs.

    Params:
        v (np.ndarray): Principal's value vector (length 5)
        content (list[dict]): each dict has keys: 'Contract' (list of 5),
                              'Principal Utility' (float),
                              'Agent Action' (1 or -1)
    Returns:
        np.ndarray: n_actions x 6 (5 probabilities + 1 cost)
    """
    m_outcomes = v.size
    L = len(content)

    # Prepare arrays for easier manipulation
    contracts = np.array([log['Contract'] for log in content])  # shape (L,5)
    ag_actions = np.array([log['Agent Action'] for log in content])  # shape (L,)
    p_util = np.array([log['Principal Utility'] for log in content])  # shape (L,)

    accepted_ix = np.where(ag_actions == 1)[0]
    rejected_ix = np.where(ag_actions == -1)[0]

    # If no accepted contracts, return uniform distributions with zero cost (trivial)
    if accepted_ix.size == 0:
        p_uniform = np.ones(m_outcomes) / m_outcomes
        return np.hstack([p_uniform.reshape(1, -1), np.array([[0]])])

    accepted_w = contracts[accepted_ix]

    # Normalize accepted contracts by their sum to get shape for clustering
    norm_w = accepted_w / (accepted_w.sum(axis=1, keepdims=True) + 1e-16)

    # Adaptive number of clusters: min between 10 and sqrt of accepted samples, at least 1
    n_clusters = min(10, max(1, int(np.sqrt(len(accepted_ix)))))
    clustering = AgglomerativeClustering(n_clusters=n_clusters, linkage="average")
    labels = clustering.fit_predict(norm_w)

    # Initialize lists to hold candidate actions (probability vectors and costs)
    p_candidates = []
    costs_lb = []

    # For each cluster, infer a candidate distribution p and corresponding minimal cost
    for c in range(n_clusters):
        cluster_mask = (labels == c)
        cluster_ix = accepted_ix[cluster_mask]
        if cluster_ix.size == 0:
            continue
        cluster_contracts = contracts[cluster_ix]

        # Step 1: estimate p by solving LP to maximize dot(p, v) subject to:
        # p @ w_i - cost >= 0 for some cost >=0, but cost unknown
        # Approximate by ensuring p @ w_i >= 0 for all cluster contracts (simulate cost=0)
        #
        # To get p: maximize p.v s.t. p.w_i >= 0 for all i in cluster, p in simplex

        # Build LP:
        # max c^T p = v^T p
        # s.t. A_ub p <= b_ub
        #     p >= 0
        #     sum(p) = 1

        # Constraints: For each contract w_i, -w_i @ p <= 0  <=> w_i @ p >=0
        A_ub = -cluster_contracts  # shape (n_contracts, m_outcomes)
        b_ub = np.zeros(cluster_contracts.shape[0])

        # Equality: sum p =1
        A_eq = np.ones((1, m_outcomes))
        b_eq = np.array([1])

        # Bounds p_j in [0,1]
        bounds = [(0,1) for _ in range(m_outcomes)]

        # linprog minimizes, so maximize v^T p = minimize -v^T p
        res = linprog(
            c=-v,
            A_ub=A_ub,
            b_ub=b_ub,
            A_eq=A_eq,
            b_eq=b_eq,
            bounds=bounds,
            method='highs',
        )
        if res.success:
            p = res.x
        else:
            # fallback: uniform distribution
            p = np.ones(m_outcomes) / m_outcomes

        # Compute minimal cost to rationalize acceptance for cluster contracts:
        # cost <= min_i p @ w_i since agent utility >=0 means cost <= p @ w_i
        p_dot_w = cluster_contracts @ p
        min_cost = np.min(p_dot_w)
        min_cost = max(min_cost, 0.0)  # cost non-negative

        p_candidates.append(p)
        costs_lb.append(min_cost)

    p_candidates = np.array(p_candidates)
    costs_lb = np.array(costs_lb)

    # For rejected contracts, impose rejection constraints:
    # For each rejected contract r and each action a:
    # p_a @ w_r - cost_a < 0  => cost_a > p_a @ w_r
    if rejected_ix.size > 0:
        reject_contracts = contracts[rejected_ix]
        p_w_rej = p_candidates @ reject_contracts.T  # shape (n_actions, #rej)
        c_rej_min = p_w_rej.max(axis=1)
        c_rej_min = np.maximum(c_rej_min, 0.0)
    else:
        c_rej_min = np.zeros(len(p_candidates))

    # Costs must satisfy cost >= max(min_cost_from_acceptance, rejection_threshold)
    costs = np.maximum(costs_lb, c_rej_min)

    # Validate all accepted contracts can be rationalized by some action:
    # If not, add new action with cost = p@w (single contract distribution)
    def can_be_explained(w):
        for p, c in zip(p_candidates, costs):
            if (p @ w - c) >= -1e-9:
                return True
        return False

    added_new = True
    # Iteratively add new actions until all accepted contracts explained or max iterations
    max_iters = 10
    iter_i = 0
    while added_new and iter_i < max_iters:
        added_new = False
        for i in accepted_ix:
            w_i = contracts[i]
            if not can_be_explained(w_i):
                # Add new action exactly fitting this contract:
                p_new = w_i.copy()
                s = p_new.sum()
                if s > 1e-16:
                    p_new /= s
                else:
                    p_new = np.ones(m_outcomes) / m_outcomes
                c_new = p_new @ w_i
                if c_new < 0:
                    c_new = 0.0
                p_candidates = np.vstack([p_candidates, p_new])
                costs = np.append(costs, c_new)
                added_new = True
        iter_i += 1

    # After adding new actions, enforce rejection constraints again by adjusting costs upwards
    if rejected_ix.size > 0:
        reject_contracts = contracts[rejected_ix]
        p_w_rej = p_candidates @ reject_contracts.T
        for a in range(len(p_candidates)):
            max_rej_util = p_w_rej[a].max()
            if costs[a] < max_rej_util:
                costs[a] = max_rej_util + 1e-8  # small epsilon margin

    # Normalize p rows to sum to 1
    p_candidates = np.clip(p_candidates, 0, None)
    sums = p_candidates.sum(axis=1, keepdims=True)
    sums[sums < 1e-16] = 1.0
    p_candidates /= sums

    # Ensure costs non-negative
    costs = np.maximum(costs, 0)

    agent_setting = np.hstack([p_candidates, costs[:, None]])
    return agent_setting
```
