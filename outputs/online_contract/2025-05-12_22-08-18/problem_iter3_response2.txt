```python
import numpy as np
from sklearn.cluster import AgglomerativeClustering
from scipy.optimize import linprog

def agent_solver_v2(v: np.ndarray, content: list[dict]) -> np.ndarray:
    """
    Infer a valid agent setting (actions = distributions over outcomes + cost)
    consistent with historical contract logs.

    Params:
        v (np.ndarray): Principal's value vector (length 5)
        content (list[dict]): each dict has keys: 'Contract' (list of 5),
                              'Principal Utility' (float),
                              'Agent Action' (1 or -1)
    Returns:
        np.ndarray: n_actions x 6 (5 probabilities + 1 cost)
    """

    m_outcomes = v.size
    L = len(content)

    # Prepare arrays for easier manipulation
    contracts = np.array([log['Contract'] for log in content])  # shape (L,5)
    ag_actions = np.array([log['Agent Action'] for log in content])  # shape (L,)
    p_util = np.array([log['Principal Utility'] for log in content])  # shape (L,)

    accepted_ix = np.where(ag_actions == 1)[0]
    rejected_ix = np.where(ag_actions == -1)[0]

    # To explain data complexity, adaptively select number of actions up to max 10 or fewer if data small
    max_actions = min(10, max(1, len(accepted_ix)))

    # If no accepted contracts, cannot infer meaningful setting, return uniform prob and zero cost single action
    if len(accepted_ix) == 0:
        p = np.ones((1, m_outcomes)) / m_outcomes
        c = np.array([0.0])
        return np.hstack([p, c[:, None]])

    # Normalize contracts by outcome sum to compare shapes (avoid scale)
    norm_accepted_w = contracts[accepted_ix] / (contracts[accepted_ix].sum(axis=1, keepdims=True) + 1e-8)

    # Cluster accepted contracts by normalized shape to identify distinct agent actions
    clustering = AgglomerativeClustering(n_clusters=max_actions, linkage='average')
    labels = clustering.fit_predict(norm_accepted_w)

    # For each cluster, compute a prototype distribution p by constrained optimization:
    # Find p on simplex maximizing sum of acceptance margins (expected utility)
    # while ensuring p is a distribution and costs derived later are consistent

    p_candidates = []
    costs_lower_bound = []

    for c_idx in range(max_actions):
        cluster_inds = accepted_ix[labels == c_idx]
        if cluster_inds.size == 0:
            continue
        cluster_contracts = contracts[cluster_inds]  # contracts of cluster
        cluster_p_util = p_util[cluster_inds]

        # We want to find p solving:
        # maximize sum_i (p @ w_i - c) s.t p in simplex, c >=0 and p @ w_i - c >=0 for accepted contracts in cluster
        # Cost unknown but cost <= p @ w_i for all accepted i in cluster
        # We approximate p by maximizing average p @ w_i weighted by v to reflect principal preferences

        # Define LP:
        # Variables: p (length m_outcomes)
        # maximize p @ v
        # s.t p >=0, sum p =1
        # and p @ w_i >= 0 for all i in cluster (agent utility threshold 0 without cost)
        # But acceptance means p @ w_i - cost >= 0 => cost <= p @ w_i
        # Since cost unknown, we focus on p satisfying p @ w_i >= 0 (agent utility ignoring cost)
        # To be less restrictive we skip the constraints p @ w_i >=0 since w_i >= 0 and p>=0
        # Instead, we just find p maximizing p @ v to match principal's values for cluster contracts

        # Setup to maximize p @ v s.t p in simplex
        c_obj = -v  # minimize negative dot product to maximize dot product
        A_eq = np.ones((1, m_outcomes))
        b_eq = np.array([1])
        bounds = [(0, 1) for _ in range(m_outcomes)]

        res = linprog(c=c_obj, A_eq=A_eq, b_eq=b_eq, bounds=bounds, method='highs')

        if res.success:
            p = res.x
        else:
            # fallback: average normalized accepted contract in cluster, then normalize
            avg_w = cluster_contracts.mean(axis=0)
            p = np.maximum(avg_w, 0)
            if p.sum() == 0:
                p = np.ones(m_outcomes) / m_outcomes
            else:
                p = p / p.sum()

        p_candidates.append(p)

        # Estimate cost lower bound as minimal p @ w_i over cluster contracts (agent utility >=0 means cost <= p @ w_i)
        cluster_p_w = cluster_contracts @ p
        min_cost = np.min(cluster_p_w)
        if min_cost < 0:
            min_cost = 0  # costs non-negative
        costs_lower_bound.append(min_cost)

    p_candidates = np.array(p_candidates)
    costs_lower_bound = np.array(costs_lower_bound)

    # Now enforce rejection constraints:
    # For each rejected contract r and all actions a:
    # p_a @ w_r - cost_a < 0 => cost_a > p_a @ w_r
    # Thus cost_a must exceed max_r (p_a @ w_r)
    if rejected_ix.size > 0:
        reject_contracts = contracts[rejected_ix]
        # Compute all p_a @ w_r
        p_w_rej = p_candidates @ reject_contracts.T  # shape (n_actions, #rej)
        c_rej_min = p_w_rej.max(axis=1)
        c_rej_min = np.maximum(c_rej_min, 0)
    else:
        c_rej_min = np.zeros(len(p_candidates))

    # Final costs: max of acceptance lower bound and rejection constraints
    costs = np.maximum(costs_lower_bound, c_rej_min)

    # Ensure costs non-negative
    costs = np.maximum(costs, 0)

    # Validate all accepted contracts can be explained by some action (p, cost):
    # For any accepted contract not explained, add a new action to explain it exactly
    def action_explains_contract(p, c, w):
        return (p @ w - c) >= -1e-8

    def find_explaining_action(w):
        for idx, (p, cst) in enumerate(zip(p_candidates, costs)):
            if action_explains_contract(p, cst, w):
                return idx
        return None

    # Add new actions for accepted contracts if needed
    added = False
    for i in accepted_ix:
        w_i = contracts[i]
        if find_explaining_action(w_i) is None:
            # Create new action with p proportional to w_i (normalize) and cost equal to acceptance margin
            if w_i.sum() > 0:
                p_new = w_i / w_i.sum()
            else:
                p_new = np.ones(m_outcomes) / m_outcomes
            c_new = p_new @ w_i
            p_candidates = np.vstack([p_candidates, p_new])
            costs = np.append(costs, c_new)
            added = True

    # If new actions added, re-check rejection constraints and update costs accordingly
    if rejected_ix.size > 0 and added:
        reject_contracts = contracts[rejected_ix]
        p_w_rej = p_candidates @ reject_contracts.T
        for a in range(len(p_candidates)):
            max_rej = p_w_rej[a].max()
            if costs[a] < max_rej:
                costs[a] = max_rej + 1e-8  # small epsilon margin

    # Normalize p_candidates rows (probabilities) strictly to simplex,
    # correcting any small negative values due to numerical issues
    p_candidates = np.clip(p_candidates, 0, None)
    p_sums = p_candidates.sum(axis=1, keepdims=True)
    p_sums[p_sums == 0] = 1.0
    p_candidates /= p_sums

    # Assemble final agent setting matrix (n_actions x 6)
    agent_setting = np.hstack([p_candidates, costs[:, None]])

    return agent_setting
```
