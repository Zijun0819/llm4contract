```python
import numpy as np
from sklearn.cluster import KMeans
from scipy.optimize import linprog

def agent_solver_v2(v: np.ndarray, content: list[dict]) -> np.ndarray:
    """
    Infer a valid agent setting matrix given principal reward vector v and historical interaction logs content.
    The inference:
    - Find a minimal set of agent actions (distributions over outcomes + costs) that rationalize accept/reject logs.
    - Leverage clustering and constrained optimization for IR, IC, rejection constraints simultaneously.

    Parameters:
    - v: np.ndarray, shape (5,), principal reward vector per outcome.
    - content: list of dicts with keys 'Contract', 'Principal Utility', 'Agent Action'.

    Returns:
    - agent_setting: np.ndarray, shape (n_actions, 6), each row [p1, p2, p3, p4, p5, cost].
    """
    contracts = np.array([log['Contract'] for log in content])  # L x 5
    agent_actions = np.array([log['Agent Action'] for log in content])  # L,
    principal_utils = np.array([log['Principal Utility'] for log in content])  # L,

    L = len(content)
    m = v.size

    accepted_indices = np.where(agent_actions == 1)[0]
    rejected_indices = np.where(agent_actions == -1)[0]

    # If no accepted contracts, return trivial uniform distribution with zero cost
    if len(accepted_indices) == 0:
        uniform_p = np.ones(m) / m
        return np.hstack([uniform_p.reshape(1, -1), np.array([[0.0]])])

    accepted_contracts = contracts[accepted_indices]

    # Cap number of candidate agent actions (clusters)
    max_candidates = min(8, len(accepted_indices))

    # Cluster accepted contracts to group by similar accepted contract types
    kmeans = KMeans(n_clusters=max_candidates, random_state=42, n_init=15)
    assigns = kmeans.fit_predict(accepted_contracts)
    n = max_candidates

    # Index helper for variables vector x:
    # variables are arranged as [p_0_0,...p_0_m-1, p_1_0,...p_1_m-1, ..., p_n-1_m-1, c_0,...,c_n-1]
    def idx_p(a, o):
        return a * m + o
    def idx_c(a):
        return n * m + a

    # Collect inequality constraints A_ub x <= b_ub

    # Accepted contracts IR constraints:
    # For contract i assigned to action a:
    # p_a @ w_i - c_a >= 0   =>   -p_a @ w_i + c_a <= 0
    A_ub = []
    b_ub = []
    for idx_i, a in enumerate(assigns):
        i = accepted_indices[idx_i]
        w = contracts[i]
        row = np.zeros(n * m + n)
        for o in range(m):
            row[idx_p(a, o)] = -w[o]
        row[idx_c(a)] = 1.0
        A_ub.append(row)
        b_ub.append(0.0)

    # Rejected contracts constraints:
    # For each rejected contract j and each action a:
    # p_a @ w_j - c_a <= -epsilon  (agent utility < 0)
    epsilon = 1e-4
    for j in rejected_indices:
        w = contracts[j]
        for a in range(n):
            row = np.zeros(n * m + n)
            for o in range(m):
                row[idx_p(a, o)] = w[o]
            row[idx_c(a)] = -1.0
            A_ub.append(row)
            b_ub.append(-epsilon)

    A_ub = np.array(A_ub) if A_ub else np.zeros((0, n * m + n))
    b_ub = np.array(b_ub) if b_ub else np.array([])

    # Equality constraints A_eq x = b_eq:
    # For each action a: sum_o p_a[o] = 1 (probabilities sum to 1)
    A_eq = np.zeros((n, n * m + n))
    b_eq = np.ones(n)
    for a in range(n):
        for o in range(m):
            A_eq[a, idx_p(a, o)] = 1.0

    # Bounds:
    # p_a[o] in [0,1], c_a in [0, +inf)
    bounds = [(0, 1)] * (n * m) + [(0, None)] * n

    # Objective: minimize sum of costs (to find parsimonious costs)
    c_obj = np.zeros(n * m + n)
    c_obj[n * m:] = 1.0

    # Solve LP
    res = linprog(
        c=c_obj,
        A_ub=A_ub,
        b_ub=b_ub,
        A_eq=A_eq,
        b_eq=b_eq,
        bounds=bounds,
        method='highs',
    )

    if not res.success:
        # Fallback: uniform distributions and zero costs for a small number of actions
        uniform_p = np.ones(m) / m
        fallback_n = min(3, n)
        agent_setting = np.vstack([np.append(uniform_p, 0.0) for _ in range(fallback_n)])
        return agent_setting

    x = res.x
    p_mat = x[: n * m].reshape(n, m)
    c_vec = x[n * m: n * m + n]

    # Project p vectors to simplex to fix minor numerical issues
    def project_simplex(vec):
        # Implementation of the projection onto simplex (nonnegative, sum=1)
        z = np.sort(vec)[::-1]
        cumsum = np.cumsum(z)
        rho_candidates = z + (1.0 - cumsum) / (np.arange(len(vec)) + 1)
        rho = np.where(rho_candidates > 0)[0]
        if len(rho) == 0:
            return np.ones_like(vec) / len(vec)
        rho = rho[-1]
        theta = (cumsum[rho] - 1) / (rho + 1)
        return np.maximum(vec - theta, 0.0)

    for i in range(n):
        p_mat[i] = project_simplex(p_mat[i])
        if c_vec[i] < 0:
            c_vec[i] = 0.0

    # Enforce that costs are sufficiently large to guarantee rejection constraints strictly
    if len(rejected_indices) > 0:
        slack = 1e-4
        for a in range(n):
            max_rej_util = max((p_mat[a] @ contracts[j]) for j in rejected_indices)
            if c_vec[a] <= max_rej_util:
                c_vec[a] = max_rej_util + slack

    agent_setting = np.hstack([p_mat, c_vec.reshape(-1, 1)])
    return agent_setting
```
