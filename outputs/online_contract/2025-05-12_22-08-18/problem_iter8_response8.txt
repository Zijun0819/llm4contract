```python
import numpy as np
from sklearn.cluster import AgglomerativeClustering

def agent_solver_v2(v: np.ndarray, content: list[dict]) -> np.ndarray:
    """
    Infer a valid agent setting consistent with historical contract logs,
    emphasizing strict rejection margins, adaptive clustering,
    weighted centroids by principal utility, incremental action augmentation,
    and robust simplex normalization.

    Params:
        v (np.ndarray): Principal's value vector (length 5)
        content (list[dict]): each dict with keys: 'Contract' (list of 5),
                              'Principal Utility' (float),
                              'Agent Action' (1 or -1)
    Returns:
        np.ndarray: n_actions x 6 matrix (5 probabilities + 1 cost)
    """
    m_outcomes = v.size
    L = len(content)

    # Extract arrays from logs
    contracts = np.array([log['Contract'] for log in content], dtype=np.float64)  # (L,5)
    agent_actions = np.array([log['Agent Action'] for log in content], dtype=int) # (L,)
    p_util = np.array([log['Principal Utility'] for log in content], dtype=np.float64)  # (L,)

    accepted_ix = np.where(agent_actions == 1)[0]
    rejected_ix = np.where(agent_actions == -1)[0]

    # If no accepted contracts, return trivial uniform action with zero cost
    if accepted_ix.size == 0:
        uniform_p = np.ones(m_outcomes) / m_outcomes
        return np.hstack([uniform_p.reshape(1, -1), np.array([[0.0]])])

    accepted_w = contracts[accepted_ix]  # accepted contracts rewards

    # Normalize accepted contracts w for clustering (avoid magnitude bias)
    accepted_sum = accepted_w.sum(axis=1, keepdims=True)
    norm_w = accepted_w / (accepted_sum + 1e-14)

    # Adaptive cluster count: at least 1, at most 10, also cap by #accepted
    n_accepted = len(accepted_ix)
    n_candidates = max(1, min(10, int(np.ceil(np.sqrt(n_accepted))), n_accepted))

    clustering = AgglomerativeClustering(n_clusters=n_candidates, linkage='average')
    labels = clustering.fit_predict(norm_w)

    p_candidates = []
    costs_lb = []

    # Compute weighted centroids and robust cost lower bounds per cluster
    for c in range(n_candidates):
        cluster_idx = accepted_ix[labels == c]
        if cluster_idx.size == 0:
            continue
        cluster_w = contracts[cluster_idx]
        cluster_util = p_util[cluster_idx]

        # Weights emphasizing principal utility within cluster (shifted +1)
        weights = cluster_util - cluster_util.min()
        weights += 1.0

        avg_w = np.average(cluster_w, axis=0, weights=weights)
        # Project avg_w to nonnegative and normalize to simplex
        p = np.clip(avg_w, 0.0, None)
        s = p.sum()
        if s < 1e-14:
            p = np.ones(m_outcomes) / m_outcomes
        else:
            p /= s

        p_candidates.append(p)

        # Cost lower bound: min over cluster accepted contracts of p @ w_i (agent utility â‰¥ 0)
        costs_cluster = np.array([p @ contracts[i] for i in cluster_idx])
        costs_lb.append(costs_cluster.min())

    p_candidates = np.array(p_candidates)  # shape (n_candidates, m_outcomes)
    costs_lb = np.array(costs_lb)          # shape (n_candidates,)

    # Handle rejected contracts: agent utility < 0 for all actions inferred
    if rejected_ix.size > 0:
        reject_w = contracts[rejected_ix]  # (#rej,5)
        p_w_rej = p_candidates @ reject_w.T  # shape (n_candidates, #rej)
        # Each cost must be strictly > max p @ w_r for all rejected contracts (strict IR)
        costs_rej_min = p_w_rej.max(axis=1) + 1e-7
    else:
        costs_rej_min = np.zeros(len(p_candidates))

    # Initial costs must satisfy both acceptance (lower bounds) and rejection (strictly above)
    costs = np.maximum(costs_lb, costs_rej_min)
    costs = np.maximum(costs, 0.0)

    # Function to check if an accepted contract can be rationalized by current actions
    def valid_action_for_contract(w_i):
        # utility = p_a @ w_i - cost_a
        utils = p_candidates @ w_i - costs
        # Accept if any utility >= -1e-10 (numerical tolerance)
        feasible = np.where(utils >= -1e-10)[0]
        return feasible[0] if feasible.size > 0 else None

    # Add incremental actions for accepted contracts not explained by current actions
    added = False
    for i in accepted_ix:
        w_i = contracts[i]
        if valid_action_for_contract(w_i) is None:
            p_new = w_i.copy()
            s = p_new.sum()
            if s < 1e-14:
                p_new = np.ones(m_outcomes) / m_outcomes
            else:
                p_new /= s
            c_new = p_new @ w_i
            p_candidates = np.vstack([p_candidates, p_new])
            costs = np.append(costs, c_new)
            added = True

    # If added actions, re-check rejection constraints and fix costs if necessary
    if added and rejected_ix.size > 0:
        reject_w = contracts[rejected_ix]
        p_w_rej = p_candidates @ reject_w.T
        margin = 1e-6
        for a in range(len(p_candidates)):
            max_rej_util = p_w_rej[a].max()
            if costs[a] < max_rej_util + margin:
                costs[a] = max_rej_util + margin

    # Final refinement: enforce strict rejection margins on all actions
    if rejected_ix.size > 0:
        reject_w = contracts[rejected_ix]
        p_w_rej = p_candidates @ reject_w.T
        margin = 1e-6
        for _ in range(3):  # small fixed iterations for stability
            updated = False
            for a in range(len(p_candidates)):
                max_rej_util = p_w_rej[a].max()
                if costs[a] < max_rej_util + margin:
                    costs[a] = max_rej_util + margin
                    updated = True
            if not updated:
                break

    # Ensure probabilities are strictly on simplex after all operations
    p_candidates = np.clip(p_candidates, 0.0, None)
    sums = p_candidates.sum(axis=1, keepdims=True)
    zero_mask = sums < 1e-14
    p_candidates[zero_mask[:, 0], :] = 1.0 / m_outcomes
    sums[zero_mask] = 1.0
    p_candidates /= sums

    # Assemble final matrix: (n_actions, 6) = 5 probabilities + 1 cost column
    agent_setting = np.hstack([p_candidates, costs[:, None]])

    return agent_setting
```
