```python
import numpy as np
from sklearn.cluster import AgglomerativeClustering

def agent_solver_v2(v: np.ndarray, content: list[dict]) -> np.ndarray:
    """
    Infer a valid agent setting (actions = outcome distributions + cost)
    consistent with historical contract logs, enforcing strict global IR/IC constraints.

    Params:
        v (np.ndarray): Principal's value vector (length 5)
        content (list[dict]): each dict has keys: 'Contract' (list of 5),
                              'Principal Utility' (float),
                              'Agent Action' (1 or -1)
    Returns:
        np.ndarray: n_actions x 6 (5 probabilities + 1 cost)
    """

    m_outcomes = v.size
    L = len(content)

    # Prepare arrays
    contracts = np.array([log['Contract'] for log in content])  # (L,5)
    ag_actions = np.array([log['Agent Action'] for log in content])  # (L,)
    p_util = np.array([log['Principal Utility'] for log in content])  # (L,)

    accepted_ix = np.where(ag_actions == 1)[0]
    rejected_ix = np.where(ag_actions == -1)[0]

    # If no accepted contracts, fallback to uniform distribution with zero cost
    if accepted_ix.size == 0:
        return np.hstack([np.ones((1, m_outcomes)) / m_outcomes, np.array([[0.]])])

    accepted_w = contracts[accepted_ix]

    # Normalize accepted contracts for clustering (sum to 1)
    norm_w = accepted_w / (accepted_w.sum(axis=1, keepdims=True) + 1e-12)

    # Adaptive number of clusters: min(10, #accepted, sqrt(#accepted))
    n_max_actions = max(1, min(10, int(np.sqrt(len(accepted_ix))), len(accepted_ix)))

    # Cluster accepted contracts by shape (prob distribution)
    clustering = AgglomerativeClustering(n_clusters=n_max_actions, linkage='average')
    labels = clustering.fit_predict(norm_w)

    p_candidates = []
    costs_lower_bound = []

    # For each cluster, compute weighted centroid emphasizing principal utility
    for c in range(n_max_actions):
        cluster_idx = accepted_ix[labels == c]
        if cluster_idx.size == 0:
            continue
        cluster_w = contracts[cluster_idx]

        # Weights: principal utility shifted by min + 1 (positive)
        weights = p_util[cluster_idx] - p_util[cluster_idx].min() + 1
        avg_w = np.average(cluster_w, axis=0, weights=weights)

        # Project avg_w to simplex (clip negatives, normalize)
        p = np.clip(avg_w, 0, None)
        if p.sum() < 1e-12:
            p = np.ones(m_outcomes) / m_outcomes
        else:
            p = p / p.sum()

        p_candidates.append(p)

        # Cost lower bound: minimal p@w_i over cluster accepted contracts
        p_dot_w = np.array([p @ contracts[i] for i in cluster_idx])
        min_cost = p_dot_w.min()
        costs_lower_bound.append(min_cost)

    p_candidates = np.array(p_candidates)
    costs_lower_bound = np.array(costs_lower_bound)

    # Handle rejected contracts: agent utility < 0 for all inferred actions
    if rejected_ix.size > 0:
        reject_contracts = contracts[rejected_ix]  # (#rej,5)
        # Shape (n_actions, #rej)
        p_w_rej = p_candidates @ reject_contracts.T
        # For each action a, cost_a must be strictly > max_r p_a @ w_r to reject all
        c_rej_min = p_w_rej.max(axis=1) + 1e-6
    else:
        c_rej_min = np.zeros(len(p_candidates))

    # Final costs: ensure cost >= max(accepted lower bound, rejection lower bound), nonnegative
    costs = np.maximum(costs_lower_bound, c_rej_min)
    costs = np.maximum(costs, 0)

    # Validate accepted contracts: each must be rationalized by some action
    def valid_action_for_contract(w_i):
        for a, (p, c) in enumerate(zip(p_candidates, costs)):
            util = p @ w_i - c
            if util >= -1e-8:
                return a
        return None

    # Add minimal dummy actions for accepted contracts not explained
    unexplained = []
    for i in accepted_ix:
        w_i = contracts[i]
        if valid_action_for_contract(w_i) is None:
            unexplained.append(i)

    for i in unexplained:
        w_i = contracts[i]
        # Normalize to valid probability distribution
        p_new = np.clip(w_i, 0, None)
        if p_new.sum() < 1e-12:
            p_new = np.ones(m_outcomes) / m_outcomes
        else:
            p_new = p_new / p_new.sum()
        c_new = p_new @ w_i
        p_candidates = np.vstack([p_candidates, p_new])
        costs = np.append(costs, c_new)

    # After adding dummy actions, re-check rejection constraints and adjust costs iteratively
    if rejected_ix.size > 0:
        reject_contracts = contracts[rejected_ix]
        p_w_rej = p_candidates @ reject_contracts.T
        # Enforce cost > max rejection util with margin
        for a in range(len(p_candidates)):
            max_rej_util = p_w_rej[a].max()
            if costs[a] < max_rej_util + 1e-8:
                costs[a] = max_rej_util + 1e-4

    # Global IR constraint: agent utility ≥ 0 for accepted contracts guaranteed by construction

    # Global IC constraints: For all pairs of inferred actions (a,a'),
    # ensure agent prefers own action (p_a,c_a) over others (p_a',c_a')
    # This requires for each accepted contract i explained by action a_i:
    # p_a_i @ w_i - c_a_i ≥ p_a' @ w_i - c_a' for all a'
    # We'll tighten costs if violated (slack adjustment)

    # Assign each accepted contract to the explaining action
    explained_by = np.full(L, -1, dtype=int)
    for i in accepted_ix:
        w_i = contracts[i]
        for a, (p, c) in enumerate(zip(p_candidates, costs)):
            util = p @ w_i - c
            if util >= -1e-8:
                explained_by[i] = a
                break

    # Iterate a few times to fix IC violations
    for _ in range(3):
        updated = False
        for i in accepted_ix:
            a_i = explained_by[i]
            if a_i == -1:
                continue
            w_i = contracts[i]
            u_i = p_candidates[a_i] @ w_i - costs[a_i]
            for a_prime in range(len(p_candidates)):
                if a_prime == a_i:
                    continue
                u_prime = p_candidates[a_prime] @ w_i - costs[a_prime]
                # If IC violated: u_prime > u_i, increase cost[a_prime]
                if u_prime > u_i + 1e-8:
                    # Increase cost[a_prime] to reduce incentive deviation
                    costs[a_prime] += u_prime - u_i + 1e-4
                    updated = True
                    # Recompute u_prime after update to avoid over-updating
                    u_prime = p_candidates[a_prime] @ w_i - costs[a_prime]
                    if u_prime <= u_i + 1e-8:
                        continue
        if not updated:
            break

    # Final normalization of p_candidates to ensure valid distributions
    p_candidates = np.clip(p_candidates, 0, None)
    p_sums = p_candidates.sum(axis=1, keepdims=True)
    p_sums[p_sums < 1e-12] = 1.0  # avoid division by zero
    p_candidates /= p_sums

    # Assemble final agent setting matrix (n_actions x 6)
    agent_setting = np.hstack([p_candidates, costs[:, None]])

    return agent_setting
```
