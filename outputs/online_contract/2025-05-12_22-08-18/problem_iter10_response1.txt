```python
import numpy as np
from scipy.optimize import linprog
from sklearn.cluster import AgglomerativeClustering

def agent_solver(v: np.ndarray, content: list[dict]) -> np.ndarray:
    """
    Improved agent setting inference consistent with historical logs,
    enforcing global IR/IC constraints via LP, adaptive clustering with weighted centroids,
    per-contract dummy actions for unexplained accepted contracts,
    tighter rejection margin, LP refinement on rejection constraints only,
    and precise normalization of probabilities.

    Params:
        v (np.ndarray): Principal's value vector (length 5)
        content (list[dict]): each dict has keys: 'Contract' (list of 5),
                              'Principal Utility' (float),
                              'Agent Action' (1 or -1)

    Returns:
        np.ndarray: n_actions x 6 (5 probabilities + 1 cost)
    """
    m_outcomes = v.size
    L = len(content)

    # Extract arrays for convenience
    contracts = np.array([log['Contract'] for log in content])  # shape (L,5)
    ag_actions = np.array([log['Agent Action'] for log in content])  # shape (L,)
    p_util = np.array([log['Principal Utility'] for log in content])  # shape (L,)

    accepted_ix = np.where(ag_actions == 1)[0]
    rejected_ix = np.where(ag_actions == -1)[0]

    # If no accepted contracts, return trivial uniform action with zero cost
    if accepted_ix.size == 0:
        uniform_p = np.ones(m_outcomes) / m_outcomes
        return np.hstack([uniform_p.reshape(1, -1), np.array([[0.]])])

    accepted_w = contracts[accepted_ix]

    # Normalize contracts for clustering (avoid zero division)
    norm_w = accepted_w / (accepted_w.sum(axis=1, keepdims=True) + 1e-12)

    # Adaptive number of clusters: min(10, #accepted, int(sqrt(#accepted)))
    n_clusters = max(1, min(10, int(np.sqrt(len(accepted_ix))), len(accepted_ix)))

    clustering = AgglomerativeClustering(n_clusters=n_clusters, linkage='average')
    labels = clustering.fit_predict(norm_w)

    p_candidates = []
    costs_lb = []

    # Compute weighted cluster centroids (weights from principal utilities shifted to positive)
    for c in range(n_clusters):
        cluster_idx = accepted_ix[labels == c]
        if cluster_idx.size == 0:
            continue
        cluster_w = contracts[cluster_idx]
        cluster_p_util = p_util[cluster_idx]

        # Weights for averaging: principal utility shifted to > 0
        weights = cluster_p_util - cluster_p_util.min() + 1.0
        avg_w = np.average(cluster_w, axis=0, weights=weights)

        # Project avg_w to simplex (clip negatives and renormalize)
        p = np.clip(avg_w, 0, None)
        if p.sum() < 1e-12:
            p = np.ones(m_outcomes) / m_outcomes
        else:
            p = p / p.sum()

        p_candidates.append(p)

        # Cost lower bound from accepted contracts in cluster (utility >= 0 => cost <= p @ w_i)
        costs_cluster = np.array([p @ contracts[i] for i in cluster_idx])
        costs_lb.append(costs_cluster.min())

    p_candidates = np.array(p_candidates)  # shape (n_actions, m_outcomes)
    costs_lb = np.array(costs_lb)  # shape (n_actions,)

    # Rejection constraints: cost > max_r p@w_r for all actions
    if rejected_ix.size > 0:
        reject_contracts = contracts[rejected_ix]
        p_w_rej = p_candidates @ reject_contracts.T  # shape (n_actions, n_rejected)
        c_rej_min = p_w_rej.max(axis=1) + 1e-6  # strictly greater margin
    else:
        c_rej_min = np.zeros(len(p_candidates))

    # Initial costs: max of accepted lower bound and rejected lower bound, clipped >=0
    costs = np.maximum(costs_lb, c_rej_min)
    costs = np.maximum(costs, 0.0)

    # Helper: check if an action explains accepted contract (utility >= -1e-8)
    def explains(w_i):
        for p, c in zip(p_candidates, costs):
            if (p @ w_i - c) >= -1e-8:
                return True
        return False

    # Add per-contract dummy actions for any accepted contract unexplained by current actions
    for i in accepted_ix:
        w_i = contracts[i]
        if not explains(w_i):
            # Use normalized w_i as p_new (projected to simplex)
            p_new = np.clip(w_i, 0, None)
            if p_new.sum() < 1e-12:
                p_new = np.ones(m_outcomes) / m_outcomes
            else:
                p_new = p_new / p_new.sum()
            c_new = p_new @ w_i  # cost equals expected payment to get utility=0 exactly
            p_candidates = np.vstack([p_candidates, p_new])
            costs = np.append(costs, c_new)

    n_actions = len(p_candidates)

    # After adding dummy actions, re-check rejection constraints and tighten costs if needed
    if rejected_ix.size > 0:
        reject_contracts = contracts[rejected_ix]
        p_w_rej = p_candidates @ reject_contracts.T  # shape (n_actions, n_rejected)
        margin = 1e-4
        for a in range(n_actions):
            max_rej_util = p_w_rej[a].max()
            if costs[a] < max_rej_util + margin:
                costs[a] = max_rej_util + margin

    # LP formulation: minimize sum(costs) s.t. cost_a >= p_a @ w_r + epsilon for all rejected contracts r
    # Accepted constraints (existence) handled by dummy actions, so only enforce rejection constraints here
    c_obj = np.zeros(n_actions)  # zero objective to just find feasible costs
    epsilon = 1e-8

    A_ub = []
    b_ub = []

    if rejected_ix.size > 0:
        for a in range(n_actions):
            p_a = p_candidates[a]
            for r in rejected_ix:
                val = p_a @ contracts[r] + epsilon
                row = np.zeros(n_actions)
                row[a] = -1  # -c_a <= -val
                A_ub.append(row)
                b_ub.append(-val)

        A_ub = np.array(A_ub)
        b_ub = np.array(b_ub)
    else:
        A_ub = None
        b_ub = None

    bounds = [(0, None) for _ in range(n_actions)]

    # Solve LP to refine costs
    if A_ub is not None:
        res = linprog(c_obj, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')
        if res.success:
            # Use LP solution only if it does not violate accepted constraints (should be true)
            costs = np.maximum(costs, res.x)

    # Final normalization of p_candidates (clip negatives and renormalize)
    p_candidates = np.clip(p_candidates, 0, None)
    p_sums = p_candidates.sum(axis=1, keepdims=True)
    p_sums[p_sums < 1e-12] = 1.0
    p_candidates /= p_sums

    # Compose final agent setting matrix: n_actions x (5 + 1)
    agent_setting = np.hstack([p_candidates, costs[:, None]])

    return agent_setting
```
