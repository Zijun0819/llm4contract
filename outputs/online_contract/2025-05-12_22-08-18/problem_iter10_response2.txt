```python
import numpy as np
from sklearn.cluster import AgglomerativeClustering
from scipy.optimize import linprog

def agent_solver_v2(v: np.ndarray, content: list[dict]) -> np.ndarray:
    """
    Infer a valid agent setting consistent with historical logs:
    - Adaptive clustering on normalized accepted contracts with weighted centroids by principal utility.
    - Add minimal dummy actions exactly matching unexplained accepted contracts.
    - Enforce global IR/IC constraints via LP to refine action costs.
    - Strictly separate accepted and rejected contracts (agent utilities ≥0 vs <0).
    - Normalize output probabilities strictly to simplex.

    Args:
        v (np.ndarray): Principal's reward vector over 5 outcomes, shape (5,)
        content (list[dict]): Each dict has keys:
            'Contract' (list/array length 5),
            'Principal Utility' (float),
            'Agent Action' (1 or -1)

    Returns:
        np.ndarray: agent setting matrix n_actions x 6,
                    each row: [p_1,...,p_5, cost],
                    p_i ≥0, sum p_i=1, cost ≥0
    """
    m = v.size
    L = len(content)

    # Defensive return for no data
    if L == 0:
        return np.hstack([np.ones((1, m)) / m, np.array([[0.0]])])

    contracts = np.array([log['Contract'] for log in content], dtype=np.float64)  # (L, m)
    agent_actions = np.array([log['Agent Action'] for log in content], dtype=int)  # (L,)
    principal_utils = np.array([log['Principal Utility'] for log in content], dtype=np.float64)  # (L,)

    accepted_ix = np.where(agent_actions == 1)[0]
    rejected_ix = np.where(agent_actions == -1)[0]

    # If no accepted contracts, return trivial uniform action zero cost
    if accepted_ix.size == 0:
        return np.hstack([np.ones((1, m)) / m, np.array([[0.0]])])

    accepted_contracts = contracts[accepted_ix]  # (n_acc, m)
    accepted_pu = principal_utils[accepted_ix]

    # Normalize accepted contracts for clustering (avoid zero sums)
    norm_accepted = accepted_contracts / (accepted_contracts.sum(axis=1, keepdims=True) + 1e-12)

    n_accepted = accepted_ix.size
    n_clusters = max(1, min(10, int(np.sqrt(n_accepted)), n_accepted))

    # Cluster accepted contracts by normalized probabilities, average linkage
    clustering = AgglomerativeClustering(n_clusters=n_clusters, linkage='average')
    labels = clustering.fit_predict(norm_accepted)

    p_actions = []
    costs_lb = []

    # Weighted centroids of clusters with principal utility shifted to positive weights
    pu_shift = accepted_pu.min()
    weights = accepted_pu - pu_shift + 1.0  # all weights ≥1

    for c in range(n_clusters):
        mask = (labels == c)
        if not np.any(mask):
            continue
        idxs = accepted_ix[mask]
        cluster_contracts = contracts[idxs]
        cluster_weights = weights[mask]

        # Weighted average contract vector in original rewards space
        centroid = np.average(cluster_contracts, axis=0, weights=cluster_weights)

        # Project to simplex: clip negatives and normalize
        p = np.clip(centroid, 0, None)
        s = p.sum()
        if s < 1e-12:
            p = np.ones(m) / m
        else:
            p /= s
        p_actions.append(p)

        # Cost lower bound from accepted contracts in cluster: cost ≤ p @ w_i for utility≥0
        costs_cluster = np.array([p @ contracts[i] for i in idxs])
        costs_lb.append(costs_cluster.min())

    if len(p_actions) == 0:
        # Defensive fallback: uniform distribution zero cost
        return np.hstack([np.ones((1, m)) / m, np.array([[0.0]])])

    p_actions = np.array(p_actions)  # (n_actions, m)
    costs_lb = np.array(costs_lb)   # (n_actions,)

    # For rejected contracts, costs must be strictly greater than p_action @ w_r + epsilon
    epsilon = 1e-6
    if rejected_ix.size > 0:
        reject_contracts = contracts[rejected_ix]  # (n_rejected, m)
        pwr = p_actions @ reject_contracts.T       # (n_actions, n_rejected)
        costs_rej_min = pwr.max(axis=1) + epsilon
    else:
        costs_rej_min = np.zeros(len(p_actions))

    # Initial costs satisfy both accepted and rejected constraints
    costs = np.maximum(costs_lb, costs_rej_min)
    costs = np.maximum(costs, 0.0)

    def action_explains_contract(w_i):
        # Return True if some action a satisfies p_a @ w_i - cost_a ≥ -tol
        tol = 1e-9
        for p, c in zip(p_actions, costs):
            if (p @ w_i - c) >= -tol:
                return True
        return False

    # Add minimal dummy actions for unexplained accepted contracts
    unexplained_ix = [i for i in accepted_ix if not action_explains_contract(contracts[i])]
    for i in unexplained_ix:
        w_i = contracts[i]
        p_new = np.clip(w_i, 0, None)
        s = p_new.sum()
        if s < 1e-12:
            p_new = np.ones(m) / m
        else:
            p_new /= s
        c_new = p_new @ w_i
        p_actions = np.vstack([p_actions, p_new])
        costs = np.append(costs, c_new)

    n_actions = len(costs)

    # Re-check rejection constraints after dummy addition, enforce strict separation
    if rejected_ix.size > 0:
        reject_contracts = contracts[rejected_ix]
        pwr_full = p_actions @ reject_contracts.T  # (n_actions, n_rejected)
        for a in range(n_actions):
            max_rej_util = pwr_full[a].max()
            if costs[a] <= max_rej_util + 1e-10:
                costs[a] = max_rej_util + 1e-4  # margin

    # Setup LP to refine costs ensuring strict IR/IC:
    # Variables: costs vector (length n_actions)
    # Constraints:
    #  - For each rejected contract r and action a:
    #       cost_a ≥ p_a @ w_r + epsilon  =>  -cost_a ≤ - (p_a @ w_r + epsilon)
    #  - costs ≥ 0
    # 
    # We do NOT enforce accepted contracts directly since dummy actions cover them.
    # Objective: minimize sum costs to keep parsimonious.

    c_obj = np.ones(n_actions)
    A_ub = []
    b_ub = []

    for a in range(n_actions):
        for r in rejected_ix:
            val = p_actions[a] @ contracts[r] + epsilon
            row = np.zeros(n_actions)
            row[a] = -1
            A_ub.append(row)
            b_ub.append(-val)

    if len(A_ub) > 0:
        A_ub = np.vstack(A_ub)
        b_ub = np.array(b_ub)
    else:
        A_ub = None
        b_ub = None

    bounds = [(0, None)] * n_actions

    res = linprog(c=c_obj, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')
    if res.success and res.x is not None and np.all(np.isfinite(res.x)):
        refined_costs = np.maximum(res.x, 0.0)

        # Double-check all accepted contracts explained by refined costs
        def contract_explained(w_i):
            return any((p_actions[a] @ w_i - refined_costs[a]) >= -1e-9 for a in range(n_actions))

        if all(contract_explained(contracts[i]) for i in accepted_ix):
            costs = refined_costs

    # Final normalization of p_actions to simplex strictly
    p_actions = np.clip(p_actions, 0, None)
    sums = p_actions.sum(axis=1, keepdims=True)
    sums[sums < 1e-12] = 1.0
    p_actions /= sums

    agent_setting = np.hstack([p_actions, costs.reshape(-1, 1)])

    return agent_setting
```
