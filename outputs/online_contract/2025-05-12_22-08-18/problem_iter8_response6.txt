```python
import numpy as np
from sklearn.cluster import AgglomerativeClustering
from scipy.optimize import linprog

def agent_solver(v: np.ndarray, content: list[dict]) -> np.ndarray:
    """
    Infer a valid agent setting matrix from historical contract interactions,
    enforcing IR, IC, and rejection constraints via adaptive clustering and LP.

    Parameters:
    - v: Principal reward vector of shape (5,)
    - content: List of dicts, each with keys 'Contract' (list of 5 floats),
               'Principal Utility' (float), 'Agent Action' (1 or -1)

    Returns:
    - agent_setting: n x 6 numpy array where each row represents an action:
        first 5 elements are outcome probabilities (sum to 1),
        last element is agent's cost (>=0) for performing the action.
    """
    m_outcomes = v.size
    L = len(content)
    if L == 0:
        # No data: trivial uniform action with zero cost
        p_uniform = np.ones(m_outcomes) / m_outcomes
        return np.hstack([p_uniform, [0.0]]).reshape(1, -1)

    contracts = np.array([log['Contract'] for log in content], dtype=np.float64)  # (L,5)
    ag_actions = np.array([log['Agent Action'] for log in content], dtype=int)    # (L,)
    p_util = np.array([log['Principal Utility'] for log in content], dtype=np.float64)  # (L,)

    accepted_ix = np.where(ag_actions == 1)[0]
    rejected_ix = np.where(ag_actions == -1)[0]

    # If no accepted contracts, return trivial uniform action with zero cost
    if accepted_ix.size == 0:
        p_uniform = np.ones(m_outcomes) / m_outcomes
        return np.hstack([p_uniform, [0.0]]).reshape(1, -1)

    accepted_w = contracts[accepted_ix]  # (num_accept, 5)
    accepted_pu = p_util[accepted_ix]

    # Normalize accepted contracts to avoid zero-sum issues for clustering
    norm_w = accepted_w / (accepted_w.sum(axis=1, keepdims=True) + 1e-12)

    # Adaptive number of clusters to avoid overfitting
    n_max_actions = max(1, min(10, int(np.sqrt(len(accepted_ix))), len(accepted_ix)))

    clustering = AgglomerativeClustering(n_clusters=n_max_actions, linkage='average')
    labels = clustering.fit_predict(norm_w)

    p_candidates = []
    costs_lower_bound = []

    # Compute weighted centroids and cost lower bounds per cluster
    for c in range(n_max_actions):
        cluster_idx = accepted_ix[labels == c]
        if cluster_idx.size == 0:
            continue
        cluster_w = contracts[cluster_idx]
        cluster_pu = accepted_pu[labels == c]

        # Weights: principal utility shifted to positive
        weights = cluster_pu - cluster_pu.min() + 1
        avg_w = np.average(cluster_w, axis=0, weights=weights)

        # Project avg_w to probability simplex (clip negatives, normalize)
        p = np.clip(avg_w, 0, None)
        s = p.sum()
        if s < 1e-12:
            p = np.ones(m_outcomes) / m_outcomes
        else:
            p /= s
        p_candidates.append(p)

        # Cost lower bound from accepted contracts in cluster:
        # agent utility >=0 => cost <= p @ w_i for all accepted i in cluster
        costs_cluster = np.array([p @ contracts[i] for i in cluster_idx])
        min_cost = costs_cluster.min()
        costs_lower_bound.append(min_cost)

    p_candidates = np.array(p_candidates)
    costs_lower_bound = np.array(costs_lower_bound)

    # Handle rejected contracts: cost must be strictly > max p @ w over rejected contracts
    if rejected_ix.size > 0:
        rejected_w = contracts[rejected_ix]
        p_w_rej = p_candidates @ rejected_w.T  # (n_actions, #rej)
        c_rej_min = p_w_rej.max(axis=1) + 1e-6
    else:
        c_rej_min = np.zeros(len(p_candidates), dtype=np.float64)

    # Initialize costs satisfying lower bounds and rejection margins, non-negative
    costs = np.maximum(costs_lower_bound, c_rej_min)
    costs = np.maximum(costs, 0.0)

    # Validate accepted contracts rationalized by some action
    def valid_action_for_contract(w_i):
        for a, (p, c) in enumerate(zip(p_candidates, costs)):
            util = p @ w_i - c
            if util >= -1e-8:
                return a
        return None

    # Add dummy actions for unexplained accepted contracts
    for i in accepted_ix:
        w_i = contracts[i]
        if valid_action_for_contract(w_i) is None:
            p_new = np.clip(w_i, 0, None)
            s = p_new.sum()
            if s < 1e-12:
                p_new = np.ones(m_outcomes) / m_outcomes
            else:
                p_new /= s
            c_new = p_new @ w_i
            p_candidates = np.vstack([p_candidates, p_new])
            costs = np.append(costs, c_new)

    # After adding new actions, ensure rejection constraints strictly hold
    if rejected_ix.size > 0:
        rejected_w = contracts[rejected_ix]
        p_w_rej = p_candidates @ rejected_w.T
        for a in range(len(costs)):
            max_rej_util = p_w_rej[a].max()
            if costs[a] < max_rej_util + 1e-8:
                costs[a] = max_rej_util + 1e-4

    # Enforce global IR & IC constraints via LP

    n_actions = len(p_candidates)
    n_contracts = L

    # Objective: minimize sum costs
    c_obj = np.ones(n_actions)

    A_ub = []
    b_ub = []

    # IR constraints (accepted contracts):
    # For each accepted contract i and action a: c_a <= p_a @ w_i
    # => c_a - (p_a @ w_i) <= 0
    for i in accepted_ix:
        w_i = contracts[i]
        for a in range(n_actions):
            row = np.zeros(n_actions)
            row[a] = 1
            ub = p_candidates[a] @ w_i
            A_ub.append(row)
            b_ub.append(ub)

    # Rejection constraints (rejected contracts):
    # For each rejected contract j and action a: c_a > p_a @ w_j
    # => -c_a + (p_a @ w_j) <= -epsilon
    epsilon = 1e-6
    for i in rejected_ix:
        w_i = contracts[i]
        for a in range(n_actions):
            row = np.zeros(n_actions)
            row[a] = -1
            ub = - (p_candidates[a] @ w_i) - epsilon
            A_ub.append(row)
            b_ub.append(ub)

    # IC constraints:
    # For all triples (i in accepted contracts, a,b in actions):
    # (c_b - c_a) >= (p_b - p_a) @ w_i
    # => -(c_b - c_a) <= -((p_b - p_a) @ w_i)
    for i in accepted_ix:
        w_i = contracts[i]
        for a in range(n_actions):
            for b in range(n_actions):
                row = np.zeros(n_actions)
                row[a] = 1
                row[b] = -1
                rhs = - ((p_candidates[b] - p_candidates[a]) @ w_i)
                A_ub.append(row)
                b_ub.append(rhs)

    A_ub = np.array(A_ub, dtype=np.float64)
    b_ub = np.array(b_ub, dtype=np.float64)

    bounds = [(0, None) for _ in range(n_actions)]

    # Solve LP
    res = linprog(c=c_obj, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs', options={'presolve': True, 'disp': False})

    if res.success:
        costs_lp = res.x
        # Trust LP solution if it improves costs lower bound
        costs = np.maximum(costs, costs_lp)
    # else: fallback to previous costs

    # Final normalization of probability vectors
    p_candidates = np.clip(p_candidates, 0, None)
    p_sums = p_candidates.sum(axis=1, keepdims=True)
    p_sums[p_sums < 1e-12] = 1.0
    p_candidates /= p_sums
    costs = np.clip(costs, 0, None)

    agent_setting = np.hstack([p_candidates, costs[:, None]])
    return agent_setting
```
