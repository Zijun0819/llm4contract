```python
import numpy as np
from sklearn.cluster import AgglomerativeClustering
from scipy.optimize import linprog

def agent_solver_v2(v: np.ndarray, content: list[dict]) -> np.ndarray:
    """
    Infer a valid agent setting matrix (actions = outcome distributions + costs)
    that rationalizes all historical contract-agent interaction logs under IC and IR,
    using weighted clustering on accepted contracts emphasizing high-utility contracts,
    dynamically adding actions for unexplained accepted contracts, and strictly enforcing
    rejection margin on costs via LP refinement for robust feasibility.

    Parameters:
    - v (np.ndarray): Principal's value vector of length 5
    - content (list[dict]): each dict has keys:
        'Contract' (list of 5 floats),
        'Principal Utility' (float),
        'Agent Action' (1 or -1)

    Returns:
    - agent_setting (np.ndarray): n_actions x 6 matrix; each row:
        first 5 elements: outcome probabilities summing to 1,
        last element: nonnegative agent cost
    """
    m = v.shape[0]
    L = len(content)

    # Extract arrays from logs
    contracts = np.array([log['Contract'] for log in content], dtype=np.float64)  # (L,5)
    agent_actions = np.array([log['Agent Action'] for log in content], dtype=int)  # (L,)
    principal_utils = np.array([log['Principal Utility'] for log in content], dtype=np.float64)  # (L,)

    accepted_idx = np.where(agent_actions == 1)[0]
    rejected_idx = np.where(agent_actions == -1)[0]

    # Case: no accepted contracts, trivial uniform action with zero cost
    if accepted_idx.size == 0:
        uniform_p = np.ones(m) / m
        return np.hstack([uniform_p.reshape(1, -1), np.array([[0.0]])])

    accepted_contracts = contracts[accepted_idx]
    accepted_utils = principal_utils[accepted_idx]

    # Normalize accepted contracts for clustering: avoid zero sums
    sums = accepted_contracts.sum(axis=1, keepdims=True)
    sums[sums < 1e-12] = 1.0
    normalized_accepted = accepted_contracts / sums

    # Determine cluster count adaptively: min(10, accepted size, floor(sqrt(accepted size)))
    n_clusters = max(1, min(10, accepted_idx.size, int(np.sqrt(accepted_idx.size))))

    if n_clusters > 1:
        clustering = AgglomerativeClustering(n_clusters=n_clusters, linkage='average')
        cluster_labels = clustering.fit_predict(normalized_accepted)
    else:
        cluster_labels = np.zeros(accepted_idx.size, dtype=int)

    p_candidates = []
    cost_lb_candidates = []

    # Form candidate actions by weighted averaging within clusters
    for cid in range(n_clusters):
        cluster_mask = (cluster_labels == cid)
        cluster_ids = accepted_idx[cluster_mask]
        if cluster_ids.size == 0:
            continue
        cluster_w = contracts[cluster_ids]
        cluster_util = accepted_utils[cluster_mask]

        # Weight emphasizing better contracts: util - min + 1
        min_util = cluster_util.min()
        weights = cluster_util - min_util + 1.0
        if weights.sum() < 1e-12:
            weights = np.ones_like(weights)
        weights /= weights.sum()

        avg_w = np.average(cluster_w, axis=0, weights=weights)
        p = np.clip(avg_w, 0, None)
        s = p.sum()
        if s < 1e-12:
            p = np.ones(m) / m
        else:
            p /= s

        # IR constraint lower bound on cost: minimal p @ w_i over cluster contracts
        vals = np.array([p @ contracts[i] for i in cluster_ids])
        cost_lb = vals.min()

        p_candidates.append(p)
        cost_lb_candidates.append(cost_lb)

    p_candidates = np.array(p_candidates)  # (n_actions, 5)
    cost_lb_candidates = np.array(cost_lb_candidates)  # (n_actions,)

    # Rejection constraints must hold strictly: costs > max p @ w_j for rejected contracts
    if rejected_idx.size > 0:
        rejected_w = contracts[rejected_idx]  # (#rej, 5)
        p_w_rej = p_candidates @ rejected_w.T  # (n_actions, #rej)
        cost_rej_min = p_w_rej.max(axis=1) + 1e-8
    else:
        cost_rej_min = np.zeros_like(cost_lb_candidates)

    # Costs satisfy both IR and rejection constraints
    costs = np.maximum(cost_lb_candidates, cost_rej_min)
    costs = np.maximum(costs, 0.0)

    def action_explains_contract(w_i):
        utils = p_candidates @ w_i - costs
        valid = np.where(utils >= -1e-9)[0]
        return valid[0] if valid.size > 0 else None

    # Add dummy actions to explain any accepted contract not yet rationalized
    for idx in accepted_idx:
        w_i = contracts[idx]
        if action_explains_contract(w_i) is None:
            p_new = np.clip(w_i, 0, None)
            s = p_new.sum()
            if s < 1e-12:
                p_new = np.ones(m) / m
            else:
                p_new /= s
            c_new = p_new @ w_i
            p_candidates = np.vstack([p_candidates, p_new])
            costs = np.append(costs, c_new)

    n_actions = p_candidates.shape[0]

    # Re-validate rejection constraints and adjust costs upward if needed for new actions
    if rejected_idx.size > 0:
        rejected_w = contracts[rejected_idx]
        p_w_rej = p_candidates @ rejected_w.T  # (n_actions, #rej)
        for a in range(n_actions):
            max_rej_util = p_w_rej[a].max()
            if costs[a] < max_rej_util + 1e-9:
                costs[a] = max_rej_util + 1e-4

    # Formulate LP to refine costs with strict rejection constraints and cost â‰¥ 0
    epsilon = 1e-5
    A_ub = []
    b_ub = []
    for a in range(n_actions):
        for r in rejected_idx:
            constr_val = p_candidates[a] @ contracts[r] + epsilon
            # -c_a <= -constr_val  =>  c_a >= constr_val
            row = np.zeros(n_actions)
            row[a] = -1.0
            A_ub.append(row)
            b_ub.append(-constr_val)
    if A_ub:
        A_ub = np.vstack(A_ub)
        b_ub = np.array(b_ub)
    else:
        A_ub = None
        b_ub = None

    bounds = [(0, None)] * n_actions
    c_obj = np.zeros(n_actions)

    res = linprog(c_obj, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs', options={"disp": False})
    if res.success:
        costs = res.x
    # else fallback to previous costs (already feasible)

    # Final robust normalization of p_candidates
    p_candidates = np.clip(p_candidates, 0, None)
    row_sums = p_candidates.sum(axis=1, keepdims=True)
    row_sums[row_sums < 1e-12] = 1.0
    p_candidates /= row_sums

    costs = np.maximum(costs, 0.0)

    agent_setting = np.hstack([p_candidates, costs[:, None]])
    return agent_setting
```
