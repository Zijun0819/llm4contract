```python
import numpy as np
from scipy.optimize import linprog
from sklearn.cluster import KMeans

def agent_solver_v2(v: np.ndarray, content: list[dict]) -> np.ndarray:
    """
    Infer a valid agent setting matrix from historical contract interactions,
    tightly fitting accepted contracts via convex optimization,
    enforcing incentive compatibility (IC) and individual rationality (IR),
    and handling rejected contracts by adjusting costs or adding dummy actions.

    Parameters:
    - v: Principal reward vector of shape (5,)
    - content: List of dicts, each with keys 'Contract' (list of 5 floats),
               'Principal Utility' (float), 'Agent Action' (1 or -1)

    Returns:
    - agent_setting: n x 6 numpy array where each row represents an action:
        first 5 elements are outcome probabilities (sum to 1),
        last element is agent's cost (>=0) for performing the action.
    """
    m_outcomes = v.shape[0]
    L = len(content)

    # Parse logs into arrays
    contracts = np.array([entry['Contract'] for entry in content], dtype=np.float64)  # (L,5)
    p_utils = np.array([entry['Principal Utility'] for entry in content], dtype=np.float64)  # (L,)
    agent_actions = np.array([entry['Agent Action'] for entry in content], dtype=int)  # (L,)

    accepted_idx = np.where(agent_actions == 1)[0]
    rejected_idx = np.where(agent_actions == -1)[0]

    # If no accepted logs, return trivial uniform action with zero cost
    if len(accepted_idx) == 0:
        p_uniform = np.ones(m_outcomes) / m_outcomes
        return np.hstack([p_uniform, [0.0]]).reshape(1, -1)

    # --- Step 1: Cluster accepted contracts to find candidate actions ---
    # Use accepted contracts as clustering features
    unique_accepts = np.unique(contracts[accepted_idx], axis=0)
    # Adaptive candidate number choice:
    n_candidates = min(max(2, len(unique_accepts) // 2), 10)
    n_candidates = min(n_candidates, len(accepted_idx))
    if n_candidates < 1:
        n_candidates = 1

    # KMeans clustering of accepted contracts
    kmeans = KMeans(n_clusters=n_candidates, random_state=42, n_init=15)
    cluster_labels = kmeans.fit_predict(contracts[accepted_idx])

    # --- Step 2: For each cluster, solve LP to find (p, c) ---
    # Variables: p in R^5 (probabilities), c >= 0 (cost)
    # Constraints:
    #   sum(p) = 1, p >= 0
    #   For each accepted contract w_i in cluster: p @ w_i >= c  <=>  -p @ w_i + c <= 0
    # Objective: minimize c

    n_vars = m_outcomes + 1  # p(5) + c(1)
    c_var_idx = m_outcomes

    p_list = []
    c_list = []

    for clus in range(n_candidates):
        idxs = accepted_idx[cluster_labels == clus]
        W = contracts[idxs]  # shape (#cluster, 5)

        # Equality: sum p_i = 1
        A_eq = np.zeros((1, n_vars))
        A_eq[0, :m_outcomes] = 1.0
        b_eq = np.array([1.0])

        # Inequality: -p @ w_i + c <= 0 for each i in cluster
        A_ub = np.zeros((len(W), n_vars))
        b_ub = np.zeros(len(W))
        for i, w_i in enumerate(W):
            A_ub[i, :m_outcomes] = -w_i
            A_ub[i, c_var_idx] = 1.0

        bounds = [(0, 1)] * m_outcomes + [(0, None)]

        # Objective: minimize c
        c_obj = np.zeros(n_vars)
        c_obj[c_var_idx] = 1.0

        res = linprog(c=c_obj, A_ub=A_ub, b_ub=b_ub,
                      A_eq=A_eq, b_eq=b_eq,
                      bounds=bounds, method='highs')

        if res.success:
            p_candidate = res.x[:m_outcomes]
            cost_candidate = res.x[c_var_idx]
        else:
            # fallback: uniform p, zero cost
            p_candidate = np.ones(m_outcomes) / m_outcomes
            cost_candidate = 0.0

        # Numerical cleanup
        p_candidate = np.maximum(p_candidate, 0)
        s = p_candidate.sum()
        if s < 1e-12:
            p_candidate = np.ones(m_outcomes) / m_outcomes
        else:
            p_candidate /= s
        cost_candidate = max(cost_candidate, 0.0)

        p_list.append(p_candidate)
        c_list.append(cost_candidate)

    p_matrix = np.array(p_list)        # (n_candidates, 5)
    c_vec = np.array(c_list)           # (n_candidates,)

    # --- Step 3: Enforce rejection constraints ---
    # For each rejected contract w_j and every action a:
    #     p[a] @ w_j - c[a] < 0  =>  c[a] > p[a] @ w_j
    # If violated, increase cost accordingly

    if len(rejected_idx) > 0:
        rej_contracts = contracts[rejected_idx]  # (#rej, 5)
        utils_rej = p_matrix @ rej_contracts.T  # (n_candidates, #rej)

        # Violations: where utility >= cost (agent would accept rejected contract)
        violations = utils_rej >= (c_vec[:, None] - 1e-12)

        # Increase costs minimally to fix violations
        for j in range(violations.shape[1]):
            viol_actions = np.where(violations[:, j])[0]
            if viol_actions.size == 0:
                continue
            for a_idx in viol_actions:
                required_cost = utils_rej[a_idx, j] + 1e-6
                if required_cost > c_vec[a_idx]:
                    c_vec[a_idx] = required_cost

        # Re-check to ensure no violations remain
        utils_rej_post = p_matrix @ rej_contracts.T
        if np.any(utils_rej_post >= c_vec[:, None] - 1e-9):
            # Add dummy action that strictly rejects all rejected contracts
            p_dummy = np.ones(m_outcomes) / m_outcomes
            max_rej_util = (p_dummy @ rej_contracts.T).max()
            cost_dummy = max_rej_util + 1e3
            p_matrix = np.vstack([p_matrix, p_dummy])
            c_vec = np.concatenate([c_vec, [cost_dummy]])

    # --- Step 4: Enforce IC and IR for accepted contracts ---
    # Each accepted contract must have some action with utility >= 0 (IR)
    # and that chosen action(s) must have utility not exceeded by others (IC)

    for i in accepted_idx:
        w_i = contracts[i]
        utilities = p_matrix @ w_i - c_vec  # (n_actions,)

        max_util = np.max(utilities)
        if max_util < -1e-9:
            # No existing action explains acceptance -> add new action exactly explaining it
            p_new = np.maximum(w_i, 0)
            s = p_new.sum()
            if s < 1e-12:
                p_new = np.ones(m_outcomes) / m_outcomes
            else:
                p_new /= s
            cost_new = p_new @ w_i
            cost_new = max(cost_new, 0.0)
            p_matrix = np.vstack([p_matrix, p_new])
            c_vec = np.concatenate([c_vec, [cost_new]])
            utilities = np.append(utilities, max_util)

            max_util = cost_new - cost_new + p_new @ w_i - cost_new  # = 0 by construction

        # Actions with near-maximal utility considered chosen by agent
        chosen_actions = np.where(utilities >= max_util - 1e-9)[0]

        # Enforce IC: no other action has strictly higher utility on this contract
        # If violated, increase other action cost minimally
        for chosen_a in chosen_actions:
            for other_a in range(len(c_vec)):
                if other_a == chosen_a:
                    continue
                diff = utilities[other_a] - utilities[chosen_a]
                if diff > 0:
                    # Increase cost of other_a minimally to fix violation
                    increment = diff + 1e-6
                    required_cost = p_matrix[other_a] @ w_i + increment
                    if required_cost > c_vec[other_a]:
                        c_vec[other_a] = required_cost
                        # Update utilities after cost change
                        utilities[other_a] = p_matrix[other_a] @ w_i - c_vec[other_a]

    # Final cleanup
    p_matrix = np.maximum(p_matrix, 0)
    row_sums = p_matrix.sum(axis=1, keepdims=True)
    row_sums[row_sums < 1e-12] = 1.0  # avoid div by zero
    p_matrix /= row_sums
    c_vec = np.clip(c_vec, 0, None)

    agent_setting = np.hstack([p_matrix, c_vec[:, None]])

    return agent_setting
```
