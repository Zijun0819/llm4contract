```python
import numpy as np
import pandas as pd
from scipy.optimize import linprog, minimize
from sklearn.cluster import KMeans


def agent_solver_v2(v: np.ndarray, content: list[dict]) -> np.ndarray:
    """
    Infer a valid agent setting given principal's reward vector v and historical interaction logs.
    - Uses clustering on accepted contracts' implied outcome distributions.
    - Jointly solves for outcome distributions and costs via constrained optimization to satisfy IR and IC.
    - Ensures rejected contracts yield negative utility for all actions.
    """

    m_outcomes = v.shape[0]
    L = len(content)

    # Extract contracts, principal utilities, and actions
    contracts = np.array([log['Contract'] for log in content])  # shape (L, m_outcomes)
    principals_util = np.array([log['Principal Utility'] for log in content])  # shape (L,)
    agent_actions = np.array([log['Agent Action'] for log in content])  # shape (L,)

    # Step 1: Focus on accepted contracts to infer candidate agent outcome distributions
    # For each accepted contract w, recover a plausible outcome distribution p
    # by solving: max_p p @ w subject to p in simplex and p@(v-w) = u_agent (unknown)
    # Approximate agent expected utilities for accepted contracts as >=0,
    # so try solving min norm (p@w - principal_utility), as principal utility = p@v - c, so p@v = principal_utility + c
    # We can't solve directly, try a proxy: For each accepted contract, find p maximizing expected wage (p@w) s.t. sum p=1

    accepted_idx = np.where(agent_actions == 1)[0]
    rejected_idx = np.where(agent_actions == -1)[0]

    # If no accepted logs, return trivial valid setting: uniform outcome, zero cost
    if len(accepted_idx) == 0:
        uniform_p = np.ones(m_outcomes) / m_outcomes
        return np.hstack([uniform_p.reshape(1, -1), np.array([[0.0]])])

    # Step 2: Heuristic to propose number of agent actions: e.g. min(7, unique contracts accepted)
    n_candidates = min(7, len(accepted_idx))

    # Step 3: Approximate outcome distributions for accepted contracts:
    # For each accepted contract w, seek p solving max p @ w
    # s.t. p in simplex and p@v >= c + 0 (nonnegative utility)
    # As c unknown, only constrain p to simplex.
    def infer_p_given_w(w):
        # maximize p @ w s.t. sum p=1, p>=0
        # i.e. p is pure indicator on max(w)
        # To be more expressive, solve:
        # max p@w s.t. sum p=1, p>=0
        # Solution puts all mass on max reward index
        p = np.zeros_like(w)
        max_idx = np.argmax(w)
        p[max_idx] = 1.0
        return p

    candidate_ps = []
    for i in accepted_idx:
        w = contracts[i]
        p_i = infer_p_given_w(w)
        candidate_ps.append(p_i)

    candidate_ps = np.array(candidate_ps)

    # Step 4: Cluster candidate_ps into n_candidates clusters
    kmeans = KMeans(n_clusters=n_candidates, random_state=0, n_init=10).fit(candidate_ps)
    p0 = kmeans.cluster_centers_  # shape (n_candidates, m_outcomes)
    # Normalize to simplex in case of rounding
    p0 = np.clip(p0, 0, None)
    p0 /= p0.sum(axis=1, keepdims=True)

    # Step 5: Assign each accepted contract to best action (max p @ w)
    assigns = np.full(L, -1, dtype=int)
    for i in accepted_idx:
        w = contracts[i]
        utilities = p0 @ w
        assigns[i] = int(np.argmax(utilities))

    # Step 6: We will optimize costs c >= 0 to satisfy IR, IC, and rejection conditions.
    # Let costs be vector c of length n_candidates.
    # Constraints:

    # IR: For accepted contracts i assigned to action a,
    # the agent's utility u_i = p0[a]@w[i] - c[a] >= 0
    # So c[a] <= p0[a] @ w[i]

    # IC: For accepted contract i assigned to action a and any other action a',
    # u_i(a) >= u_i(a'), i.e. p0[a]@w[i] - c[a] >= p0[a']@w[i] - c[a']
    # Rearranged: c[a'] - c[a] >= p0[a']@w[i] - p0[a]@w[i]

    # Rejection: For rejected contracts j (action -1),
    # agent utility u_j(a) = p0[a] @ w[j] - c[a] < 0 for all a
    # Meaning c[a] > p0[a] @ w[j]

    # We formulate these as linear inequalities and solve for c using linear program / or QP.

    from scipy.optimize import linprog

    n = n_candidates

    # Inequalities will be collected as:
    # A_ub @ c <= b_ub

    # IR upper bounds: c[a] <= min_{i:assigns[i]=a} p0[a]@w[i]
    # We'll convert to form -c[a] <= -min_val (multiply by -1)
    # IC inequalities: c[a'] - c[a] >= p0[a']@w[i] - p0[a]@w[i]
    # => -c[a'] + c[a] <= -(p0[a']@w[i] - p0[a]@w[i])
    # rejection: c[a] > p0[a]@w[j] => -c[a] < -p0[a]@ w[j] - eps (strict, approximate with small eps)
    # We use epsilon = 1e-6 for strict inequality

    epsilon = 1e-6

    A_ub_rows = []
    b_ub_rows = []

    # IR constraints
    for a in range(n):
        idxs = np.where(assigns == a)[0]
        if len(idxs) > 0:
            vals = np.array([p0[a] @ contracts[i] for i in idxs])
            ub = vals.min()
            # -c[a] <= -ub
            row = np.zeros(n)
            row[a] = -1
            A_ub_rows.append(row)
            b_ub_rows.append(-ub)
        else:
            # No accepted contract assigned, so IR cost can be zero or free
            # c[a] >= 0 already enforced by bounds below
            pass

    # IC constraints
    # For each accepted contract i assigned to a, for each a' != a:
    # -c[a'] + c[a] <= -(p0[a']@w - p0[a]@w)
    for i in accepted_idx:
        a = assigns[i]
        w = contracts[i]
        for a2 in range(n):
            if a2 == a:
                continue
            val = (p0[a2] @ w) - (p0[a] @ w)
            row = np.zeros(n)
            row[a2] = -1
            row[a] = +1
            A_ub_rows.append(row)
            b_ub_rows.append(-val)

    # Rejection constraints
    # For each rejected contract j, for all actions a:
    # -c[a] < -p0[a]@ w[j] - epsilon  =>  -c[a] <= -p0[a]@ w[j] - epsilon
    for j in rejected_idx:
        w = contracts[j]
        for a in range(n):
            val = p0[a] @ w
            row = np.zeros(n)
            row[a] = -1
            A_ub_rows.append(row)
            b_ub_rows.append(-val - epsilon)

    A_ub = np.vstack(A_ub_rows) if A_ub_rows else np.zeros((0, n))
    b_ub = np.array(b_ub_rows) if b_ub_rows else np.array([])

    # costs >= 0
    bounds = [(0, None) for _ in range(n)]

    # Objective: minimize sum of costs for parsimony
    c_obj = np.ones(n)

    # Solve LP for costs c
    res = linprog(c=c_obj, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')

    if not res.success:
        # fallback: set c as maximal IR lower bound and zero where undefined
        c_fallback = np.zeros(n)
        for a in range(n):
            idxs = np.where(assigns == a)[0]
            if len(idxs) > 0:
                vals = np.array([p0[a] @ contracts[i] for i in idxs])
                c_fallback[a] = vals.min()
        costs = c_fallback
    else:
        costs = res.x

    # To guarantee rejecting contracts utility < 0:
    # Add small slack to costs
    if len(rejected_idx) > 0:
        slack = 1e-4
        for a in range(n):
            max_rej_util = max((p0[a] @ contracts[j]) for j in rejected_idx)
            if costs[a] <= max_rej_util:
                costs[a] = max_rej_util + slack

    # Final agent setting matrix: (n_candidates) x (5 + 1)
    agent_setting = np.hstack([p0, costs.reshape(-1, 1)])

    # Normalize rows p0 again (safety)
    outcome_probs = agent_setting[:, :m_outcomes]
    outcome_probs = np.clip(outcome_probs, 0, None)
    outcome_probs /= outcome_probs.sum(axis=1, keepdims=True)
    agent_setting[:, :m_outcomes] = outcome_probs

    # Costs non-negative
    agent_setting[:, -1] = np.maximum(agent_setting[:, -1], 0)

    return agent_setting
```
