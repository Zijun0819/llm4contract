```python
import numpy as np
import pandas as pd
from sklearn.cluster import KMeans
from scipy.optimize import linprog

def agent_solver_v2(v: np.ndarray, content: list[dict]) -> np.ndarray:
    """
    Infer a valid agent setting (actions defined by outcome distributions and cost)
    consistent with historical contract logs under IR and IC constraints.

    Args:
        v: np.ndarray, shape (5,), principal reward vector.
        content: list of dicts, each dict with keys:
            'Contract': list or array of 5 payments,
            'Principal Utility': float,
            'Agent Action': int (1 for accept, -1 for reject).

    Returns:
        np.ndarray of shape (n_actions, 6), each row:
        [p_1, p_2, p_3, p_4, p_5, cost], where p_i sum to 1 and cost >= 0.
    """
    m_outcomes = v.shape[0]
    logs = pd.DataFrame(content)

    contracts = np.vstack(logs["Contract"].values)  # (L, 5)
    principal_utils = logs["Principal Utility"].values  # (L,)
    agent_actions = logs["Agent Action"].values  # (L,)

    accepted_idx = np.where(agent_actions == 1)[0]
    rejected_idx = np.where(agent_actions == -1)[0]
    L = len(agent_actions)

    # If no accepted contracts, return trivial uniform action with zero cost
    if len(accepted_idx) == 0:
        uniform_p = np.ones(m_outcomes) / m_outcomes
        return np.hstack([uniform_p.reshape(1, -1), np.array([[0.0]])])

    # Step 1: Infer candidate outcome distributions for accepted contracts
    # Use solution that places full mass on max payment outcome (deterministic max)
    candidate_ps = np.zeros((len(accepted_idx), m_outcomes))
    for i, idx in enumerate(accepted_idx):
        w = contracts[idx]
        p = np.zeros_like(w)
        max_indices = np.flatnonzero(np.isclose(w, w.max()))
        # If multiple max indices, distribute mass evenly among them
        p[max_indices] = 1.0 / len(max_indices)
        candidate_ps[i] = p

    # Step 2: Cluster candidate_ps to get prototype agent actions
    # Number of clusters adaptively chosen: min(7, accepted contracts count)
    n_actions = min(7, len(accepted_idx))
    kmeans = KMeans(n_clusters=n_actions, random_state=42, n_init=20).fit(candidate_ps)
    p_centroids = kmeans.cluster_centers_

    # Normalize centroids to simplex (just in case)
    p_centroids = np.clip(p_centroids, 0, None)
    p_centroids /= np.maximum(p_centroids.sum(axis=1, keepdims=True), 1e-12)

    # Step 3: Assign each accepted contract to best fitting action by max expected wage
    assigns = np.full(L, -1, dtype=int)
    for idx in accepted_idx:
        w = contracts[idx]
        utilities = p_centroids @ w
        assigns[idx] = int(np.argmax(utilities))

    # Step 4: Form linear constraints to solve for costs c (one per action)
    # Variables: c_a >= 0
    # IR constraints:
    #   For accepted contract i assigned to a: c_a <= p_a @ w_i
    # IC constraints:
    #   For accepted contract i assigned to a, for all a' != a:
    #       c_{a'} - c_a >= p_{a'}@w_i - p_a@w_i
    # Rejection constraints:
    #   For all rejected contract j and all actions a:
    #       c_a > p_a @ w_j  (approximate strict by c_a >= p_a @ w_j + eps)

    epsilon = 1e-8
    n = n_actions

    A_ub_rows = []
    b_ub_rows = []

    # IR (Participation) constraints: c_a <= min_{i:assigns[i]=a} p_a @ w_i
    for a in range(n):
        idxs = np.where(assigns == a)[0]
        if len(idxs) == 0:
            # No accepted contracts assigned, no IR constraint needed for this action
            continue
        vals = np.array([p_centroids[a] @ contracts[i] for i in idxs])
        ub = vals.min()
        # c_a <= ub  <=>  -c_a <= -ub
        row = np.zeros(n)
        row[a] = -1
        A_ub_rows.append(row)
        b_ub_rows.append(-ub)

    # IC (Incentive Compatibility) constraints:
    # For each accepted contract i assigned to a:
    #   For each other action a2:
    #   c_{a2} - c_a >= p_{a2}@w_i - p_a@w_i
    #   => -c_{a2} + c_a <= -(p_{a2}@w_i - p_a@w_i)
    for i in accepted_idx:
        a = assigns[i]
        w = contracts[i]
        for a2 in range(n):
            if a2 == a:
                continue
            val = (p_centroids[a2] @ w) - (p_centroids[a] @ w)
            row = np.zeros(n)
            row[a2] = -1
            row[a] = 1
            A_ub_rows.append(row)
            b_ub_rows.append(-val)

    # Rejection constraints:
    # For each rejected contract j and action a:
    # c_a > p_a @ w_j => c_a >= p_a @ w_j + epsilon
    # -c_a <= -p_a @ w_j - epsilon
    for j in rejected_idx:
        w = contracts[j]
        for a in range(n):
            val = p_centroids[a] @ w
            row = np.zeros(n)
            row[a] = -1
            A_ub_rows.append(row)
            b_ub_rows.append(-val - epsilon)

    if A_ub_rows:
        A_ub = np.vstack(A_ub_rows)
        b_ub = np.array(b_ub_rows)
    else:
        A_ub = None
        b_ub = None

    bounds = [(0, None) for _ in range(n)]
    c_obj = np.ones(n)  # minimize sum of costs for parsimony

    # Solve LP for costs c
    res = linprog(c=c_obj, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs', options={'presolve': True})

    if not res.success:
        # Fallback: set costs to min IR upper bound for each action or zero if none
        costs = np.zeros(n)
        for a in range(n):
            idxs = np.where(assigns == a)[0]
            if len(idxs) > 0:
                vals = np.array([p_centroids[a] @ contracts[i] for i in idxs])
                costs[a] = vals.min()
    else:
        costs = np.clip(res.x, 0, None)

    # Enforce strict rejection utilities < 0 by small slack adjustment
    if len(rejected_idx) > 0:
        slack = 1e-6
        for a in range(n):
            max_rej_util = max((p_centroids[a] @ contracts[j]) for j in rejected_idx)
            if costs[a] <= max_rej_util:
                costs[a] = max_rej_util + slack

    # Final agent setting matrix: [p_1,...,p_5, cost]
    # Normalize probabilities again for safety
    p_centroids = np.clip(p_centroids, 0, None)
    p_sums = p_centroids.sum(axis=1, keepdims=True)
    p_sums[p_sums < 1e-12] = 1.0  # avoid division by zero
    p_centroids /= p_sums

    agent_setting = np.hstack([p_centroids, costs.reshape(-1, 1)])

    return agent_setting
```
