```python
import numpy as np
import pandas as pd
from scipy.optimize import linprog
from sklearn.cluster import AgglomerativeClustering


def agent_solver_v2(v: np.ndarray, content: pd.DataFrame) -> np.ndarray:
    """
    Infer a valid agent setting (probabilities and costs) consistent with historical contract logs.
    
    Strategy:
    1. Extract accepted contracts and estimate corresponding expected outcome distributions.
    2. Cluster these inferred distributions using Agglomerative Clustering (to automatically determine n).
    3. For each cluster (action), infer the cost as the minimal agent cost consistent with IR and IC.
    4. Validate rejection logs for no spurious acceptances under inferred costs.
    
    Returns:
        agent_setting: np.ndarray of shape (n_actions, 6)
            Rows represent agent actions,
            cols 0-4 represent outcome probabilities,
            col 5 is the non-negative cost for that action.
    """
    contracts = np.array(content['Contract'].tolist())
    principal_utils = content['Principal Utility'].to_numpy()
    actions = content['Agent Action'].to_numpy()
    n_logs = len(content)
    m = len(v)  # number of outcomes

    # Helper: Solve lp for p given contract w to best fit principal utility u
    def infer_p(w: np.ndarray, u: float):
        # We try to find p s.t p.w = u agent expected payment and sum(p) =1, p>=0
        # But utility depends on p.(w - c), we want p summing 1 and p·w close to u.
        # Minimize ||p.w - u|| subject to sum p=1, p>=0
        # We reformulate as linear program:
        # Since p.w = sum_i p_i w_i, and sum_i p_i=1
        #
        # We solve:
        # min t
        # s.t p.w - u <= t
        #      u - p.w <= t
        #      sum p_i=1
        #      p_i>=0
        # Use linprog with slack variable t:
        c_obj = np.zeros(m + 1)
        c_obj[-1] = 1  # minimize t
        # Constraints matrix:
        #  1)p.w - u <= t  --> p.w - t <= u
        #  2)u - p.w <= t  --> -p.w - t <= -u
        A_ub = np.zeros((2, m + 1))
        A_ub[0, :m] = w
        A_ub[0, -1] = -1
        b_ub = np.array([u])
        A_ub[1, :m] = -w
        A_ub[1, -1] = -1
        b_ub = np.append(b_ub, -u)

        # Equality sum p_i=1
        A_eq = np.zeros((1, m + 1))
        A_eq[0, :m] = 1
        b_eq = np.array([1])

        bounds = [(0, 1)] * m + [(0, None)]  # p_i ∈ [0,1], t≥0

        res = linprog(c=c_obj, A_ub=A_ub, b_ub=b_ub, A_eq=A_eq, b_eq=b_eq, bounds=bounds, method='highs')
        if res.success:
            p = res.x[:m]
            # Check sum ~1 and p≥0, normalize to be safe
            p = np.clip(p, 0, None)
            p = p / p.sum()
            return p
        else:
            return None

    # Infer distributions p_i for all accepted contracts
    inferred_ps = []
    accepted_indices = []
    for i in range(n_logs):
        if actions[i] == 1:
            p_i = infer_p(contracts[i], principal_utils[i])
            if p_i is not None:
                inferred_ps.append(p_i)
                accepted_indices.append(i)
    if len(inferred_ps) == 0:
        # fallback: uniform distributions with zero costs dummy one action
        prob_uniform = np.ones(m) / m
        cost_dummy = 0.0
        return np.array([np.hstack((prob_uniform, cost_dummy))])

    inferred_ps = np.array(inferred_ps)  # shape (num_accepted, m)

    # Cluster inferred_ps to form actions adaptively using AgglomerativeClustering
    # until within-cluster max L2 dist ≤ threshold (heuristic)
    max_dist_threshold = 0.3
    n_clusters = 1
    while True:
        clusterer = AgglomerativeClustering(n_clusters=n_clusters)
        labels = clusterer.fit_predict(inferred_ps)
        # Compute max intra-cluster L2 distance
        max_within = 0
        for c in range(n_clusters):
            pts = inferred_ps[labels == c]
            if len(pts) < 2:
                continue
            dists = np.linalg.norm(pts[:, None] - pts[None, :], axis=2)
            max_within = max(max_within, np.max(dists))
        if max_within <= max_dist_threshold or n_clusters >= min(len(inferred_ps), 10):
            break
        n_clusters += 1

    # Compute centroids as final p of each action, enforce normalization and non-negativity
    p_actions = np.zeros((n_clusters, m))
    for c in range(n_clusters):
        cluster_ps = inferred_ps[labels == c]
        p_c = cluster_ps.mean(axis=0)
        p_c = np.clip(p_c, 0, None)
        if p_c.sum() == 0:
            p_c = np.ones(m) / m
        else:
            p_c /= p_c.sum()
        p_actions[c] = p_c

    # Assign all logs (accepted) to closest action by utility comparison on contract
    train_assign = np.full(n_logs, -1, dtype=int)
    for idx, i in enumerate(accepted_indices):
        contract_w = contracts[i]
        # Utility = p @ w - cost, cost unknown but cost same for given action, pick closest p maximizing p.w
        utilities = p_actions @ contract_w
        train_assign[i] = utilities.argmax()

    # Now infer costs for each action using accepted contracts assigned to them:
    # For action a: cost_a = min_i [p_a . w_i - agent utility from i] 
    # But agent utility not observed directly, IR means costs ≤ p_a.w for contracts accepted by that action.
    # Principal Utility = <w_i,v> - Agent utility, and agent accepted means agent utility≥0
    # We approximate cost_a ≈ min_i p_a.w_i (agent expected payment) among contracts assigned to action a, as lower bound of cost
    # Also consider rejection logs to ensure no rejected contract is mistakenly acceptable by actions.

    costs = np.zeros(n_clusters)
    for c in range(n_clusters):
        assigned_idxs = np.where(train_assign == c)[0]
        if len(assigned_idxs) == 0:
            costs[c] = 0.0
            continue
        p_c = p_actions[c]
        # Get minimal expected wage among assigned contracts
        expected_wages = contracts[assigned_idxs] @ p_c
        min_exp_wage = expected_wages.min()
        # Cost ≤ min_exp_wage to ensure IR
        costs[c] = max(min_exp_wage, 0.0)

    # Increase costs if any rejection contract is accepted by mistake under current costs (IC)
    reject_idxs = np.where(actions == -1)[0]
    if len(reject_idxs) > 0:
        p_reject_wages = contracts[reject_idxs] @ p_actions.T  # shape (n_rej, n_actions)
        # Agent utility = p . w - cost, must be < 0 for rejected contracts by all actions
        # If p_reject_wage[c] - costs[c] ≥ 0 means inconsistency
        violations = (p_reject_wages - costs[np.newaxis, :]) >= 0
        # To fix, raise costs for violated actions minimally so these no longer accept problematic contracts
        for c in range(n_clusters):
            viol_idx = np.where(violations[:, c])[0]
            if len(viol_idx) == 0:
                continue
            # Increase cost to just above max agent expected payment among those contracts rejected
            max_violation_val = p_reject_wages[viol_idx, c].max()
            costs[c] = max(costs[c], max_violation_val + 1e-6)  # tiny margin

    # Final safety clamp to non-negative costs
    costs = np.clip(costs, 0, None)

    agent_setting = np.hstack((p_actions, costs[:, None]))
    return agent_setting
```
