```python
import numpy as np
from scipy.optimize import linprog
from sklearn.cluster import KMeans

def agent_solver_v2(v: np.ndarray, content: list[dict]) -> np.ndarray:
    """
    Infer a valid agent setting matrix (n_actions x 6) where each row is:
    [probabilities over 5 outcomes (sum to 1), cost ≥ 0].

    Inputs:
    - v: np.ndarray of shape (5,), principal's reward vector over outcomes.
    - content: list of dicts with keys:
        'Contract': list/array of length 5 (payment vector),
        'Principal Utility': float,
        'Agent Action': 1 (accept) or -1 (reject).

    Returns:
    - agent_setting: np.ndarray shape (n_actions, 6) with each row:
      [p_1,...,p_5, cost], p_i ≥ 0, sum p_i=1, cost ≥ 0.
    """
    np.random.seed(42)
    m = len(v)
    L = len(content)
    eps_rej = 1e-6  # Strict inequality margin for rejection constraints
    slack_cost_bump = 1e-5  # To strictly enforce rejection cost margin

    # Parse logs
    contracts = np.array([log['Contract'] for log in content], dtype=np.float64)  # (L,m)
    agent_actions = np.array([log['Agent Action'] for log in content], dtype=int)
    principal_utils = np.array([log['Principal Utility'] for log in content], dtype=np.float64)

    accepted_idx = np.where(agent_actions == 1)[0]
    rejected_idx = np.where(agent_actions == -1)[0]

    # If no accepted contracts, fallback trivial uniform action with zero cost
    if len(accepted_idx) == 0:
        uniform_p = np.ones(m) / m
        return np.hstack([uniform_p.reshape(1, -1), np.array([[0.0]])])

    accepted_contracts = contracts[accepted_idx]

    # Adaptive max clusters based on data size
    # At least 2 clusters, max 8 or max 10% of accepted contracts count
    max_K = min(8, max(2, max(1, len(accepted_idx) // 10)))
    if max_K < 1:
        max_K = 1

    max_attempts = 7
    attempt = 0

    while attempt < max_attempts and max_K >= 1:
        try:
            if max_K == 1:
                # Just one cluster: center = mean of accepted contracts
                centers_w = accepted_contracts.mean(axis=0, keepdims=True)
            else:
                # Cluster accepted contracts using kmeans on contract payment vectors
                kmeans = KMeans(n_clusters=max_K, random_state=0, n_init=20).fit(accepted_contracts)
                centers_w = kmeans.cluster_centers_  # (max_K, m)
        except Exception:
            # If clustering fails (e.g. too few points), reduce clusters
            max_K -= 1
            attempt += 1
            continue

        # Infer p_k for each cluster center w_k by LP: maximize p · w_k s.t p≥0 sum p=1
        p_candidates = np.zeros((max_K, m), dtype=np.float64)
        for k in range(max_K):
            w_k = centers_w[k]
            # Solve LP: max p·w_k <=> min -p·w_k
            res = linprog(
                c=-w_k,
                A_eq=[np.ones(m)],
                b_eq=[1.0],
                bounds=[(0, 1)] * m,
                method='highs',
            )
            if res.success and res.x is not None:
                p = res.x
                # Numerical safety: clip negatives and normalize
                p = np.clip(p, 0, None)
                s = p.sum()
                if s <= 0:
                    p = np.ones(m) / m
                else:
                    p /= s
                p_candidates[k] = p
            else:
                # fallback: place all mass on max coordinate of w_k
                p = np.zeros(m)
                max_idx = np.argmax(w_k)
                p[max_idx] = 1.0
                p_candidates[k] = p

        # Assign each accepted contract to nearest cluster (by Euclidean)
        if max_K == 1:
            assigned_clusters = np.zeros(len(accepted_idx), dtype=int)
        else:
            assigned_clusters = kmeans.predict(accepted_contracts)

        # Build IR constraints (accepted contracts):
        # For accepted contract i assigned to cluster k:
        # p_k · contract_i - cost_k >= 0  =>  cost_k <= p_k · contract_i
        accepted_rows = []
        accepted_bounds = []
        for idx_i, cluster_k in zip(accepted_idx, assigned_clusters):
            row = np.zeros(max_K, dtype=np.float64)
            row[cluster_k] = -1.0  # -cost_k
            bound = -np.dot(p_candidates[cluster_k], contracts[idx_i])
            accepted_rows.append(row)
            accepted_bounds.append(bound)
        if accepted_rows:
            accepted_rows = np.array(accepted_rows)
            accepted_bounds = np.array(accepted_bounds)
        else:
            accepted_rows = np.empty((0, max_K))
            accepted_bounds = np.array([])

        # Build rejection constraints:
        # For rejected contract j and cluster k:
        # p_k · contract_j - cost_k < 0 => cost_k > p_k · contract_j
        # Represent as: -cost_k <= -p_k · contract_j - eps_rej
        rejected_rows = []
        rejected_bounds = []
        for idx_j in rejected_idx:
            contract_j = contracts[idx_j]
            for k in range(max_K):
                row = np.zeros(max_K, dtype=np.float64)
                row[k] = -1.0  # -cost_k
                bound = -(np.dot(p_candidates[k], contract_j) + eps_rej)
                rejected_rows.append(row)
                rejected_bounds.append(bound)
        if rejected_rows:
            rejected_rows = np.array(rejected_rows)
            rejected_bounds = np.array(rejected_bounds)
        else:
            rejected_rows = np.empty((0, max_K))
            rejected_bounds = np.array([])

        # Combine inequality constraints
        if accepted_rows.size or rejected_rows.size:
            A_ub = np.vstack([accepted_rows, rejected_rows]) if accepted_rows.size and rejected_rows.size else (
                accepted_rows if accepted_rows.size else rejected_rows)
            b_ub = np.hstack([accepted_bounds, rejected_bounds]) if accepted_bounds.size and rejected_bounds.size else (
                accepted_bounds if accepted_bounds.size else rejected_bounds)
        else:
            A_ub = None
            b_ub = None

        # Bounds on costs: costs ≥ 0
        bounds_costs = [(0, None)] * max_K

        # Objective: minimize sum of costs (parsimony)
        c_obj = np.ones(max_K, dtype=np.float64)

        res_cost = linprog(
            c=c_obj,
            A_ub=A_ub,
            b_ub=b_ub,
            bounds=bounds_costs,
            method='highs',
        )

        if res_cost.success and res_cost.x is not None:
            costs = res_cost.x
            # Numerical safety: clip negatives and finite
            costs = np.clip(costs, 0, None)
            if not np.all(np.isfinite(costs)):
                max_K -= 1
                attempt += 1
                continue

            # Enforce strict rejection constraints by bumping costs if needed
            if len(rejected_idx) > 0:
                for i in range(len(costs)):
                    max_rej_util = max((p_candidates[i] @ contracts[j]) for j in rejected_idx)
                    if costs[i] <= max_rej_util:
                        costs[i] = max_rej_util + slack_cost_bump

            # Final cleanup: ensure p_candidates rows sum to 1 and nonnegative
            for i in range(p_candidates.shape[0]):
                p = p_candidates[i]
                p = np.clip(p, 0, None)
                s = p.sum()
                if s <= 0:
                    p = np.ones(m) / m
                else:
                    p /= s
                p_candidates[i] = p

            agent_setting = np.hstack([p_candidates, costs.reshape(-1, 1)])
            return agent_setting

        else:
            # Infeasible LP, try reducing clusters for simpler model
            max_K -= 1
            attempt += 1

    # Fallback: single uniform action with empirical distribution over accepted contracts' best outcomes
    outcome_counts = np.zeros(m, dtype=np.float64)
    for idx_i in accepted_idx:
        best_outcome = np.argmax(contracts[idx_i])
        outcome_counts[best_outcome] += 1
    if outcome_counts.sum() > 0:
        empirical_p = outcome_counts / outcome_counts.sum()
    else:
        empirical_p = np.ones(m) / m
    return np.hstack([empirical_p.reshape(1, -1), np.array([[0.0]])])
```
