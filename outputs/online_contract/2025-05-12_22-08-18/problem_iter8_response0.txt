```python
import numpy as np
from sklearn.cluster import AgglomerativeClustering
from scipy.optimize import linprog

def agent_solver_v2(v: np.ndarray, content: list[dict]) -> np.ndarray:
    """
    Infer a valid agent setting consistent with historical logs,
    enforcing IR/IC constraints globally using LP, adaptive clustering,
    dummy actions for unexplained acceptances, iterative cost refinement,
    and robust probability normalization.

    Parameters:
        v (np.ndarray): Principal's reward vector (length 5).
        content (list[dict]): List of dicts each with keys:
            'Contract' (list of 5 floats),
            'Principal Utility' (float),
            'Agent Action' (1 or -1).

    Returns:
        np.ndarray: n_actions x 6 array where each row is (p_1,...,p_5, cost),
                    p_i >= 0, sum p_i = 1, cost >= 0.
    """
    m_outcomes = v.size
    L = len(content)

    # Extract arrays
    contracts = np.array([log['Contract'] for log in content], dtype=np.float64)  # (L,5)
    principal_utils = np.array([log['Principal Utility'] for log in content], dtype=np.float64)  # (L,)
    agent_actions = np.array([log['Agent Action'] for log in content], dtype=int)  # (L,)

    accepted_ix = np.where(agent_actions == 1)[0]
    rejected_ix = np.where(agent_actions == -1)[0]

    # If no accepted contracts, return trivial uniform action with zero cost
    if accepted_ix.size == 0:
        uniform_p = np.ones(m_outcomes) / m_outcomes
        return np.hstack([uniform_p.reshape(1, -1), np.zeros((1,1))])

    accepted_contracts = contracts[accepted_ix]

    # Normalize accepted contracts for clustering on simplex (avoid divide by zero)
    accepted_sum = accepted_contracts.sum(axis=1, keepdims=True)
    accepted_sum[accepted_sum < 1e-12] = 1.0
    norm_accepted = accepted_contracts / accepted_sum

    # Adaptive clusters: min(10, #accepted, sqrt(#accepted))
    n_clusters = max(1, min(10, int(np.sqrt(accepted_ix.size)), accepted_ix.size))
    clustering = AgglomerativeClustering(n_clusters=n_clusters, linkage='average')
    labels = clustering.fit_predict(norm_accepted)

    p_candidates = []
    costs_lb = []

    # Build candidate actions: weighted centroid per cluster and cost lower bound from IR acceptance
    for cid in range(n_clusters):
        cluster_mask = (labels == cid)
        cluster_idx = accepted_ix[cluster_mask]
        if cluster_idx.size == 0:
            continue
        cluster_contracts = contracts[cluster_idx]
        cluster_pu = principal_utils[cluster_idx]

        # Weights shift: min to zero + 1 to ensure positivity
        weights = cluster_pu - cluster_pu.min() + 1.0
        avg_w = np.average(cluster_contracts, axis=0, weights=weights)

        # Project onto simplex: clip negatives, renormalize
        p = np.clip(avg_w, 0, None)
        p_sum = p.sum()
        if p_sum < 1e-12:
            p = np.ones(m_outcomes) / m_outcomes
        else:
            p /= p_sum
        p_candidates.append(p)

        # Cost lower bound from acceptance IR: cost ≤ min p @ w_i for i in cluster
        costs_i = np.array([p @ contracts[i] for i in cluster_idx])
        min_cost = costs_i.min()
        costs_lb.append(min_cost)

    if len(p_candidates) == 0:
        # fallback to uniform zero-cost action
        uniform_p = np.ones(m_outcomes) / m_outcomes
        return np.hstack([uniform_p.reshape(1, -1), np.zeros((1,1))])

    p_candidates = np.array(p_candidates)
    costs_lb = np.array(costs_lb)

    # Rejection constraints: cost > max_r p @ w_r for each action
    if rejected_ix.size > 0:
        rejected_contracts = contracts[rejected_ix]
        p_w_rej = p_candidates @ rejected_contracts.T  # shape (n_actions, n_rejected)
        rej_cost_min = p_w_rej.max(axis=1) + 1e-6
    else:
        rej_cost_min = np.zeros_like(costs_lb)

    # Initial costs satisfy IR (lower bound) and IC (rejection) constraints
    costs = np.maximum(costs_lb, rej_cost_min)
    costs = np.maximum(costs, 0.0)

    # Helper: check if any action rationalizes acceptance of contract w_i
    def any_action_accepts(w_i):
        for i, (p, c) in enumerate(zip(p_candidates, costs)):
            util = np.dot(p, w_i) - c
            if util >= -1e-9:
                return i
        return None

    # Add dummy actions exactly matching unexplained accepted contracts (minimal cost)
    for i in accepted_ix:
        w_i = contracts[i]
        if any_action_accepts(w_i) is None:
            p_new = np.clip(w_i, 0, None)
            p_sum = p_new.sum()
            if p_sum < 1e-12:
                p_new = np.ones(m_outcomes) / m_outcomes
            else:
                p_new /= p_sum
            c_new = p_new @ w_i
            p_candidates = np.vstack([p_candidates, p_new])
            costs = np.append(costs, c_new)

    n_actions = p_candidates.shape[0]

    # After adding new actions, re-check rejection constraints and adjust costs upward if needed
    if rejected_ix.size > 0:
        rejected_contracts = contracts[rejected_ix]
        p_w_rej = p_candidates @ rejected_contracts.T  # (n_actions, n_rejected)
        for a in range(n_actions):
            max_rej_util = p_w_rej[a].max()
            if costs[a] < max_rej_util + 1e-9:
                costs[a] = max_rej_util + 1e-4

    # Setup LP to refine costs enforcing rejection constraints strictly and costs ≥0
    # Constraints:
    #   For all rejected contracts r and actions a: c_a ≥ p_a @ w_r + ε
    # We do NOT enforce accepted contracts here (non-convex), rely on dummy actions coverage.

    epsilon = 1e-5
    A_ub = []
    b_ub = []
    for a in range(n_actions):
        for r in rejected_ix:
            val = p_candidates[a] @ contracts[r] + epsilon
            row = np.zeros(n_actions)
            row[a] = -1  # -c_a ≤ -val
            A_ub.append(row)
            b_ub.append(-val)
    if len(A_ub) > 0:
        A_ub = np.array(A_ub)
        b_ub = np.array(b_ub)
    else:
        A_ub = None
        b_ub = None

    # Bounds for costs ≥ 0
    bounds = [(0, None)] * n_actions

    # Objective: minimize sum costs (or zero vector) just to get feasible, stable costs
    c_obj = np.zeros(n_actions)

    # Solve LP
    res = linprog(c_obj, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs', options={"disp": False})
    if res.success:
        costs = res.x
    # else fallback to previous costs (already consistent)

    # Final robust normalization of p_candidates to valid probability distributions
    p_candidates = np.clip(p_candidates, 0, None)
    p_sums = p_candidates.sum(axis=1, keepdims=True)
    p_sums[p_sums < 1e-12] = 1.0
    p_candidates /= p_sums

    # Assemble final agent setting matrix: probabilities + cost column
    agent_setting = np.hstack([p_candidates, costs[:, None]])

    return agent_setting
```
