```python
import numpy as np
from sklearn.cluster import KMeans
from scipy.optimize import linprog

def agent_solver(v: np.ndarray, content: list[dict]) -> np.ndarray:
    """
    Infer a valid agent setting (probabilities over outcomes + cost) given:
    - v: principal's reward vector over outcomes (length 5)
    - content: list of logs, each dict with keys 'Contract', 'Principal Utility', 'Agent Action'

    Returns:
    - agent_setting: n x 6 array with rows: [p_1,...,p_5, cost], where p_i >=0, sum p_i =1, cost >=0.
    """
    np.random.seed(42)
    m = len(v)  # number of outcomes = 5

    # Parse logs into arrays for faster indexing:
    contracts = np.array([log['Contract'] for log in content])    # shape (L, m)
    principal_utils = np.array([log['Principal Utility'] for log in content])  # shape (L,)
    agent_actions = np.array([log['Agent Action'] for log in content])  # shape (L,)

    # Extract accepted and rejected indices
    accepted_idx = np.where(agent_actions == 1)[0]
    rejected_idx = np.where(agent_actions == -1)[0]

    if len(accepted_idx) == 0:
        # No accepted contracts => fallback to uniform distribution, zero cost
        uniform_p = np.ones(m) / m
        return np.hstack([uniform_p.reshape(1, -1), np.zeros((1, 1))])

    accepted_contracts = contracts[accepted_idx]

    # Adaptive choice of max number of clusters (agent actions)
    max_K = min(8, max(2, len(accepted_idx)//10))
    if max_K < 2:
        max_K = 2

    attempt = 0
    while attempt < 4:
        # Cluster accepted contracts into max_K clusters
        kmeans = KMeans(n_clusters=max_K, random_state=0, n_init=20).fit(accepted_contracts)
        centers_w = kmeans.cluster_centers_  # shape (max_K, m)

        # Infer p_k for each cluster center w_k by LP: maximize p_k @ w_k s.t p_k≥0, sum p_k=1
        p_candidates = []
        for k in range(max_K):
            w_k = centers_w[k]
            # linprog minimizes, so minimize -p_k@w_k
            res = linprog(c=-w_k,
                          A_eq=[np.ones(m)],
                          b_eq=[1.0],
                          bounds=[(0, 1)]*m,
                          method='highs')
            if res.success and res.x is not None:
                p_candidates.append(res.x)
            else:
                # fallback to 1-hot on max payout outcome
                p = np.zeros(m)
                p[np.argmax(w_k)] = 1.0
                p_candidates.append(p)
        p_candidates = np.array(p_candidates)  # shape (max_K, m)

        # Assign each accepted contract to a cluster
        assigned_clusters = kmeans.predict(accepted_contracts)

        # Construct inequalities for costs c_k (length max_K):
        # Accepted contracts: c_k ≤ p_k @ contract_i  =>  -c_k ≤ - p_k @ contract_i
        accepted_rows = []
        accepted_bounds = []
        for idx_i, cluster_k in zip(accepted_idx, assigned_clusters):
            row = np.zeros(max_K)
            row[cluster_k] = -1
            val = -np.dot(p_candidates[cluster_k], contracts[idx_i])
            accepted_rows.append(row)
            accepted_bounds.append(val)
        accepted_rows = np.array(accepted_rows) if accepted_rows else np.empty((0, max_K))
        accepted_bounds = np.array(accepted_bounds) if accepted_bounds else np.array([])

        # Rejected contracts: for all k, p_k @ contract_j - c_k < 0
        # => c_k > p_k @ contract_j + eps  => -c_k ≤ -(p_k @ contract_j + eps)
        eps = 1e-5
        rejected_rows = []
        rejected_bounds = []
        for idx_j in rejected_idx:
            c_j = contracts[idx_j]
            for k in range(max_K):
                row = np.zeros(max_K)
                row[k] = 1
                rejected_rows.append(-row)
                rejected_bounds.append(-(np.dot(p_candidates[k], c_j) + eps))
        if rejected_rows:
            rejected_rows = np.array(rejected_rows)
            rejected_bounds = np.array(rejected_bounds)
        else:
            rejected_rows = np.empty((0, max_K))
            rejected_bounds = np.array([])

        # Costs non-negative:
        bounds_c = [(0, None)] * max_K

        # Combine all inequalities:
        A_ub = np.vstack([accepted_rows, rejected_rows]) if accepted_rows.size + rejected_rows.size > 0 else np.empty((0, max_K))
        b_ub = np.hstack([accepted_bounds, rejected_bounds]) if accepted_bounds.size + rejected_bounds.size > 0 else np.array([])

        # Objective: minimize sum of costs (for regularization)
        obj = np.ones(max_K)

        feas_res = linprog(c=obj, A_ub=A_ub, b_ub=b_ub, bounds=bounds_c, method='highs')

        if feas_res.success:
            costs = feas_res.x
            # Filter invalid costs (NaN or negative)
            valid_mask = np.isfinite(costs) & (costs >= 0)
            p_candidates = p_candidates[valid_mask]
            costs = costs[valid_mask]
            if len(costs) == 0:
                # fallback uniform
                uniform_p = np.ones(m) / m
                return np.hstack([uniform_p.reshape(1, -1), np.zeros((1, 1))])
            # Normalize p to sum to 1 and nonnegative
            agent_setting = np.empty((len(costs), m + 1))
            for i in range(len(costs)):
                p = p_candidates[i]
                p = np.maximum(p, 0)
                s = p.sum()
                if s <= 0:
                    p = np.ones(m) / m
                else:
                    p = p / s
                agent_setting[i, :m] = p
                agent_setting[i, m] = costs[i]
            return agent_setting

        # If infeasible, try reducing clusters and retry
        max_K -= 1
        if max_K < 1:
            break
        accepted_contracts = accepted_contracts  # no change
        attempt += 1

    # Final fallback if all fails: one agent action with empirical distribution of best outcomes on accepted contracts, zero cost
    outcome_counts = np.zeros(m)
    for idx_i in accepted_idx:
        # Approximate outcome distribution by max payout index in contract
        best_outcome = np.argmax(contracts[idx_i])
        outcome_counts[best_outcome] += 1
    if outcome_counts.sum() > 0:
        p_empirical = outcome_counts / outcome_counts.sum()
    else:
        p_empirical = np.ones(m) / m
    return np.hstack([p_empirical.reshape(1, -1), np.zeros((1, 1))])
```
