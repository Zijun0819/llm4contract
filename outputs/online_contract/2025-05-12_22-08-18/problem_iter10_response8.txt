```python
import numpy as np
from sklearn.cluster import AgglomerativeClustering

def agent_solver_v2(v: np.ndarray, content: list[dict]) -> np.ndarray:
    """
    Infer a valid agent setting (actions = outcome distributions + cost)
    consistent with all historical contract logs under IR and IC constraints.

    Parameters:
        v (np.ndarray): Principal reward vector of length 5.
        content (list[dict]): Each dict contains:
            'Contract' (list of 5 floats),
            'Principal Utility' (float),
            'Agent Action' (1 for accept, -1 for reject).

    Returns:
        np.ndarray: n_actions x 6 array, each row is (p_1,...,p_5,cost)
                    where p_i >= 0, sum p_i = 1, cost >= 0.
    """
    eps = 1e-8
    margin_reject = 1e-5
    m = v.size
    L = len(content)

    # Extract arrays from content
    contracts = np.array([log['Contract'] for log in content], dtype=np.float64)  # (L,5)
    principal_utils = np.array([log['Principal Utility'] for log in content], dtype=np.float64)  # (L,)
    agent_actions = np.array([log['Agent Action'] for log in content], dtype=int)  # (L,)

    accepted_ix = np.where(agent_actions == 1)[0]
    rejected_ix = np.where(agent_actions == -1)[0]

    # Handle no accepted contracts: trivial uniform action with zero cost
    if accepted_ix.size == 0:
        uniform_p = np.ones(m) / m
        return np.hstack([uniform_p.reshape(1, -1), np.zeros((1, 1))])

    accepted_contracts = contracts[accepted_ix]

    # Normalize accepted contracts (sum=1) for clustering, safely handle zero sums
    accepted_sums = accepted_contracts.sum(axis=1, keepdims=True)
    accepted_sums[accepted_sums < eps] = 1.0
    normalized_accepted = accepted_contracts / accepted_sums

    # Adaptive number of clusters: capped, sqrt scale, at least 1
    n_accepted = accepted_ix.size
    n_clusters = min(10, n_accepted, max(1, int(np.sqrt(n_accepted))))

    # Cluster with average linkage; if n_clusters=1, do trivial labeling
    if n_clusters == 1:
        labels = np.zeros(n_accepted, dtype=int)
    else:
        clustering = AgglomerativeClustering(n_clusters=n_clusters, linkage='average')
        labels = clustering.fit_predict(normalized_accepted)

    p_candidates = []
    cost_lower_bounds = []

    # For each cluster, build weighted average action and cost lower bound
    for cid in range(n_clusters):
        mask = (labels == cid)
        cluster_indices = accepted_ix[mask]
        if cluster_indices.size == 0:
            continue

        cluster_contracts = contracts[cluster_indices]
        cluster_principal_utils = principal_utils[cluster_indices]

        # Weights shifted so min utility maps to 1 for numerical stability
        min_util = cluster_principal_utils.min()
        weights = cluster_principal_utils - min_util + 1.0
        weights_sum = weights.sum()
        if weights_sum < eps:
            weights = np.ones_like(weights) / weights.size
        else:
            weights = weights / weights_sum

        avg_w = np.average(cluster_contracts, axis=0, weights=weights)

        # Project avg_w to simplex: clip negatives, then normalize
        p = np.clip(avg_w, 0.0, None)
        s = p.sum()
        if s < eps:
            p = np.ones(m) / m
        else:
            p = p / s

        p_candidates.append(p)

        # Cost lower bound from IR for cluster accepted contracts (cost â‰¤ p @ w_i)
        costs_cluster = np.dot(p, cluster_contracts.T)  # shape (#cluster)
        min_cost = costs_cluster.min()
        cost_lower_bounds.append(min_cost)

    # Fallback if no clusters formed (should not happen)
    if len(p_candidates) == 0:
        uniform_p = np.ones(m) / m
        return np.hstack([uniform_p.reshape(1, -1), np.zeros((1, 1))])

    p_candidates = np.array(p_candidates)  # shape (n_clusters, m)
    cost_lower_bounds = np.array(cost_lower_bounds)  # shape (n_clusters,)

    # Compute rejection constraints: cost > max utility on rejected contracts
    if rejected_ix.size > 0:
        rejected_contracts = contracts[rejected_ix]  # (R, m)
        p_w_rejected = p_candidates @ rejected_contracts.T  # (n_clusters, R)
        cost_reject_min = p_w_rejected.max(axis=1) + margin_reject
    else:
        cost_reject_min = np.zeros_like(cost_lower_bounds)

    # Initialize costs to max of IR lower bound and rejection lower bound, and >=0
    costs = np.maximum(cost_lower_bounds, cost_reject_min)
    costs = np.maximum(costs, 0.0)

    def explains_acceptance(w_i: np.ndarray) -> int | None:
        """
        Returns index of action that rationalizes acceptance of contract w_i
        (agent utility >= -eps), else None.
        """
        utils = np.dot(p_candidates, w_i) - costs
        idxs = np.where(utils >= -eps)[0]
        if idxs.size == 0:
            return None
        return idxs[0]

    # Add new actions for accepted contracts not explained by current actions
    for idx in accepted_ix:
        w_i = contracts[idx]
        if explains_acceptance(w_i) is None:
            # Use contract payments normalized as new action distribution
            p_new = np.clip(w_i, 0.0, None)
            s = p_new.sum()
            if s < eps:
                p_new = np.ones(m) / m
            else:
                p_new = p_new / s
            # Minimal cost so utility exactly zero
            cost_new = np.dot(p_new, w_i)
            p_candidates = np.vstack([p_candidates, p_new])
            costs = np.append(costs, cost_new)

    # After adding new actions, enforce rejection constraints strictly with margin
    if rejected_ix.size > 0:
        rejected_contracts = contracts[rejected_ix]
        p_w_rejected = p_candidates @ rejected_contracts.T  # (n_actions, R)
        for a in range(p_candidates.shape[0]):
            max_rej_util = p_w_rejected[a].max()
            if costs[a] <= max_rej_util + eps:
                costs[a] = max_rej_util + margin_reject

    # Robustly normalize probabilities again
    p_candidates = np.clip(p_candidates, 0.0, None)
    row_sums = p_candidates.sum(axis=1, keepdims=True)
    zero_sum_mask = row_sums < eps
    row_sums[zero_sum_mask] = 1.0
    p_candidates /= row_sums

    costs = np.maximum(costs, 0.0)

    agent_setting = np.hstack([p_candidates, costs[:, None]])
    return agent_setting
```
