```python
import numpy as np
from sklearn.cluster import AgglomerativeClustering

def agent_solver_v2(v: np.ndarray, content: list[dict]) -> np.ndarray:
    """
    Infer a valid agent setting (actions = distributions over outcomes + cost)
    consistent with historical contract logs.

    Params:
        v (np.ndarray): Principal's value vector (length 5)
        content (list[dict]): each dict has keys: 'Contract' (list of 5),
                              'Principal Utility' (float),
                              'Agent Action' (1 or -1)
    Returns:
        np.ndarray: n_actions x 6 (5 probabilities + 1 cost)
    """
    m_outcomes = v.size
    L = len(content)

    # Prepare arrays for easier manipulation
    contracts = np.array([log['Contract'] for log in content])  # shape (L,5)
    ag_actions = np.array([log['Agent Action'] for log in content])  # shape (L,)
    p_util = np.array([log['Principal Utility'] for log in content])  # shape (L,)

    # Accepted and rejected indices
    accepted_ix = np.where(ag_actions == 1)[0]
    rejected_ix = np.where(ag_actions == -1)[0]

    # If no accepted contracts, return uniform trivial agent setting with zero cost
    if len(accepted_ix) == 0:
        uniform_p = np.ones(m_outcomes) / m_outcomes
        return np.hstack([uniform_p.reshape(1, -1), np.array([[0.0]])])

    # Cluster accepted contracts to identify distinct agent actions
    accepted_w = contracts[accepted_ix]

    # Normalize contracts to probability simplex for clustering (shape-only)
    norm_w = accepted_w / (accepted_w.sum(axis=1, keepdims=True) + 1e-12)

    # Choose number of clusters adaptively: max 10 or sqrt of accepted samples, at least 1
    n_max_actions = max(1, min(10, int(np.sqrt(len(accepted_ix)))))
    clustering = AgglomerativeClustering(n_clusters=n_max_actions, linkage="average")
    labels = clustering.fit_predict(norm_w)

    p_candidates = []
    costs_lower_bound = []

    # For each cluster: find representative distribution and minimal cost lower bound
    for c in range(n_max_actions):
        cluster_ix = accepted_ix[labels == c]
        if cluster_ix.size == 0:
            continue
        cluster_w = contracts[cluster_ix]

        # Compute a robust prototype distribution:
        # Instead of simple mean, use weighted average by principal utility (positive)
        weights = p_util[cluster_ix] - p_util[cluster_ix].min() + 1e-3  # shift to positive
        weights /= weights.sum()

        avg_w = np.average(cluster_w, axis=0, weights=weights)
        avg_w = np.maximum(avg_w, 0)

        # Project avg_w onto the probability simplex to get p candidate
        # Using Euclidean projection onto simplex
        u = np.sort(avg_w)[::-1]
        cssv = np.cumsum(u)
        rho = np.nonzero(u * np.arange(1, m_outcomes+1) > (cssv - 1))[0][-1]
        theta = (cssv[rho] - 1) / (rho + 1)
        p = np.maximum(avg_w - theta, 0)

        # Ensure numerical stability and sum=1
        if p.sum() <= 1e-12:
            p = np.ones(m_outcomes) / m_outcomes
        else:
            p /= p.sum()

        p_candidates.append(p)

        # Estimate minimal cost to rationalize acceptance in cluster
        # cost <= p @ contract for accepted contracts since utility >=0
        costs = [p @ contracts[i] for i in cluster_ix]
        min_cost = min(costs) - 1e-7  # slight margin below minimal expected utility
        costs_lower_bound.append(min_cost)

    p_candidates = np.array(p_candidates)
    costs_lower_bound = np.array(costs_lower_bound)

    # Handle rejected contracts constraints:
    # For each rejected contract r and any action a: p_a @ w_r - cost_a < 0
    # => cost_a > p_a @ w_r, so cost_a > max_r (p_a @ w_r)

    if rejected_ix.size > 0:
        reject_contracts = contracts[rejected_ix]  # (#rej,5)
        p_w_rej = p_candidates @ reject_contracts.T  # (n_actions, #rej)
        c_rej_min = p_w_rej.max(axis=1) + 1e-6  # tiny margin for strict inequality
    else:
        c_rej_min = np.zeros(len(p_candidates))

    # Final costs must satisfy both acceptance and rejection constraints
    costs = np.maximum(costs_lower_bound, c_rej_min)
    costs = np.maximum(costs, 0)  # enforce non-negativity

    # Validate accepted contracts can be explained by some action
    def has_valid_action(w_i):
        for a, (p, c) in enumerate(zip(p_candidates, costs)):
            if p @ w_i - c >= -1e-8:
                return a
        return None

    # If some accepted contract cannot be explained, add a new action for it
    for i in accepted_ix:
        w_i = contracts[i]
        if has_valid_action(w_i) is None:
            # Create new action with p proportional to contract normalized
            p_new = w_i.copy()
            p_new = np.maximum(p_new, 0)
            if p_new.sum() < 1e-12:
                p_new = np.ones(m_outcomes) / m_outcomes
            else:
                p_new /= p_new.sum()

            c_new = p_new @ w_i - 1e-8  # slightly below expected utility for acceptance
            p_candidates = np.vstack([p_candidates, p_new])
            costs = np.append(costs, c_new if c_new >= 0 else 0.0)

    # Re-apply rejection constraints for updated actions
    if rejected_ix.size > 0:
        reject_contracts = contracts[rejected_ix]
        p_w_rej = p_candidates @ reject_contracts.T
        for a in range(len(p_candidates)):
            max_rej_util = p_w_rej[a].max()
            if costs[a] <= max_rej_util:
                costs[a] = max_rej_util + 1e-5  # margin for strict rejection

    # Final normalization of p_candidates to sum to 1 with clipping
    p_candidates = np.clip(p_candidates, 0, None)
    p_sums = p_candidates.sum(axis=1, keepdims=True)
    p_sums[p_sums < 1e-12] = 1.0  # avoid division by zero
    p_candidates /= p_sums

    # Assemble final agent setting matrix (n_actions x 6)
    agent_setting = np.hstack([p_candidates, costs[:, None]])

    return agent_setting
```
