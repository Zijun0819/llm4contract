```python
import numpy as np
import pandas as pd
from scipy.optimize import linprog
from sklearn.cluster import AgglomerativeClustering


def agent_solver_v2(v: np.ndarray, content: list[dict]) -> np.ndarray:
    m = len(v)
    L = len(content)

    contracts = np.array([log['Contract'] for log in content])  # shape (L, m)
    agent_actions = np.array([log['Agent Action'] for log in content])  # shape (L,)
    principal_utils = np.array([log['Principal Utility'] for log in content])

    # --- Step 1: Identify distinct (or approx distinct) accepted contracts by clustering ---
    # Use only accepted contracts to find representative outcome distributions
    accepted_idx = np.where(agent_actions == 1)[0]
    if len(accepted_idx) == 0:
        raise ValueError("No accepted contracts to infer from.")

    accepted_contracts = contracts[accepted_idx]

    # Cluster contracts in payment vector space to reduce complexity
    # Use hierarchical clustering with distance threshold to adaptively select cluster number
    cluster_model = AgglomerativeClustering(distance_threshold=0.5, n_clusters=None)
    cluster_labels = cluster_model.fit_predict(accepted_contracts)

    # Each cluster corresponds to an action candidate
    unique_labels = np.unique(cluster_labels)
    n_actions = len(unique_labels)

    # --- Step 2: For each action candidate, infer an outcome distribution p and cost c ---

    # Prepare output matrix: rows = actions, cols= [p_1,..,p_5, c]
    agent_setting = np.zeros((n_actions, m + 1))

    # Construct convex LP to find p and c per cluster (while ensuring all logs conform)

    for i, cl in enumerate(unique_labels):
        inds = accepted_idx[cluster_labels == cl]  # indices within content of this cluster

        # Use all contracts in this cluster to find feasible (p,c)
        # Variables: p (m dim probs), c (scalar)
        # Constraints from all accepted logs in cluster:
        #   expected utility under contract >= 0   => p @ w_i - c >= 0 for all i in inds
        # And sum(p) = 1 , p_j >=0 ; c >=0

        # We solve LP to find a p minimizing maximum violation of constraints,
        # here reformulated as feasibility problem by introducing slack variables if needed

        # Setup LP:
        # Let x = [p_1,...,p_m, c]
        # Constraints:
        #   sum(p) = 1
        #   p_j >=0, c >=0
        #   For all i in inds: p @ w_i - c >= 0

        # We'll solve feasibility LP with objective to minimize sum of slack (to ensure feasibility)

        # Using a small slack variable s_i >=0 for each accepted contract constraint,
        # minimize sum s_i, subject to constraints:

        # So variables: [p_1 to p_m, c, s_1,...,s_k] where k = len(inds)

        num_slack = len(inds)
        num_vars = m + 1 + num_slack  # p (m), c(1), s(k)

        c_obj = np.zeros(num_vars)
        c_obj[m + 1:] = 1.0  # minimize sum of slacks

        # Equality: sum(p) = 1  --> A_eq x = b_eq
        A_eq = np.zeros((1, num_vars))
        A_eq[0, 0:m] = 1
        b_eq = np.array([1])

        # Inequalities: 
        # p_j >=0  => -p_j <= 0
        # c >=0    => -c <=0
        # s_i >=0  => -s_i <=0

        # For accepted contract constraints: p @ w_i - c + s_i >= 0 => -p @ w_i + c - s_i <= 0

        A_ub = []
        b_ub = []

        # p_j >=0:
        for j in range(m):
            row = np.zeros(num_vars)
            row[j] = -1
            A_ub.append(row)
            b_ub.append(0)

        # c>=0:
        row = np.zeros(num_vars)
        row[m] = -1
        A_ub.append(row)
        b_ub.append(0)

        # s_i>=0
        for si in range(num_slack):
            row = np.zeros(num_vars)
            row[m + 1 + si] = -1
            A_ub.append(row)
            b_ub.append(0)

        # accepted contract constraints:
        for idx_i, log_i in enumerate(inds):
            w_i = contracts[log_i]
            row = np.zeros(num_vars)
            row[0:m] = -w_i  # -p_j w_ij
            row[m] = 1       # + c
            row[m + 1 + idx_i] = -1  # - s_i
            A_ub.append(row)
            b_ub.append(0)

        A_ub = np.array(A_ub)
        b_ub = np.array(b_ub)

        # Solve LP
        res = linprog(c=c_obj, A_ub=A_ub, b_ub=b_ub, A_eq=A_eq, b_eq=b_eq, bounds=(None,None), method='highs')

        if not res.success:
            # If infeasible, fallback: uniform p and cost zero
            p = np.ones(m) / m
            c = 0.
        else:
            p = res.x[0:m]
            c = res.x[m]
            # Project p to simplex (small negative entries) just in case due to numerics:
            p = np.clip(p, 0, None)
            p = p / np.sum(p) if np.sum(p) > 0 else np.ones(m)/m
            c = max(c, 0)

        agent_setting[i, 0:m] = p
        agent_setting[i, m] = c

    # --- Step 3: Validate inferred actions with rejection logs ---
    # For each rejection log (agent_action == -1), the maximum expected payoff from any action must be < 0

    rejection_idx = np.where(agent_actions == -1)[0]
    if len(rejection_idx) > 0:
        rej_contracts = contracts[rejection_idx]  # shape (R, m)
        # Expected values for each action and each rejected contract
        # expected_util[a,r] = p_a @ w_r - c_a
        expected_util = (agent_setting[:, 0:m] @ rej_contracts.T) - agent_setting[:, m][:, None]  # (n_actions, R)

        # Check feasibility and try tightening costs if violated (to ensure IR-IC)
        viol_mask = expected_util >= 0  # action a could induce acceptance in rejection log r, invalid

        if np.any(viol_mask):
            # Increase costs minimally to satisfy rejection constraints
            # For each violating entry: cost_a >= p_a @ w_r + epsilon

            epsilon = 1e-6
            # We solve an LP to find minimal cost increases to fix rejection

            # Variables: delta_c[a] >=0 (cost increments)
            n_a = n_actions
            c_obj = np.ones(n_a)  # minimize sum of increments

            # Constraints: for each violation:
            # c_a + delta_c[a] >= p_a @ w_r + epsilon
            # delta_c >=0

            A_ub = np.zeros((0, n_a))
            b_ub = np.zeros(0)

            A_ub_rows = []
            b_ub_vals = []
            for a in range(n_a):
                for r in range(len(rejection_idx)):
                    if viol_mask[a, r]:
                        row = np.zeros(n_a)
                        row[a] = -1  # -delta_c[a] <= - (p_a @ w_r - c_a + epsilon)
                        A_ub_rows.append(row)
                        bound = -(agent_setting[a, 0:m] @ rej_contracts[r] - agent_setting[a, m] + epsilon)
                        b_ub_vals.append(bound)
            if len(A_ub_rows) > 0:
                A_ub = np.vstack(A_ub_rows)
                b_ub = np.array(b_ub_vals)
                bounds = [(0, None)] * n_a
                res_cost = linprog(c=c_obj, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')
                if res_cost.success:
                    agent_setting[:, m] += res_cost.x
                else:
                    # fallback: add maximal margins from rejection contracts
                    for a in range(n_a):
                        for r in range(len(rejection_idx)):
                            p_w = agent_setting[a, 0:m] @ rej_contracts[r]
                            margin = p_w - agent_setting[a, m] + epsilon
                            if margin > 0:
                                agent_setting[a, m] += margin

    return agent_setting
```
