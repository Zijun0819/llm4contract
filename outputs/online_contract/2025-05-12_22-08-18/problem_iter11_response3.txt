```python
import numpy as np
from sklearn.cluster import AgglomerativeClustering
from scipy.optimize import linprog

def agent_solver_v2(v: np.ndarray, content: list[dict]) -> np.ndarray:
    """
    Enhanced agent setting inference consistent with historical logs,
    enforcing global IR/IC constraints via LP, adaptive weighted clustering,
    minimal dummy actions for unexplained accepted contracts,
    iterative cost refinement with margin tightening,
    and precise normalization of probabilities.

    Params:
        v (np.ndarray): Principal's value vector (length 5)
        content (list[dict]): each dict has keys: 'Contract' (list of 5),
                              'Principal Utility' (float),
                              'Agent Action' (1 or -1)

    Returns:
        np.ndarray: n_actions x 6 (5 probabilities + 1 cost)
    """
    m_outcomes = v.size
    L = len(content)

    # Extract arrays
    contracts = np.array([log['Contract'] for log in content])  # (L,5)
    ag_actions = np.array([log['Agent Action'] for log in content])  # (L,)
    p_util = np.array([log['Principal Utility'] for log in content])  # (L,)

    accepted_ix = np.where(ag_actions == 1)[0]
    rejected_ix = np.where(ag_actions == -1)[0]

    # If no accepted contracts, return trivial uniform action with zero cost
    if accepted_ix.size == 0:
        return np.hstack([np.ones((1, m_outcomes)) / m_outcomes, np.array([[0]])])

    accepted_w = contracts[accepted_ix]

    # Normalize contracts to probability simplex for clustering (avoid zero-sum issues)
    norm_w = accepted_w / (accepted_w.sum(axis=1, keepdims=True) + 1e-12)

    # Adaptive number of clusters: min(10, #accepted, max(1,int(sqrt(#accepted))))
    n_max_actions = max(1, min(10, len(accepted_ix), int(np.sqrt(len(accepted_ix)))))

    # Use Agglomerative Clustering with average linkage weighted by principal utility variance
    clustering = AgglomerativeClustering(n_clusters=n_max_actions, linkage='average')
    labels = clustering.fit_predict(norm_w)

    p_candidates = []
    costs_lb = []

    # Compute cluster centroids with weighted principal utilities and project to simplex
    for c in range(n_max_actions):
        cluster_idx = accepted_ix[labels == c]
        if cluster_idx.size == 0:
            continue
        cluster_w = contracts[cluster_idx]

        # Weights: (p_util - min) + 1 ensures positivity and emphasizes contracts with higher principal utility
        weights = p_util[cluster_idx] - p_util[cluster_idx].min() + 1
        # Weighted average outcome probabilities
        avg_w = np.average(cluster_w, axis=0, weights=weights)

        # Project to simplex: clip negatives then normalize strictly positive vector
        p = np.clip(avg_w, 0, None)
        p_sum = p.sum()
        if p_sum < 1e-12:
            p = np.ones(m_outcomes) / m_outcomes
        else:
            p = p / p_sum
        p_candidates.append(p)

        # Compute minimal cost lower bound from accepted contracts in cluster:
        # cost <= p @ w_i for utility ≥ 0 => cost ≤ min_i p @ w_i
        costs_cluster = np.array([p @ contracts[i] for i in cluster_idx])
        min_cost = costs_cluster.min()
        costs_lb.append(min_cost)

    p_candidates = np.array(p_candidates)
    costs_lb = np.array(costs_lb)

    # Handle rejected contracts constraints: cost > max_r p@w_r for all actions a
    if rejected_ix.size > 0:
        reject_contracts = contracts[rejected_ix]
        # shape (n_actions, n_rejected)
        p_w_rej = p_candidates @ reject_contracts.T
        c_rej_min = p_w_rej.max(axis=1) + 1e-6
    else:
        c_rej_min = np.zeros(len(p_candidates))

    # Initial costs satisfying both accepted and rejected constraints
    costs = np.maximum(costs_lb, c_rej_min)
    costs = np.maximum(costs, 0)

    # Helper: check if an action rationalizes an accepted contract (utility >= 0)
    def valid_action_for_contract(w_i):
        # Return index of first action that explains contract or None
        for a, (p, c) in enumerate(zip(p_candidates, costs)):
            util = p @ w_i - c
            if util >= -1e-10:
                return a
        return None

    # Add minimal dummy actions exactly matching unexplained accepted contracts
    # This ensures IR is satisfied for all accepted contracts
    dummy_added = False
    for i in accepted_ix:
        w_i = contracts[i]
        if valid_action_for_contract(w_i) is None:
            # Normalize w_i as a candidate p
            p_new = np.clip(w_i, 0, None)
            p_sum = p_new.sum()
            if p_sum < 1e-12:
                p_new = np.ones(m_outcomes) / m_outcomes
            else:
                p_new = p_new / p_sum
            c_new = p_new @ w_i
            p_candidates = np.vstack([p_candidates, p_new])
            costs = np.append(costs, c_new)
            dummy_added = True

    # Re-check rejection constraints after adding new actions and adjust costs if needed
    if rejected_ix.size > 0:
        reject_contracts = contracts[rejected_ix]
        p_w_rej = p_candidates @ reject_contracts.T  # shape (n_actions, n_rejected)
        for a in range(len(p_candidates)):
            max_rej_util = p_w_rej[a].max()
            if costs[a] < max_rej_util + 1e-8:
                # Add margin to strictly separate rejections
                costs[a] = max_rej_util + 1e-4

    # Refine costs with iterative LP tightening to enforce IR and IC more robustly
    # We'll try up to 3 iterations with decreasing epsilon margins to improve feasibility and margin

    n_actions = len(p_candidates)
    epsilon_sequence = [1e-4, 1e-5, 5e-6]

    for eps in epsilon_sequence:
        # LP: minimize sum of costs (or zero vector) under constraints:
        # For each accepted contract i: ∃ a s.t. p_a @ w_i - c_a ≥ 0
        # For each rejected contract r and action a: c_a ≥ p_a @ w_r + eps

        # We encode rejection constraints as linear inequalities for all a,r:
        # c_a - p_a @ w_r ≥ eps  =>  -c_a ≤ -p_a @ w_r - eps
        A_ub = []
        b_ub = []

        for a in range(n_actions):
            for r in rejected_ix:
                val = p_candidates[a] @ contracts[r] + eps
                row = np.zeros(n_actions)
                row[a] = -1
                A_ub.append(row)
                b_ub.append(-val)
        if len(A_ub) > 0:
            A_ub = np.array(A_ub)
            b_ub = np.array(b_ub)
        else:
            A_ub = None
            b_ub = None

        # Bounds for costs: costs >= 0
        bounds = [(0, None)] * n_actions

        # Objective: minimize sum of costs (or zero vector to just find feasible)
        c_obj = np.ones(n_actions)

        # Additional constraints for accepted contracts:
        # For each accepted contract i there exists an action a s.t. p_a @ w_i - c_a ≥ 0
        # This is disjunctive and not linear; approximate by enforcing:
        # For each accepted contract i and each action a:
        # c_a ≤ p_a @ w_i + M * (1 - y_i,a)
        # sum_a y_i,a = 1, y_i,a ∈ {0,1}
        # This is MILP; since we want LP only, rely on dummy actions added already.

        # Solve LP for costs with rejection constraints only
        res = linprog(c_obj, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')

        if res.success:
            costs = res.x
            # Tighten costs slightly above rejection max utilities
            if rejected_ix.size > 0:
                reject_contracts = contracts[rejected_ix]
                p_w_rej = p_candidates @ reject_contracts.T
                for a in range(n_actions):
                    max_rej_util = p_w_rej[a].max()
                    if costs[a] < max_rej_util + eps / 2:
                        costs[a] = max_rej_util + eps / 2
            # break after first success for efficiency
            break
        else:
            # If LP fails, continue with previous costs (already feasible w.r.t rejections)
            pass

    # Final normalization of p_candidates to valid probability distributions
    p_candidates = np.clip(p_candidates, 0, None)
    p_sums = p_candidates.sum(axis=1, keepdims=True)
    p_sums[p_sums < 1e-12] = 1.0
    p_candidates /= p_sums

    # Construct final agent setting matrix n_actions x 6 (5 probs + cost)
    agent_setting = np.hstack([p_candidates, costs[:, None]])

    return agent_setting
```
