```python
import numpy as np
import pandas as pd
from scipy.optimize import linprog, lsq_linear
from sklearn.cluster import KMeans


def agent_solver_v2(v: np.ndarray, content: list[dict]) -> np.ndarray:
    """
    Infer a valid agent setting (actions defined by outcome distributions and cost)
    consistent with historical contract logs under IR and IC.

    Args:
        v: Principal reward vector (length 5).
        content: A list of dicts each with keys:
            'Contract': list of 5 payments,
            'Principal Utility': float,
            'Agent Action': int (1 for accept, -1 for reject).
    
    Returns:
        np.ndarray of shape (n_actions, 6), each row:
        [p_1, p_2, p_3, p_4, p_5, cost], where p_i sum to 1 and cost >= 0.
    """

    # Parameters
    m_outcomes = v.size
    logs = pd.DataFrame(content)
    L = len(logs)

    # --- Step 1: Extract contracts based on agent action ---
    accept_mask = logs['Agent Action'] == 1
    reject_mask = logs['Agent Action'] == -1

    contracts_accept = np.vstack(logs.loc[accept_mask, 'Contract'].values)   # shape: n_accept x 5
    utils_accept = logs.loc[accept_mask, 'Principal Utility'].values         # shape: n_accept

    contracts_reject = np.vstack(logs.loc[reject_mask, 'Contract'].values) if reject_mask.any() else np.empty((0, m_outcomes))

    n_accept = contracts_accept.shape[0]
    n_reject = contracts_reject.shape[0]

    # --- Step 2: Infer candidate outcome distributions p for accepted contracts ---
    # We formulate: For accepted contract i, find p_i s.t:
    #   p_i @ wage_i - cost >= 0 (agent utility >= 0, cost unknown yet)
    #   p_i sums to 1 and p_i >= 0
    # We only know wage_i and principal utility = p_i@(v - wage_i)
    # From principal utility, we get: p_i*v - cost = principal utility + wage_i@p_i - cost
    # Since cost and agent utility unknown, we approximate p_i from wage_i alone by least squares on accepted contracts.

    # Because cost unknown, we just find p_i ~ (distribution) matching contracts.
    # Here, we aim to find "typical" p's by clustering payment equivalences.
    # Instead, we invert the problem approximately:
    # For each accepted contract i, we try to find p_i s.t:
    # sum p_i = 1
    # p_i >= 0
    # p_i @ wage_i ~= max agent utility

    # Initial guess: approximate outcome distributions by normalizing payments:
    # This is a heuristic just for initialization:
    p_candidates = []
    for w in contracts_accept:
        denom = np.sum(w) + 1e-8
        # Normalize to make a distribution for outcome selection heuristically,
        # Because high payment means likely outcome presumably for agent utility.
        p_ = np.clip(w, 0, None)
        sum_p_ = np.sum(p_)
        if sum_p_ < 1e-8:
            p_ = np.repeat(1.0 / m_outcomes, m_outcomes)
        else:
            p_ = p_ / sum_p_
        p_candidates.append(p_)
    p_candidates = np.array(p_candidates)

    # --- Step 3: Cluster inferred candidate p's to find n_actions prototype actions ---
    # Adaptive n_actions by elbow or fixed max 10
    max_actions = min(10, max(2, n_accept // 10))
    try:
        kmeans = KMeans(n_clusters=max_actions, random_state=42, n_init=20).fit(p_candidates)
        p_centroids = kmeans.cluster_centers_
    except Exception:
        # fallback single cluster equals average
        p_centroids = np.mean(p_candidates, axis=0, keepdims=True)

    n_actions = p_centroids.shape[0]

    # --- Step 4: For each action, infer cost c by linear optimization ---
    # Constraints come from acceptance and rejection logs:
    # Acceptance IR: For a contract w assigned to action a,
    #   p_a @ w - c_a >= 0 (agent accepts -> utility >= 0 => cost <= p_a @ w)
    # Rejection IC: For a rejected contract w,
    #   max_a(p_a @ w - c_a) < 0 (agent rejects all contracts, no action better than 0 utility)
    # We will minimize costs c_a subject to those constraints:
    # IR constraints for accepted contracts assigned to action a: c_a <= p_a @ w
    # IC constraints for rejected contracts: p_a @ w - c_a < 0 for all a and all rejected contracts

    # --- Step 4.1: Assign each accepted contract to best action ---
    assigns = np.zeros(n_accept, dtype=int)
    for i, w in enumerate(contracts_accept):
        # For each p centroid action, compute agent utility baseline ignoring cost (agent utility = p_a@w - c_a unknown)
        # Assume c_a>=0; assign to action maximizing p_a @ w (proxy for max possible utility).
        util_actions = p_centroids @ w
        assigns[i] = np.argmax(util_actions)

    # --- Step 4.2: Set up LP to find costs c = [c_0, ..., c_n-1]
    # Variables: costs c_a >= 0
    # Objective: minimize sum of costs c (to avoid trivial large values)
    # Constraints:
    # - For each accepted contract i assigned to a: c_a <= p_a @ w_i
    #   <=> -c_a <= -p_a @ w_i
    # - For each rejected contract j and each action a:
    #   p_a @ w_j - c_a < 0  =>  c_a > p_a @ w_j
    #   Relax strict < 0 to <= -epsilon with small epsilon to avoid trivial
    #   c_a >= p_a @ w_j + epsilon
    eps = 1e-5

    # Variables order: c_0 ... c_{n_actions - 1}
    n_vars = n_actions

    # Objective: min  sum c_a
    c_obj = np.ones(n_vars)

    # Constraints lists: A_ub c <= b_ub
    A_ub = []
    b_ub = []

    # Accepted contracts IR constraints: c_a <= p_a @ w_i
    for i, a in enumerate(assigns):
        rhs = np.dot(p_centroids[a], contracts_accept[i])
        row = np.zeros(n_vars)
        row[a] = 1
        # c_a <= rhs =>  c_a - rhs <= 0  => row c minus rhs
        A_ub.append(row)
        b_ub.append(rhs)

    # For rejection, we require for each rejected contract w_j and each action a:
    # p_a @ w_j - c_a < 0  => c_a > p_a @ w_j  => -c_a < -p_a@w_j  => c_a >= p_a@w_j + eps
    # Since linprog supports c_a >= 0 bounds only,
    # make these inequality constraints: -c_a <= -p_a@w_j - eps
    for w_j in contracts_reject:
        for a in range(n_actions):
            rhs = np.dot(p_centroids[a], w_j) + eps
            row = np.zeros(n_vars)
            row[a] = -1  # -c_a
            A_ub.append(row)
            b_ub.append(-rhs)

    A_ub = np.array(A_ub) if A_ub else None
    b_ub = np.array(b_ub) if b_ub else None

    bounds = [(0, None) for _ in range(n_vars)]

    # Solve LP
    res = linprog(
        c=c_obj,
        A_ub=A_ub,
        b_ub=b_ub,
        bounds=bounds,
        method="highs",
        options={'presolve': True}
    )

    if not res.success:
        # LP failed, relax reject constraints by removing eps or ignoring them
        A_ub_relaxed = A_ub[:len(assigns)] if A_ub is not None else None
        b_ub_relaxed = b_ub[:len(assigns)] if b_ub is not None else None
        res = linprog(
            c=c_obj,
            A_ub=A_ub_relaxed,
            b_ub=b_ub_relaxed,
            bounds=bounds,
            method="highs"
        )
        if not res.success:
            # fail safe: costs zero
            costs = np.zeros(n_vars)
        else:
            costs = np.clip(res.x, 0, None)
    else:
        costs = np.clip(res.x, 0, None)

    # --- Step 5: Postprocess costs: penalize zero-cost actions to min positive epsilon if necessary ---
    min_cost_positive = 1e-8
    costs = np.where(costs < min_cost_positive, 0.0, costs)  # allow zero cost if valid

    # --- Step 6: Ensure probabilities sum to 1 and non-negative ---
    p_centroids = np.clip(p_centroids, 0, None)
    p_centroids = p_centroids / np.maximum(p_centroids.sum(axis=1, keepdims=True), 1e-12)

    # --- Step 7: Compose agent setting matrix: (n_actions, 6) ---
    # Each row: 5 outcome probabilities + 1 cost
    agent_setting = np.hstack([p_centroids, costs[:, None]])

    return agent_setting
```
