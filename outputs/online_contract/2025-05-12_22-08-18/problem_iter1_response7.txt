```python
import numpy as np
import pandas as pd
from scipy.optimize import linprog
from sklearn.cluster import AgglomerativeClustering


def agent_solver_v2(v: np.ndarray, content: pd.DataFrame) -> np.ndarray:
    """
    Infer an agent setting (actions with outcome distributions and costs)
    consistent with historical contract interactions between principal and agent.
    
    Args:
        v: 1D array of principal's rewards for 5 outcomes.
        content: pd.DataFrame with columns 'Contract', 'Principal Utility', 'Agent Action'.

    Returns:
        agent_setting: ndarray shape (n_actions, 6),
            first 5 columns = outcome distributions (sum to 1),
            last column = agent's cost for that action (non-negative).
    """
    m = len(v)  # number of outcomes, expected 5
    logs = content.copy()
    L = len(logs)

    # Parse contracts and utilities
    contracts = np.array(logs['Contract'].to_list())  # shape (L,5)
    utilities = logs['Principal Utility'].to_numpy()  # shape (L,)
    actions = logs['Agent Action'].to_numpy()         # shape (L,)

    # 1) Separate accepted and rejected logs
    accepted_idx = (actions == 1)
    rejected_idx = (actions == -1)

    # Constraint info for agent expected utility (accept if >=0, else reject)
    # Agent utility: p \cdot w - c >= 0 accepted actions
    # Agent utility: p \cdot w - c < 0 rejected actions

    # 2) Infer candidate agent behavior clusters from accepted logs:
    # We want to find a small set of distributions p (actions),
    # each p sums to 1, p>=0, explaining accepted contracts via some cost c.
    A_contracts = contracts[accepted_idx]
    A_utilities = utilities[accepted_idx]
    n_accept = A_contracts.shape[0]

    # For each accepted contract, estimated agent utility = p @ w - c >= 0
    # We do not know p, but we hypothesize #actions clusters.
    # Because accepted acts represent agent choosing an action,
    # cluster accepted contracts by payment profile relative to v.

    # Embedding accepted contracts normalized by principal utility + small epsilon
    # to capture shape patterns and avoid bias just on amounts.
    eps = 1e-8
    reshape_input = (A_contracts / (A_utilities[:, None] + eps))

    # Use Agglomerative Clustering with a conservative max number of clusters
    max_clusters = min(8, max(2, n_accept // 10))
    if n_accept < max_clusters:
        max_clusters = n_accept

    clustering = AgglomerativeClustering(n_clusters=max_clusters).fit(reshape_input)
    labels = clustering.labels_

    # Initialize agent actions p and c: for each cluster, find avg p and estimate cost
    n_actions = max(labels) + 1

    p_candidates = []
    c_candidates = []

    def solve_p_given_cost(w_matrix, cost):
        # Solve for p ≥0 sum to 1, s.t. p @ w_i ≥ cost for each contract i (agent utility≥0)
        # Minimize ||p||^2 roughly -> here just feasibility, use linprog with small objective.
        m = w_matrix.shape[1]
        n = w_matrix.shape[0]

        # linprog: minimize 0, subject to A_ub, bounds, A_eq sum(p)=1
        c_obj = np.zeros(m)
        A_ub = -(w_matrix)  # want p @ w_i >= cost -> -p@w_i ≤ -cost = -constant
        b_ub = -np.full(n, cost)
        A_eq = np.ones((1, m))
        b_eq = np.array([1.0])
        bounds = [(0, 1) for _ in range(m)]
        res = linprog(c_obj, A_ub=A_ub, b_ub=b_ub, A_eq=A_eq, b_eq=b_eq, bounds=bounds, method='highs')
        if res.success:
            return res.x
        else:
            # fallback uniform distribution
            return np.ones(m) / m

    for a in range(n_actions):
        idx_a = np.where(labels == a)[0]
        w_a = A_contracts[idx_a]  # subset contracts for cluster
        u_a = A_utilities[idx_a]

        # Assume cost = min agent utility among contracts: p @ w - c >= 0 => c ≤ min p @ w
        # We initially approximate cost as minimal agent utility for an estimated p to be found.

        # Step 1: estimate cost = max over contracts of minimal p @ w
        # For initial guess, use centroid of contracts as p temporarily
        w_centroid = np.mean(w_a, axis=0)
        p_init = w_centroid / (np.sum(w_centroid) + eps)
        p_init = np.clip(p_init, 0, None)
        p_init /= (p_init.sum() + eps)
        cost_init = np.min(w_a @ p_init)  # minimal agent utility for centroid p
        cost_init = float(max(cost_init, 0))

        # Step 2: refine p by solving feasible p for cost_init
        p_refined = solve_p_given_cost(w_a, cost_init)

        # Step 3: refine cost by minimal p_refined @ w among cluster contracts
        cost_refined = np.min(w_a @ p_refined)
        cost_refined = float(max(cost_refined, 0))

        p_candidates.append(p_refined)
        c_candidates.append(cost_refined)

    p_candidates = np.array(p_candidates)  # shape (n_actions,5)
    c_candidates = np.array(c_candidates)  # shape (n_actions,)

    # 3) Enforce IR and IC constraints for all contracts (including rejected)
    # Rejected actions: agent utility must be < 0 for all p,c
    R_contracts = contracts[rejected_idx]

    # Adjust costs upward if any rejects violate utility <0
    for _ in range(3):  # 3 refinement rounds
        violation = np.zeros(n_actions, dtype=bool)
        for a in range(n_actions):
            if R_contracts.size > 0:
                utils_rej = R_contracts @ p_candidates[a] - c_candidates[a]
                if np.any(utils_rej >= -1e-8):
                    violation[a] = True
        if not violation.any():
            break
        # increase cost for violating actions to push utility < 0 on rejects
        for a in np.where(violation)[0]:
            c_candidates[a] += 0.05  # small step up

        # Also ensure cost >=0
        c_candidates = np.clip(c_candidates, 0, None)

    # 4) Normalize p_candidates (fix any numerical issues)
    p_candidates = np.clip(p_candidates, 0, None)
    p_candidates /= np.maximum(p_candidates.sum(axis=1, keepdims=True), 1e-8)

    # 5) Final verification: for accepted contracts, some action should satisfy agent utility ≥ 0 & IC
    for i in range(L):
        w_i = contracts[i]
        a_i = actions[i]
        util_candidate = p_candidates @ w_i - c_candidates
        if a_i == 1:
            # must have action with utility ≥ 0 (IR)
            if not np.any(util_candidate >= -1e-8):
                # If not, reduce costs minimal to fix
                min_idx = np.argmax(util_candidate)
                c_candidates[min_idx] = w_i @ p_candidates[min_idx]
        else:
            # agent rejected, all utilities must be <0
            if np.any(util_candidate >= -1e-8):
                max_idx = np.argmax(util_candidate)
                c_candidates[max_idx] = w_i @ p_candidates[max_idx] + 0.05

    c_candidates = np.clip(c_candidates, 0, None)

    # 6) Return agent setting: concatenation p and cost
    agent_setting = np.hstack([p_candidates, c_candidates[:, None]])
    return agent_setting
```
