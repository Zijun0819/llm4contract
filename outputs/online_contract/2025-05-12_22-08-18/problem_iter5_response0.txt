```python
import numpy as np
from sklearn.cluster import AgglomerativeClustering

def agent_solver(v: np.ndarray, content: list[dict]) -> np.ndarray:
    """
    Infer a valid agent setting (actions = distributions + cost)
    consistent with historical contract logs, with adaptive clustering,
    iterative refinement, dummy actions for outliers, and strict IR/IC/rejection constraints.

    Params:
        v (np.ndarray): Principal's value vector (length 5)
        content (list[dict]): each dict has keys:
            'Contract' (list of 5 floats),
            'Principal Utility' (float),
            'Agent Action' (1 or -1)
    Returns:
        np.ndarray: n_actions x 6 (5 probabilities + 1 cost)
    """
    m_outcomes = v.size
    L = len(content)

    contracts = np.array([log['Contract'] for log in content])  # (L,5)
    ag_actions = np.array([log['Agent Action'] for log in content])  # (L,)
    p_util = np.array([log['Principal Utility'] for log in content])  # (L,)

    accepted_ix = np.where(ag_actions == 1)[0]
    rejected_ix = np.where(ag_actions == -1)[0]

    # If no accepted contracts, return trivial uniform action with zero cost
    if accepted_ix.size == 0:
        return np.hstack([np.ones((1, m_outcomes)) / m_outcomes, np.array([[0]])])

    accepted_w = contracts[accepted_ix]

    # Normalize contracts for clustering (avoid zero-sum issues)
    norm_w = accepted_w / (accepted_w.sum(axis=1, keepdims=True) + 1e-12)

    # Adaptive max clusters: min(10, #accepted, int(sqrt(#accepted)))
    max_clusters = min(10, len(accepted_ix), max(1, int(np.sqrt(len(accepted_ix)))))

    # We will try reducing clusters if stability is low
    def cluster_and_get_centroids(n_clusters):
        if n_clusters == 1:
            # mean of all normalized contracts
            p = norm_w.mean(axis=0)
            if p.sum() < 1e-12:
                p = np.ones(m_outcomes) / m_outcomes
            else:
                p = p / p.sum()
            return np.array([p])
        clustering = AgglomerativeClustering(n_clusters=n_clusters, linkage='average')
        labels = clustering.fit_predict(norm_w)
        p_list = []
        for c in range(n_clusters):
            cluster_idx = np.where(labels == c)[0]
            if cluster_idx.size == 0:
                # skip empty cluster (rare)
                continue
            cluster_w = accepted_w[cluster_idx]

            # weighted average by (utility - min utility + 1), favoring better contracts
            weights = p_util[accepted_ix][cluster_idx] - p_util[accepted_ix][cluster_idx].min() + 1
            avg_w = np.average(cluster_w, axis=0, weights=weights)

            p = np.clip(avg_w, 0, None)
            if p.sum() < 1e-12:
                p = np.ones(m_outcomes) / m_outcomes
            else:
                p = p / p.sum()
            p_list.append(p)
        return np.array(p_list)

    # Try clustering from max_clusters down to 1 to find stable parsimonious model
    prev_p_candidates = None
    chosen_p_candidates = None
    for nc in reversed(range(1, max_clusters + 1)):
        p_candidates = cluster_and_get_centroids(nc)
        # Measure stability by comparing to previous clustering (if any)
        if prev_p_candidates is not None:
            # Compute average min pairwise distance between old and new clusters
            dists = []
            for p_old in prev_p_candidates:
                dists.append(np.min(np.linalg.norm(p_candidates - p_old, axis=1)))
            avg_dist = np.mean(dists)
            if avg_dist < 1e-2:
                # stability good enough, accept current
                chosen_p_candidates = p_candidates
                break
        prev_p_candidates = p_candidates
    if chosen_p_candidates is None:
        chosen_p_candidates = prev_p_candidates

    p_candidates = chosen_p_candidates

    # Calculate cost lower bounds from accepted contracts
    costs_lower_bound = []
    for p in p_candidates:
        # cost <= p @ w_i for accepted contracts rationalized by this action
        # We approximate by min p @ w_i over all accepted contracts (not a perfect match)
        costs_cluster = np.array([p @ w_i for w_i in accepted_w])
        # Take minimum to ensure agent utility >=0 for at least one accepted contract
        costs_lower_bound.append(costs_cluster.min())
    costs_lower_bound = np.array(costs_lower_bound)

    # Handle rejected contracts: agent utility < 0 for all inferred actions
    if rejected_ix.size > 0:
        reject_contracts = contracts[rejected_ix]  # (#rej,5)
        p_w_rej = p_candidates @ reject_contracts.T  # (n_actions, #rej)
        c_rej_min = p_w_rej.max(axis=1) + 1e-6  # strict rejection margin
    else:
        c_rej_min = np.zeros(len(p_candidates))

    # Initial costs: max of accepted lower bounds and rejection lower bounds, nonnegative
    costs = np.maximum(costs_lower_bound, c_rej_min)
    costs = np.maximum(costs, 0)

    # Validate accepted contracts: must be rationalized by some action
    def valid_action_for_contract(w_i, eps=1e-8):
        for a, (p, c) in enumerate(zip(p_candidates, costs)):
            util = p @ w_i - c
            if util >= -eps:
                return a
        return None

    # Add dummy actions for accepted contracts not explained
    unexplained_accepts = []
    for i in accepted_ix:
        w_i = contracts[i]
        if valid_action_for_contract(w_i) is None:
            unexplained_accepts.append(i)

    for i in unexplained_accepts:
        w_i = contracts[i]
        p_new = w_i.copy()
        if p_new.sum() < 1e-12:
            p_new = np.ones(m_outcomes) / m_outcomes
        else:
            p_new = p_new / p_new.sum()
        c_new = p_new @ w_i
        p_candidates = np.vstack([p_candidates, p_new])
        costs = np.append(costs, c_new)

    # Iteratively refine costs with rejection constraints until convergence or max iter
    if rejected_ix.size > 0:
        reject_contracts = contracts[rejected_ix]
    else:
        reject_contracts = None

    max_iter = 20
    tol = 1e-6
    for _ in range(max_iter):
        prev_costs = costs.copy()

        if reject_contracts is not None:
            p_w_rej = p_candidates @ reject_contracts.T  # (n_actions, #rej)
            for a in range(len(p_candidates)):
                max_rej_util = p_w_rej[a].max()
                if costs[a] < max_rej_util + 1e-8:
                    costs[a] = max_rej_util + 1e-4  # margin

        # Ensure costs >= accepted lower bounds
        costs = np.maximum(costs, costs_lower_bound)
        costs = np.maximum(costs, 0)

        # Check convergence
        if np.max(np.abs(costs - prev_costs)) < tol:
            break

    # Final normalization of probabilities (clip negatives and normalize)
    p_candidates = np.clip(p_candidates, 0, None)
    p_sums = p_candidates.sum(axis=1, keepdims=True)
    p_sums[p_sums < 1e-12] = 1.0  # avoid division by zero
    p_candidates /= p_sums

    agent_setting = np.hstack([p_candidates, costs[:, None]])
    return agent_setting
```
