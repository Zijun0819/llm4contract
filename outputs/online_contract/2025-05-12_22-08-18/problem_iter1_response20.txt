```python
import numpy as np
import pandas as pd
from scipy.optimize import linprog
from sklearn.cluster import AgglomerativeClustering


def agent_solver_v2(v: np.ndarray, content: pd.DataFrame) -> np.ndarray:
    m = v.size
    L = len(content)

    # Prepare data arrays
    contracts = np.stack(content['Contract'].to_numpy())
    principal_utils = content['Principal Utility'].to_numpy()
    agent_actions = content['Agent Action'].to_numpy()

    # Separate accepted and rejected logs
    accepted_mask = agent_actions == 1
    rejected_mask = agent_actions == -1

    accepted_contracts = contracts[accepted_mask]
    accepted_p_utils = principal_utils[accepted_mask]
    rejected_contracts = contracts[rejected_mask]

    # Step 1: For each accepted contract, find a feasible prob dist p and cost c:
    # Solve LP: ensure sum p_j=1, p_j >=0, and v@p_j - c_j = principal utility >=0 and agent expected utility (w@p - c) >= 0
    # We'll infer p from contract and principal utility by fixing p to satisfy these. 
    # Since contract payment vector is w, principal utility is v@p - w@p = v@p - payout,
    # but principal utility given => p must satisfy v@p - c = utility + payout - unknown c
    # To avoid complicated nonlinear, we'll reverse engineer p from contracts & utilities.

    # For each accepted log:
    # idea: agent's expected utility >=0 means payment expected >= cost

    # Build candidate p from contracts and principal utils by optimizing entropy or minimal info
    # LP variables: p_j for j in m
    # Constraints:
    # sum p_j =1
    # Non-neg p_j >=0
    # Agent utility constraint: payout = contract @ p >= c (cost unknown yet)
    # Principal's utility: principal_util = v @ p - payout (known)
    # => payout = v @ p - principal_util

    # This gives two equations, but c unknown, too many vars. We infer p ignoring cost for now by searching p per contract to satisfy:
    # minimize ||p - uniform|| to get a well-defined p, subject to payout = v@p - principal_util

    def infer_p_from_contract_and_util(w: np.ndarray, util: float):
        # solve linprog to find p close to uniform with constraints sum p=1 and v@p - w@p = util => (v - w)@p=util
        c_obj = np.abs  # minimize sum abs deviation from uniform
        uniform_p = np.ones(m) / m
        # Formulate as LP minimizing sum |p - uniform_p| under constraints
        # We'll model as minimization of sum y_j s.t -y_j <= p_j - uniform_p_j <= y_j, sum p_j=1, (v-w)@p=util, p_j>=0
        # For abs-value transform, add auxiliary variables y_j >= |p_j - uniform_p_j|

        # Number of variables: p_j (m), y_j (m) total 2m
        # Objective: minimize sum y_j
        # Constraints:
        # p_j - uniform_p_j <= y_j
        # - (p_j - uniform_p_j) <= y_j  => uniform_p_j - p_j <= y_j
        # sum p_j =1
        # (v-w)@p = util
        # p_j >=0, y_j>=0

        c_lin = np.hstack([np.zeros(m), np.ones(m)])  # Cost on y_j only
        A_eq = np.vstack([
            np.hstack([np.ones(m), np.zeros(m)]),
            np.hstack([(v - w), np.zeros(m)])
        ])
        b_eq = np.array([1.0, util])
        # Inequality constraints for y_j >= |p_j - uniform_p_j|
        A_ub = []
        b_ub = []
        for j in range(m):
            row = np.zeros(2 * m)
            # p_j - uniform_p_j - y_j <= 0 => p_j - y_j <= uniform_p_j
            row[j] = 1.0
            row[m + j] = -1.0
            A_ub.append(row)
            b_ub.append(uniform_p[j])
            # - (p_j - uniform_p_j) - y_j <= 0 => -p_j - y_j <= -uniform_p_j
            row2 = np.zeros(2 * m)
            row2[j] = -1.0
            row2[m + j] = -1.0
            A_ub.append(row2)
            b_ub.append(-uniform_p[j])
        A_ub = np.array(A_ub)
        b_ub = np.array(b_ub)
        bounds = [(0, 1)] * m + [(0, None)] * m

        res = linprog(
            c=c_lin,
            A_ub=A_ub,
            b_ub=b_ub,
            A_eq=A_eq,
            b_eq=b_eq,
            bounds=bounds,
            method='highs'
        )
        if res.success:
            p = res.x[:m]
            # Clip and renormalize just in case
            p = np.clip(p, 0, 1)
            s = p.sum()
            if s > 0:
                p /= s
            else:
                p = uniform_p
            return p
        else:
            # fallback to uniform distribution
            return uniform_p

    inferred_ps = []
    for i in range(len(accepted_contracts)):
        w = accepted_contracts[i]
        util = accepted_p_utils[i]
        p_i = infer_p_from_contract_and_util(w, util)
        inferred_ps.append(p_i)
    inferred_ps = np.array(inferred_ps)

    # Step 2: Cluster inferred p vectors adaptively with hierarchical clustering 
    # to find representative agent actions (clusters of "intents/outcomes")
    # Determine number of clusters by silhouette or threshold distance

    # Use Agglomerative Clustering with distance threshold to find adaptive cluster count
    if len(inferred_ps) <= 1:
        cluster_labels = np.zeros(len(inferred_ps), dtype=int)
        n_clusters = 1
    else:
        dist_thresh = 0.15  # tunable params: threshold for max cluster distance
        clustering = AgglomerativeClustering(n_clusters=None, distance_threshold=dist_thresh)
        cluster_labels = clustering.fit_predict(inferred_ps)
        n_clusters = cluster_labels.max() + 1

    # For each cluster compute centroid p vector (mean)
    cluster_centers = np.zeros((n_clusters, m))
    for c in range(n_clusters):
        cluster_centers[c] = inferred_ps[cluster_labels == c].mean(axis=0)
        if cluster_centers[c].sum() == 0:
            cluster_centers[c] = np.ones(m) / m
        else:
            cluster_centers[c] /= cluster_centers[c].sum()

    # Step 3: Assign all accepted logs to closest cluster (action) by L2 distance on inferred p
    assignments = np.full(L, -1, dtype=int)
    for idx in np.where(accepted_mask)[0]:
        pvec = inferred_ps[np.where(accepted_mask)[0] == idx][0]
        dists = np.linalg.norm(cluster_centers - pvec, axis=1)
        assignments[idx] = int(np.argmin(dists))

    # Step 4: Infer corresponding agent costs for each action
    # Agent utility >= 0 when accepting: agent payout expected >= cost
    # We estimate cost c_a for action a as minimum (p_a @ contract) over accepted contracts assigned to a
    costs = np.full(n_clusters, np.inf)
    for a in range(n_clusters):
        idxs = np.where(assignments == a)[0]
        if len(idxs) == 0:
            # No accepted contracts assigned -> cost 0
            costs[a] = 0.0
            continue
        p_a = cluster_centers[a]
        payouts = np.dot(contracts[idxs], p_a)
        costs[a] = payouts.min()  # minimal payout from contracts accepted for this action

    # Step 5: Enforce rejection consistency: agent must reject contracts with agent utility < 0
    if rejected_contracts.shape[0] > 0:
        # For each rejected contract w, check max agent expected payout under any action must be < cost
        expected_payouts = cluster_centers @ rejected_contracts.T  # shape (n_actions, n_rejected)
        # We want cost_a > max payout_a, so max payout must be < cost to justify rejection
        rejected_max_payouts = expected_payouts.max(axis=1)
        # Enforce cost constraints:
        costs = np.maximum(costs, rejected_max_payouts + 1e-8)  # add tiny epsilon for strict inequality

    # Step 6: Construct final agent setting matrix (rows: actions)
    # Columns 0..4: outcome probabilities, column 5: cost
    cost_nonneg = np.clip(costs, 0, None)
    agent_setting = np.hstack([cluster_centers, cost_nonneg[:, np.newaxis]])

    return agent_setting
```
