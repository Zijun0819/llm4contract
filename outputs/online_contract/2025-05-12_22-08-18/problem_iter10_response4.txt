```python
import numpy as np
from sklearn.cluster import AgglomerativeClustering
from scipy.optimize import linprog

def agent_solver_v2(v: np.ndarray, content: list[dict]) -> np.ndarray:
    """
    Infer an agent setting matrix (actions = outcome distributions + costs) consistent with all
    historical contract-agent interaction logs under IR and IC constraints.

    Improvements over previous versions:
    - Global LP-based cost refinement enforces rejection constraints strictly.
    - Adaptive clustering with weighted centroids for candidate actions.
    - Minimal dummy actions added for any accepted contracts not rationalized by existing actions.
    - Strict margins guarantee rejection constraints are satisfied with numerical safety.
    - Robust simplex projection and normalization of probabilities.
    - Final LP optimizes costs to satisfy all constraints tightly without violating IR/IC.

    Parameters:
    - v (np.ndarray): Principal's value vector of length 5.
    - content (list[dict]): Each dict contains keys:
        'Contract' (list of 5 floats),
        'Principal Utility' (float),
        'Agent Action' (1 or -1).

    Returns:
    - agent_setting (np.ndarray): n_actions x 6 matrix; each row:
      first 5 elements: outcome probabilities summing to 1,
      last element: nonnegative agent cost.
    """
    m_outcomes = v.size
    L = len(content)

    # Extract arrays from logs
    contracts = np.array([log['Contract'] for log in content], dtype=np.float64)  # shape (L,5)
    ag_actions = np.array([log['Agent Action'] for log in content], dtype=int)    # shape (L,)
    p_util = np.array([log['Principal Utility'] for log in content], dtype=np.float64)  # shape (L,)

    accepted_ix = np.where(ag_actions == 1)[0]
    rejected_ix = np.where(ag_actions == -1)[0]

    # Handle no accepted contracts: trivial uniform action with zero cost suffices
    if accepted_ix.size == 0:
        uniform_p = np.ones(m_outcomes) / m_outcomes
        return np.hstack([uniform_p.reshape(1, -1), np.array([[0.0]])])

    accepted_w = contracts[accepted_ix]

    # Normalize accepted contracts for clustering (avoid zero-sum issues)
    accepted_w_sum = accepted_w.sum(axis=1, keepdims=True)
    accepted_w_sum[accepted_w_sum < 1e-12] = 1.0  # avoid division by zero
    norm_w = accepted_w / accepted_w_sum

    # Adaptive number of clusters: min(10, sqrt(#accepted), #accepted) at least 1
    n_clusters = max(1, min(10, int(np.sqrt(len(accepted_ix))), len(accepted_ix)))

    if n_clusters > 1:
        clustering = AgglomerativeClustering(n_clusters=n_clusters, linkage='average')
        cluster_labels = clustering.fit_predict(norm_w)
    else:
        cluster_labels = np.zeros(len(accepted_ix), dtype=int)

    p_candidates = []
    cost_lb = []

    # Compute weighted centroids per cluster and cost lower bounds from IR constraints
    for c in range(n_clusters):
        cluster_mask = (cluster_labels == c)
        cluster_idx = accepted_ix[cluster_mask]
        if cluster_idx.size == 0:
            continue

        cluster_w = contracts[cluster_idx]
        cluster_util = p_util[cluster_idx]

        # Weights: positive and proportional to utilities shifted to be ≥1
        weights = cluster_util - cluster_util.min() + 1.0
        if np.sum(weights) < 1e-12:
            weights = np.ones_like(weights)
        weights = weights / weights.sum()

        weighted_avg = np.average(cluster_w, axis=0, weights=weights)

        # Project weighted average onto simplex: clip negatives and renormalize
        p = np.clip(weighted_avg, 0.0, None)
        s = p.sum()
        if s < 1e-12:
            p = np.ones(m_outcomes) / m_outcomes
        else:
            p = p / s

        p_candidates.append(p)

        # Cost lower bound: for IR, cost ≤ min_{i in cluster} p @ w_i
        cluster_costs = np.array([p @ contracts[i] for i in cluster_idx])
        cost_lb.append(cluster_costs.min())

    p_candidates = np.array(p_candidates)
    cost_lb = np.array(cost_lb)

    # Rejected contracts constraints: cost > max_{r} p @ w_r for each action p
    if rejected_ix.size > 0:
        rejected_w = contracts[rejected_ix]
        p_w_rej = p_candidates @ rejected_w.T  # shape (n_actions, n_rejected)
        c_rej_min = p_w_rej.max(axis=1) + 1e-8  # small margin epsilon
    else:
        c_rej_min = np.zeros(len(p_candidates))

    # Initial costs satisfying both IR and rejection constraints
    costs = np.maximum(cost_lb, c_rej_min)
    costs = np.maximum(costs, 0.0)  # enforce nonnegativity

    # Define helper to check if an accepted contract is rationalized by any current action
    def rationalizes(w_i: np.ndarray) -> bool:
        utilities = p_candidates @ w_i - costs
        return np.any(utilities >= -1e-12)

    # Add minimal dummy actions for accepted contracts not rationalized
    for idx in accepted_ix:
        w_i = contracts[idx]
        if not rationalizes(w_i):
            p_new = np.clip(w_i, 0.0, None)
            s = p_new.sum()
            if s < 1e-12:
                p_new = np.ones(m_outcomes) / m_outcomes
            else:
                p_new = p_new / s
            c_new = p_new @ w_i  # minimal cost consistent with IR
            p_candidates = np.vstack([p_candidates, p_new])
            costs = np.append(costs, c_new)

    n_actions = len(p_candidates)

    # After adding dummy actions, recompute rejection constraints margins strictly
    if rejected_ix.size > 0:
        rejected_w = contracts[rejected_ix]
        p_w_rej = p_candidates @ rejected_w.T  # (n_actions, n_rejected)
        for a in range(n_actions):
            max_rej = p_w_rej[a].max()
            if costs[a] <= max_rej + 1e-12:
                costs[a] = max_rej + 1e-4  # small safety margin

    # Prepare LP to refine costs globally:
    # Variables: costs c_a (nonnegative)
    # Constraints:
    # 1) For each rejected contract r and each action a: c_a ≥ p_a @ w_r + epsilon
    # 2) For each accepted contract i: exists action a with c_a ≤ p_a @ w_i (handled by dummy actions)
    # Objective: minimize sum of costs (or zero vector since any feasible solution suffices)

    epsilon = 1e-5
    c_obj = np.zeros(n_actions)

    # Build inequality constraints for rejection: -c_a ≤ -(p_a @ w_r + epsilon)
    A_ub = []
    b_ub = []

    if rejected_ix.size > 0:
        for a in range(n_actions):
            p_a = p_candidates[a]
            for r in rejected_ix:
                val = p_a @ contracts[r] + epsilon
                row = np.zeros(n_actions)
                row[a] = -1.0
                A_ub.append(row)
                b_ub.append(-val)

        A_ub = np.array(A_ub)
        b_ub = np.array(b_ub)
    else:
        # No rejections => no inequality constraints
        A_ub = None
        b_ub = None

    bounds = [(0, None)] * n_actions  # costs ≥ 0

    # Solve LP via HiGHS (efficient modern LP solver)
    if A_ub is not None:
        res = linprog(c_obj, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')
        if res.success:
            refined_costs = res.x
            # Enforce numerical nonnegativity and margins
            refined_costs = np.maximum(refined_costs, costs)
            costs = refined_costs

    # Final normalization of probabilities onto simplex (numerical safety)
    p_candidates = np.clip(p_candidates, 0.0, None)
    p_sums = p_candidates.sum(axis=1, keepdims=True)
    zero_mask = p_sums < 1e-12
    p_sums[zero_mask] = 1.0
    p_candidates /= p_sums

    # Ensure costs nonnegative and reshape for output
    costs = np.maximum(costs, 0.0)
    costs = costs.reshape(-1, 1)

    agent_setting = np.hstack([p_candidates, costs])
    return agent_setting
```
