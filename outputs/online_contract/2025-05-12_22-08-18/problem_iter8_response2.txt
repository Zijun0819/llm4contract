```python
import numpy as np
from scipy.optimize import linprog
from sklearn.cluster import AgglomerativeClustering

def agent_solver_v2(v: np.ndarray, content: list[dict]) -> np.ndarray:
    """
    Infer a valid agent setting consistent with historical logs by:
    - Weighted agglomerative clustering on normalized accepted contracts,
    - Weighted centroids with principal utility weights,
    - Adding minimal dummy actions for unexplained accepted contracts,
    - Refining costs via LP enforcing strict IR/IC constraints,
    - Precise normalization of probabilities.

    Args:
        v (np.ndarray): Principal's reward vector over 5 outcomes, shape (5,)
        content (list[dict]): Each dict has keys:
            'Contract' (list/array length 5),
            'Principal Utility' (float),
            'Agent Action' (1 or -1)

    Returns:
        np.ndarray: agent setting matrix (n_actions x 6),
                    each row: [p_1,...,p_5, cost],
                    p_i >=0, sum p_i=1, cost >=0
    """
    m = v.size
    L = len(content)
    if L == 0:
        # No data, return trivial uniform action zero cost
        return np.hstack([np.ones((1, m)) / m, np.array([[0.0]])])

    contracts = np.array([log['Contract'] for log in content], dtype=np.float64)  # (L, m)
    agent_actions = np.array([log['Agent Action'] for log in content], dtype=int)  # (L,)
    principal_utils = np.array([log['Principal Utility'] for log in content], dtype=np.float64)  # (L,)

    accepted_ix = np.where(agent_actions == 1)[0]
    rejected_ix = np.where(agent_actions == -1)[0]

    # If no accepted contracts, trivial uniform action zero cost
    if accepted_ix.size == 0:
        return np.hstack([np.ones((1, m)) / m, np.array([[0.0]])])

    accepted_contracts = contracts[accepted_ix]  # (num_accepted, m)

    # Normalize accepted contracts to simplex for clustering (avoid division by zero)
    accepted_sum = accepted_contracts.sum(axis=1, keepdims=True)
    accepted_sum[accepted_sum < 1e-12] = 1.0
    norm_accepted = accepted_contracts / accepted_sum  # (num_accepted, m)

    n_accepted = accepted_ix.size
    # Adaptive number of clusters: min(10, n_accepted, int(sqrt(n_accepted)) or 1 if zero)
    n_clusters = max(1, min(10, n_accepted, int(np.sqrt(n_accepted))))

    # Use AgglomerativeClustering with average linkage
    clustering = AgglomerativeClustering(n_clusters=n_clusters, linkage='average')
    labels = clustering.fit_predict(norm_accepted)

    p_candidates = []
    costs_lb = []

    # Compute weighted centroids with shifted positive principal utilities as weights
    # For the accepted contracts only
    pu_accepted = principal_utils[accepted_ix]
    pu_shift = pu_accepted.min()
    weights_per_contract = pu_accepted - pu_shift + 1.0  # positive weights >= 1

    for c in range(n_clusters):
        cluster_mask = (labels == c)
        if not np.any(cluster_mask):
            continue
        cluster_indices = accepted_ix[cluster_mask]
        cluster_contracts = contracts[cluster_indices]

        cluster_weights = weights_per_contract[cluster_mask]
        # Weighted average centroid in reward space
        weighted_avg = np.average(cluster_contracts, axis=0, weights=cluster_weights)

        # Project to simplex: clip negatives and renormalize
        p = np.clip(weighted_avg, 0, None)
        s = p.sum()
        if s < 1e-12:
            p = np.ones(m) / m
        else:
            p /= s
        p_candidates.append(p)

        # Cost lower bound from accepted contracts in this cluster: cost <= p @ w_i (utility>=0)
        costs_in_cluster = p @ cluster_contracts.T  # shape (cluster_size,)
        min_cost = np.min(costs_in_cluster)
        costs_lb.append(min_cost)

    if len(p_candidates) == 0:
        # Defensive fallback: uniform distribution zero cost
        return np.hstack([np.ones((1, m)) / m, np.array([[0.0]])])

    p_candidates = np.array(p_candidates)  # (n_actions, m)
    costs_lb = np.array(costs_lb)

    # Handle rejection constraints:
    # For each rejected contract r and each action a: cost_a > p_a @ w_r (strict)
    if rejected_ix.size > 0:
        reject_contracts = contracts[rejected_ix]  # (n_rej, m)
        p_w_rej = p_candidates @ reject_contracts.T  # (n_actions, n_rej)
        c_rej_min = p_w_rej.max(axis=1) + 1e-6  # strict margin epsilon=1e-6
    else:
        c_rej_min = np.zeros(len(p_candidates))

    # Initial costs satisfying both accepted and rejected constraints
    costs = np.maximum(costs_lb, c_rej_min)
    costs = np.maximum(costs, 0)

    def action_rationalizes_contract(w_i):
        """
        Return index of action that rationalizes contract w_i with agent utility >=0,
        or None if none found.
        """
        for i, (p, c) in enumerate(zip(p_candidates, costs)):
            if p @ w_i - c >= -1e-9:
                return i
        return None

    # Add minimal dummy actions for unexplained accepted contracts
    unexplained_mask = []
    for i in accepted_ix:
        w_i = contracts[i]
        if action_rationalizes_contract(w_i) is None:
            unexplained_mask.append(i)
    # Append one dummy action per unexplained contract
    for i in unexplained_mask:
        w_i = contracts[i]
        p_new = np.clip(w_i, 0, None)
        s = p_new.sum()
        if s < 1e-12:
            p_new = np.ones(m) / m
        else:
            p_new /= s
        c_new = p_new @ w_i
        p_candidates = np.vstack([p_candidates, p_new])
        costs = np.append(costs, c_new)

    # Re-check rejection constraints after adding dummy actions
    if rejected_ix.size > 0:
        reject_contracts = contracts[rejected_ix]
        p_w_rej = p_candidates @ reject_contracts.T  # (n_actions, n_rej)
        for a in range(len(costs)):
            max_rej_util = p_w_rej[a].max()
            if costs[a] < max_rej_util + 1e-8:
                costs[a] = max_rej_util + 1e-4  # add small margin

    n_actions = len(costs)

    # Setup LP to refine costs ensuring IR/IC strictly:
    # Variables: costs a vector length n_actions
    # Constraints:
    #  (1) For all accepted contracts i: ∃ a s.t. p_a @ w_i - cost_a ≥ 0
    #      => cost_a ≤ p_a @ w_i for some a
    #      Since non-convex max constraint, approximate by ensuring at least one action satisfies:
    #      We'll enforce cost_a ≤ p_a @ w_i for all accepted i and all actions a (loose but safe).
    #
    #  (2) For all rejected contracts r and all actions a: cost_a > p_a @ w_r + eps
    #
    # We'll encode (2) as inequalities:
    #   -cost_a ≤ - (p_a @ w_r + eps)
    #
    # Objective: minimize sum(costs) to keep costs parsimonious

    # Construct inequality constraints for rejected contracts:
    epsilon = 1e-5
    A_ub_rows = []
    b_ub_vals = []
    for a in range(n_actions):
        for r in rejected_ix:
            val = p_candidates[a] @ contracts[r] + epsilon
            row = np.zeros(n_actions)
            row[a] = -1
            A_ub_rows.append(row)
            b_ub_vals.append(-val)
    if len(A_ub_rows) > 0:
        A_ub = np.vstack(A_ub_rows)
        b_ub = np.array(b_ub_vals)
    else:
        A_ub = None
        b_ub = None

    # Bounds for costs: ≥ 0
    bounds = [(0, None)] * n_actions

    # Objective: minimize sum(costs)
    c_obj = np.ones(n_actions)

    # Solve LP
    res = linprog(c=c_obj, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')

    if res.success and res.x is not None and np.all(np.isfinite(res.x)):
        refined_costs = np.maximum(res.x, 0)
        # Check accepted contracts IR feasibility:
        # For each accepted contract i, check if any action satisfies p_a @ w_i - c_a >=0
        def contract_explained(w_i):
            return any(p_candidates[a] @ w_i - refined_costs[a] >= -1e-9 for a in range(n_actions))

        all_accepted_feasible = all(contract_explained(contracts[i]) for i in accepted_ix)

        if all_accepted_feasible:
            costs = refined_costs
        # else fallback to previous costs (safe)
    # else fallback to previous costs (safe)

    # Normalize p_candidates rows to simplex strictly
    p_candidates = np.clip(p_candidates, 0, None)
    sums = p_candidates.sum(axis=1, keepdims=True)
    sums[sums < 1e-12] = 1.0
    p_candidates /= sums

    agent_setting = np.hstack([p_candidates, costs.reshape(-1, 1)])
    return agent_setting
```
