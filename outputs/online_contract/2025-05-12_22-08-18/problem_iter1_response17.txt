```python
import numpy as np
import pandas as pd
from scipy.optimize import linprog
from sklearn.cluster import AgglomerativeClustering
from typing import List, Dict


def agent_solver_v2(v: np.ndarray, content: List[Dict]) -> np.ndarray:
    """
    Infer a valid agent setting matrix [p1, ..., p5, c] from historical contract logs.

    Args:
    - v: principal's reward vector for 5 outcomes, shape (5,)
    - content: list of logs, each a dict with keys 'Contract' (list of 5 floats),
      'Principal Utility' (float), and 'Agent Action' (1 or -1).

    Returns:
    - agent_setting: n_actions x 6 matrix, where each row = [p1,...p5,cost].
      Each p is a valid probability distribution over 5 outcomes, cost >=0.
    """

    contracts = np.array([log['Contract'] for log in content])  # L x 5
    princ_utils = np.array([log['Principal Utility'] for log in content])  # L
    agent_actions = np.array([log['Agent Action'] for log in content])      # L
    L, m = contracts.shape

    # Separate accepted and rejected logs
    accept_mask = agent_actions == 1
    reject_mask = agent_actions == -1

    contracts_accepted = contracts[accept_mask]
    princ_utils_accepted = princ_utils[accept_mask]
    contracts_rejected = contracts[reject_mask]

    # 1) Use accepted contracts to infer representative outcome distributions p:
    # We'll solve, for each accepted contract i:
    #   max_p p·contract_i - c >= 0   =>   p·contract_i >= c
    #   p is prob dist: sum p =1, p>=0
    # We start by choosing the action counts heuristically by clustering.

    # First, infer a 'pseudo p_i' for each accepted contract i by
    # solving LP:
    # maximize p·contract_i s.t sum p=1, p≥0
    # Because agent prefers actions with higher expected payments minus cost >=0,
    # and cost unknown. To get variety, store the max distributions.

    def solve_max_p_given_w(w):
        c_obj = -w  # maximize p·w <=> minimize -p·w
        A_eq = [np.ones(m)]
        b_eq = [1.]
        bounds = [(0, 1)] * m
        res = linprog(c_obj, A_eq=A_eq, b_eq=b_eq, bounds=bounds, method='highs')
        if res.success:
            return res.x
        else:
            return None

    pseudo_ps = []
    for i in range(contracts_accepted.shape[0]):
        p_ = solve_max_p_given_w(contracts_accepted[i])
        if p_ is not None:
            pseudo_ps.append(p_)
    if len(pseudo_ps) == 0:
        # fallback: uniform distribution over outcomes
        pseudo_ps = [np.ones(m) / m]

    pseudo_ps = np.array(pseudo_ps)

    # 2) Cluster the pseudo_ps to group similar agent actions (agglomerative clustering)
    max_actions = min(10, len(pseudo_ps))  # Control model complexity
    clusterer = AgglomerativeClustering(n_clusters=max_actions)
    clusters = clusterer.fit_predict(pseudo_ps)

    # Representative p for each cluster: centroid (mean)
    action_count = max_actions
    p_actions = np.zeros((action_count, m))
    for k in range(action_count):
        members = pseudo_ps[clusters == k]
        if len(members) > 0:
            centroid = np.mean(members, axis=0)
            if centroid.sum() > 0:
                centroid /= centroid.sum()
            else:
                centroid = np.ones(m) / m
            p_actions[k] = centroid
        else:
            # rare: assign uniform
            p_actions[k] = np.ones(m) / m

    # 3) Calculate minimal costs c_a for each action a consistent with accept logs:
    # For all accept logs i assigned to cluster a (where p_actions[a] best fits contract_i expected utility),
    # cost c_a <= p_actions[a]·contract_i (agent utility >=0)
    # Take minimal such to maximize principal utility margin

    # Assign each accepted contract to the best action by max expected utility p·w-c ≥ 0 -> neglecting c for assignment:
    assigns = np.full(contracts_accepted.shape[0], -1)
    for i, w in enumerate(contracts_accepted):
        ex_utils = p_actions @ w  # shape(action_count,)
        assigns[i] = np.argmax(ex_utils)

    c_actions = np.full(action_count, 0.0)
    for a in range(action_count):
        indices = np.where(assigns == a)[0]
        if len(indices) == 0:
            c_actions[a] = 0.0
            continue
        # The largest cost c still compatible with all accepted logs in a is min of expected utilities over assigned logs
        costs = np.array([p_actions[a] @ contracts_accepted[i] for i in indices])
        c_actions[a] = np.min(costs)

    # 4) Enforce IR and IC constraints on rejected offers:
    # For each rejected contract j:
    # Agent utility for any action a must be < 0:
    # p_actions[a]·contract_j - c_actions[a] < 0
    # Rearranged: c_actions[a] > p_actions[a]·contract_j

    # To satisfy this, bump up costs c_actions if needed:
    if len(contracts_rejected) > 0:
        rej_utils = p_actions @ contracts_rejected.T  # shape (action_count, #rejections)
        bnd_costs = np.max(rej_utils, axis=1)  # max utility any rejected contract gives each action
        # cost must be strictly greater than bnd_costs, so add epsilon
        epsilon = 1e-5
        c_actions = np.maximum(c_actions, bnd_costs + epsilon)

    # 5) Normalize p_actions to sum to 1 (numerical safety)
    p_actions = np.clip(p_actions, 0, None)
    p_actions /= p_actions.sum(axis=1, keepdims=True)

    # 6) Assemble final agent setting matrix: [p1,...p5,cost]
    agent_setting = np.hstack([p_actions, c_actions.reshape(-1, 1)])

    # 7) Ensure cost non-negative
    agent_setting[:, -1] = np.maximum(agent_setting[:, -1], 0.0)

    return agent_setting
```
