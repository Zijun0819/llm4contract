```python
import numpy as np
import pandas as pd
from scipy.optimize import linprog
from sklearn.cluster import AgglomerativeClustering


def agent_solver_v2(v: np.ndarray, content: list[dict]) -> np.ndarray:
    """
    Infer a valid agent setting (actions as outcome distributions + cost) that explains
    all historical logs (accept = IR satisfied, reject = IR violated).
    
    Parameters
    ----------
    v : np.ndarray
        Principal's reward vector for 5 outcomes, shape (5,)
    content : list of dict
        Historical logs, each with keys:
          - 'Contract': list or array of 5 payments,
          - 'Principal Utility': float (0 if rejected),
          - 'Agent Action': 1 (accept) or -1 (reject)
    
    Returns
    -------
    agent_setting : np.ndarray
        n x 6 matrix, each row = [p_1,...p_5, cost],
        p_j >= 0, sum_j p_j = 1, cost >= 0,
        n chosen adaptively by clustering acceptance patterns
    """
    contracts = np.array([log['Contract'] for log in content])  # shape (L, 5)
    actions = np.array([log['Agent Action'] for log in content])  # shape (L,)
    princ_utils = np.array([log['Principal Utility'] for log in content])

    L, m_outcomes = contracts.shape
    assert m_outcomes == 5 and v.shape[0] == 5

    # Separate accepts and rejects
    accept_idx = np.where(actions == 1)[0]
    reject_idx = np.where(actions == -1)[0]

    accepts_C = contracts[accept_idx]   # contracts accepted
    accepts_U = princ_utils[accept_idx] # principal utils with accepted contracts

    # Step 1: Infer plausible agent outcome distributions (p) from accepted logs
    # Use LP to find p: w·p - cost >= 0 (agent IR), fixes cost later,
    # p·w = expected wage, p·v = principal expected payoff (info).
    # We'll estimate "p" by solving for a probability distribution that
    # rationalizes the agent accepting given contract w.

    def find_feasible_p(w, cutoff=0.0):
        # Solve linprog to find p: max p·w s.t. p ∈ simplex
        # Cost will be inferred later. For IR accept: p·w - cost >= 0.
        # Just find p maximizing p·w, which is trivial: put 1 probability on max w_j.
        # But for realistic distribution, solve LP: maximize min gap or diversity

        # Instead, to get a distribution explaining acceptance and multiple samples,
        # solve LP to maximize agent utility subject to simplex constraint.

        A_eq = np.ones((1, m_outcomes))
        b_eq = np.array([1])
        bounds = [(0, 1) for _ in range(m_outcomes)]

        # Maximize agent expected utility, which for a fixed w is max p·w
        c = -w  # because linprog does minimization

        res = linprog(c, A_eq=A_eq, b_eq=b_eq, bounds=bounds, method='highs')
        if res.success:
            return res.x
        else:
            return None

    inferred_ps = []
    # Build matrix of agent expected utilities under each accepted contract
    # and cluster to infer n agent action types

    for w in accepts_C:
        p = find_feasible_p(w)
        if p is None:
            # fallback uniform dist if LP fails
            p = np.ones(m_outcomes) / m_outcomes
        inferred_ps.append(p)
    inferred_ps = np.array(inferred_ps)

    # Step 2: Adaptive clustering to find number of agent actions
    # Try cluster counts from 2 up to min(8, accepted count)
    max_clusters = min(8, max(2, len(inferred_ps)))
    best_n = 1
    best_score = np.inf
    best_labels = None

    # Use hierarchical clustering with cosine affinity on the probability vectors
    for n_clusters in range(1, max_clusters + 1):
        if n_clusters == 1:
            labels = np.zeros(len(inferred_ps), dtype=int)
            centers = inferred_ps.mean(axis=0, keepdims=True)
        else:
            clusterer = AgglomerativeClustering(
                n_clusters=n_clusters, affinity='cosine', linkage='average')
            labels = clusterer.fit_predict(inferred_ps)
            centers = []
            for lbl in range(n_clusters):
                subset = inferred_ps[labels == lbl]
                if len(subset) == 0:
                    # no members, fallback uniform
                    centers.append(np.ones(m_outcomes)/m_outcomes)
                else:
                    center = subset.mean(axis=0)
                    center = np.maximum(center, 0)
                    center = center / center.sum()
                    centers.append(center)
            centers = np.array(centers)

        # Evaluate clustering quality by total intra-cluster cosine distances
        score = 0
        for i, p in enumerate(inferred_ps):
            center = centers[labels[i]]
            # Cosine similarity ~= dot product since vectors on simplex
            cosine_sim = p @ center / (np.linalg.norm(p) * np.linalg.norm(center) + 1e-8)
            dist = 1 - cosine_sim
            score += dist

        if score < best_score:
            best_score = score
            best_n = n_clusters
            best_labels = labels
            best_centers = centers

    n = best_n
    p_matrix = best_centers  # shape (n, 5)

    # Step 3: Estimate costs for each inferred agent action to satisfy logs
    # IR: For accepted contracts i assigned to action a, agent utility p_a·w_i - c_a >=0
    # => c_a <= min_i p_a·w_i over i assigned a
    #
    # IC: For rejected contracts, agent utility < 0 for all actions:
    # p_a·w_j - c_a < 0 => c_a > max_j p_a·w_j for rejected logs
    #
    # Combine constraints: c_a in [max rejected wage.t p_a, min accepted wage.t p_a]

    # Assign accepted logs to closest agent action by cosine similarity of leader (p_a and inferred p_i)
    clusters_assign = np.full(len(accept_idx), -1, dtype=int)
    for idx_, p_i in enumerate(inferred_ps):
        cos_sim = p_matrix @ p_i / (
            np.linalg.norm(p_matrix, axis=1) * np.linalg.norm(p_i) + 1e-12)
        clusters_assign[idx_] = np.argmax(cos_sim)

    costs = np.zeros(n)

    # Calculate agent expected wages for accept and reject for each action
    # Find bounds for c_a: c_a <= min accept wage, c_a > max reject wage
    for a in range(n):
        accept_indices = np.where(clusters_assign == a)[0]
        if len(accept_indices) > 0:
            accepts_w = accepts_C[accept_indices]  # contracts in accept logs assigned to a
            accept_utils = accepts_w @ p_matrix[a]  # shape (num_accepts,)
            c_u_bound_low = np.min(accept_utils)  # agent cost <= min expected wage on accepted contracts
        else:
            c_u_bound_low = 0  # no accepted logs => cost >=0

        if len(reject_idx) > 0:
            rejects_w = contracts[reject_idx]
            reject_utils = rejects_w @ p_matrix[a]  # expected wages for rejected contracts
            c_u_bound_high = np.max(reject_utils)  # cost > max expected wage on rejected contracts
        else:
            c_u_bound_high = 0

        # Feasibility: cost within (c_u_bound_high, c_u_bound_low]
        if c_u_bound_low < c_u_bound_high:
            # Infeasible: no cost satisfies IR and rejection constraints simultaneously
            # Relax cost: lower bound to c_u_bound_high, compromise triggers some rejection IR violation
            cost = c_u_bound_high + 1e-5
        else:
            # Pick cost slightly above rejection upper bound, but below accept lower bound comfortably
            margin = max(1e-5, (c_u_bound_low - c_u_bound_high) * 0.1)
            cost = c_u_bound_high + margin
            cost = min(cost, c_u_bound_low)

        costs[a] = max(cost, 0)

    # Step 4: Normalize probability vectors to ensure sum=1 exactly & non-negativity
    p_matrix = np.maximum(p_matrix, 0)
    norms = p_matrix.sum(axis=1, keepdims=True)
    valid = norms > 1e-12
    p_matrix[valid] /= norms[valid]

    agent_setting = np.hstack([p_matrix, costs.reshape(-1, 1)])
    return agent_setting
```
