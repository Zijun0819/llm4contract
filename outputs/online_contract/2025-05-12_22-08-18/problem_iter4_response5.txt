```python
import numpy as np
from sklearn.cluster import KMeans
from scipy.optimize import linprog

def agent_solver_v2(v: np.ndarray, content: list[dict]) -> np.ndarray:
    """
    Infer a valid agent setting matrix from historical contract interactions.

    Parameters:
    - v: Principal reward vector of shape (5,)
    - content: List of dicts, each with keys 'Contract' (list of 5 floats),
               'Principal Utility' (float), 'Agent Action' (1 or -1)

    Returns:
    - agent_setting: n x 6 numpy array where each row represents an action:
        first 5 elements are outcome probabilities (sum to 1),
        last element is agent's cost (>=0) for performing the action.
    """
    m_outcomes = v.shape[0]
    L = len(content)

    # Parse logs into arrays
    contracts = np.array([entry['Contract'] for entry in content], dtype=np.float64)  # (L,5)
    agent_actions = np.array([entry['Agent Action'] for entry in content], dtype=int)  # (L,)

    accepted_idx = np.where(agent_actions == 1)[0]
    rejected_idx = np.where(agent_actions == -1)[0]

    # If no accepted contracts, return trivial uniform action with zero cost
    if len(accepted_idx) == 0:
        p_uniform = np.ones(m_outcomes) / m_outcomes
        return np.hstack([p_uniform, [0.0]]).reshape(1, -1)

    # --- Step 1: Cluster accepted contracts by their contract payment vectors ---
    # Determine number of clusters adaptively
    accepted_contracts = contracts[accepted_idx]
    unique_accepts = np.unique(accepted_contracts, axis=0)
    n_candidates = min(max(2, len(unique_accepts) // 2), 10)
    n_candidates = min(n_candidates, len(accepted_idx))
    # If too few accepted contracts, just set n_candidates = number of accepted contracts (max 10)
    if n_candidates < 1:
        n_candidates = 1

    kmeans = KMeans(n_clusters=n_candidates, random_state=42, n_init=15)
    cluster_labels = kmeans.fit_predict(accepted_contracts)

    # --- Step 2: For each cluster, solve LP to find (p,c) ---
    # Variables: p in R^5 (probabilities), c in R+ (cost)
    # Constraints: sum(p)=1, p >=0, for each contract in cluster: p@w_i >= c
    # Objective: minimize c
    actions_p = []
    actions_c = []
    c_var_idx = m_outcomes
    n_vars = m_outcomes + 1  # p (5) + c (1)

    for a in range(n_candidates):
        idxs = accepted_idx[cluster_labels == a]
        W = contracts[idxs]  # (cluster_size, 5)

        # Equality constraint: sum(p) = 1
        A_eq = np.zeros((1, n_vars))
        A_eq[0, :m_outcomes] = 1
        b_eq = np.array([1.0])

        # Inequality constraints: for each contract w_i in cluster
        # -p @ w_i + c <= 0  <=>  (-w_i, 1) @ (p,c) <= 0
        A_ub = np.zeros((len(W), n_vars))
        b_ub = np.zeros(len(W))
        for i, w_i in enumerate(W):
            A_ub[i, :m_outcomes] = -w_i
            A_ub[i, c_var_idx] = 1

        # Bounds for variables: p_i in [0,1], c in [0,+inf)
        bounds = [(0, 1)] * m_outcomes + [(0, None)]

        c_obj = np.zeros(n_vars)
        c_obj[c_var_idx] = 1  # minimize cost

        res = linprog(c=c_obj, A_ub=A_ub, b_ub=b_ub,
                      A_eq=A_eq, b_eq=b_eq, bounds=bounds, method='highs')

        if res.success:
            p_candidate = res.x[:m_outcomes]
            cost_candidate = res.x[c_var_idx]
        else:
            # fallback: uniform distribution, zero cost
            p_candidate = np.ones(m_outcomes) / m_outcomes
            cost_candidate = 0.0

        # Normalize p in case of numerical errors
        p_candidate = np.maximum(p_candidate, 0)
        s = p_candidate.sum()
        if s > 0:
            p_candidate /= s
        else:
            p_candidate = np.ones(m_outcomes) / m_outcomes
        cost_candidate = max(cost_candidate, 0)

        actions_p.append(p_candidate)
        actions_c.append(cost_candidate)

    p_matrix = np.array(actions_p)  # shape (n_candidates, 5)
    c_vec = np.array(actions_c)     # shape (n_candidates,)

    # --- Step 3: Enforce rejection constraints ---
    # For each rejected contract w_j and each action a:
    # p[a] @ w_j - c[a] < 0  =>  c[a] > p[a] @ w_j
    # If violated, increase c[a] to be slightly above max utility on rejected contracts
    if len(rejected_idx) > 0:
        rej_contracts = contracts[rejected_idx]  # (#rej,5)
        utils = p_matrix @ rej_contracts.T       # (n_candidates, #rej)

        # For each action, find max utility over rejected contracts
        max_rej_util = np.max(utils, axis=1) if rej_contracts.shape[0] > 0 else np.array([])

        # Increase costs if needed
        margin = 1e-6
        for a_idx in range(len(c_vec)):
            if len(max_rej_util) == 0:
                break
            if c_vec[a_idx] <= max_rej_util[a_idx] + margin:
                c_vec[a_idx] = max_rej_util[a_idx] + margin

        # Check if any violation remains (just in case)
        utils_post = p_matrix @ rej_contracts.T
        violations = utils_post >= (c_vec[:, None] - 1e-9)
        if violations.any():
            # Add dummy action that strictly rejects all rejected contracts
            p_dummy = np.ones(m_outcomes) / m_outcomes
            max_util_dummy = (p_dummy @ rej_contracts.T).max() if rej_contracts.shape[0] > 0 else 0
            cost_dummy = max_util_dummy + 1e3  # large enough to ensure negative utility for rejected contracts
            p_matrix = np.vstack([p_matrix, p_dummy])
            c_vec = np.concatenate([c_vec, [cost_dummy]])

    # --- Step 4: Enforce IC and IR for accepted contracts ---
    # For each accepted contract w_i:
    # There must be at least one action a with p[a]@w_i - c[a] >= 0 (agent accepts)
    # And chosen action(s) must have maximum utility (IC)
    for i in accepted_idx:
        w_i = contracts[i]
        utilities = p_matrix @ w_i - c_vec  # (n_actions,)

        max_util = np.max(utilities)
        if max_util < -1e-9:
            # No action explains acceptance; add new action exactly explaining it
            p_new = np.maximum(w_i, 0)
            s = p_new.sum()
            if s > 0:
                p_new /= s
            else:
                p_new = np.ones(m_outcomes) / m_outcomes
            cost_new = max(p_new @ w_i, 0)
            p_matrix = np.vstack([p_matrix, p_new])
            c_vec = np.concatenate([c_vec, [cost_new]])
            utilities = np.append(utilities, max_util)

        # Identify chosen action(s) with utility close to max_util
        chosen_actions = np.where(utilities >= max_util - 1e-9)[0]

        # For each chosen action enforce IC: no other action has strictly higher utility
        for chosen_a in chosen_actions:
            for other_a in range(len(c_vec)):
                if other_a == chosen_a:
                    continue
                diff = (p_matrix[other_a] @ w_i - c_vec[other_a]) - (p_matrix[chosen_a] @ w_i - c_vec[chosen_a])
                if diff > 0:
                    # Increase cost of other_a minimally to fix violation:
                    # c[other_a] >= p[other_a]@w_i - (utility difference) + small margin
                    increment = diff + 1e-6
                    new_cost = p_matrix[other_a] @ w_i + increment
                    if new_cost > c_vec[other_a]:
                        c_vec[other_a] = new_cost

    # --- Step 5: Final normalization and clipping ---
    p_matrix = np.maximum(p_matrix, 0)
    row_sums = p_matrix.sum(axis=1, keepdims=True)
    row_sums[row_sums == 0] = 1.0  # avoid division by zero
    p_matrix /= row_sums
    c_vec = np.clip(c_vec, 0, None)

    agent_setting = np.hstack([p_matrix, c_vec[:, None]])

    return agent_setting
```
