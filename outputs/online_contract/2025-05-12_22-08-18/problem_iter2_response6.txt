```python
import numpy as np
from scipy.optimize import linprog
from sklearn.cluster import KMeans

def agent_solver(v: np.ndarray, content: list[dict]) -> np.ndarray:
    """
    Infer a valid agent setting matrix (n_actions x 6) where each row is:
    [probabilities over 5 outcomes (sum to 1), cost ≥ 0].

    Inputs:
    - v: np.ndarray of shape (5,), principal's reward vector over outcomes.
    - content: list of dicts with keys:
        'Contract': list/array of length 5 (payment vector),
        'Principal Utility': float,
        'Agent Action': 1 (accept) or -1 (reject).

    Returns:
    - agent_setting: np.ndarray shape (n_actions, 6) with each row:
      [p_1,...,p_5, cost], p_i ≥ 0, sum p_i=1, cost ≥ 0.
    """
    np.random.seed(42)
    m = len(v)  # number of outcomes (5)
    L = len(content)

    # Parse logs into arrays
    contracts = np.array([log['Contract'] for log in content])  # shape (L, 5)
    principal_utils = np.array([log['Principal Utility'] for log in content])
    agent_actions = np.array([log['Agent Action'] for log in content])

    accepted_idx = np.where(agent_actions == 1)[0]
    rejected_idx = np.where(agent_actions == -1)[0]

    # If no accepted contracts, fallback to trivial uniform agent with zero cost
    if len(accepted_idx) == 0:
        uniform_p = np.ones(m) / m
        return np.hstack([uniform_p.reshape(1, -1), np.array([[0.0]])])

    accepted_contracts = contracts[accepted_idx]

    # Adaptive number of clusters:
    max_K = min(8, max(2, len(accepted_idx)//10))
    if max_K < 2:
        max_K = 2

    eps = 1e-5
    attempt = 0
    max_attempts = 4

    while attempt < max_attempts and max_K >= 1:
        # Cluster accepted contracts by wage vector
        kmeans = KMeans(n_clusters=max_K, random_state=0, n_init=20).fit(accepted_contracts)
        centers_w = kmeans.cluster_centers_  # shape (max_K, 5)

        # Infer p_k per cluster center w_k via LP: maximize p @ w_k s.t. p≥0, sum p=1
        p_candidates = []
        for k in range(max_K):
            w_k = centers_w[k]
            res = linprog(
                c=-w_k,
                A_eq=[np.ones(m)],
                b_eq=[1.0],
                bounds=[(0, 1)] * m,
                method='highs'
            )
            if res.success:
                p_candidates.append(res.x)
            else:
                p = np.zeros(m)
                p[np.argmax(w_k)] = 1.0
                p_candidates.append(p)
        p_candidates = np.array(p_candidates)  # shape (max_K, 5)

        # Assign each accepted contract to closest cluster via kmeans.predict
        assigned_clusters = kmeans.predict(accepted_contracts)

        # Build constraints for costs vector c in R^{max_K}

        # Accepted contracts IR: for each i assigned to k:
        # p_k.dot(contract_i) - c_k ≥ 0 => c_k ≤ p_k.dot(contract_i)
        accepted_rows = []
        accepted_bounds = []
        for idx_i, c_k in zip(accepted_idx, assigned_clusters):
            row = np.zeros(max_K)
            row[c_k] = -1  # -c_k
            b = -np.dot(p_candidates[c_k], contracts[idx_i])
            accepted_rows.append(row)
            accepted_bounds.append(b)
        if accepted_rows:
            accepted_rows = np.array(accepted_rows)
            accepted_bounds = np.array(accepted_bounds)
        else:
            accepted_rows = np.empty((0, max_K))
            accepted_bounds = np.array([])

        # Rejected contracts: agent utility < 0 for all k:
        # p_k.dot(contract_j) - c_k < 0 => c_k > p_k.dot(contract_j)
        # => -c_k < -p_k.dot(contract_j) => -c_k ≤ -p_k.dot(contract_j) - eps (approximate strict)
        rejected_rows = []
        rejected_bounds = []
        for idx_j in rejected_idx:
            c_j = contracts[idx_j]
            for k in range(max_K):
                row = np.zeros(max_K)
                row[k] = -1  # -c_k
                bound = -(np.dot(p_candidates[k], c_j) + eps)
                rejected_rows.append(row)
                rejected_bounds.append(bound)
        if rejected_rows:
            rejected_rows = np.array(rejected_rows)
            rejected_bounds = np.array(rejected_bounds)
        else:
            rejected_rows = np.empty((0, max_K))
            rejected_bounds = np.array([])

        # Combine constraints
        A_ub = np.vstack([accepted_rows, rejected_rows])
        b_ub = np.hstack([accepted_bounds, rejected_bounds])

        # Bounds on costs c_k >= 0
        bounds_c = [(0, None)] * max_K

        # Objective: minimize sum of costs for parsimony
        obj = np.ones(max_K)

        res_cost = linprog(c=obj, A_ub=A_ub, b_ub=b_ub, bounds=bounds_c, method='highs')

        if res_cost.success:
            costs = res_cost.x
            # Validate costs are finite and nonnegative (should be by bounds)
            valid_mask = np.isfinite(costs) & (costs >= 0)
            if not np.any(valid_mask):
                # no valid costs found, fallback
                max_K -= 1
                attempt += 1
                continue
            # Filter out invalid actions if any (unlikely)
            p_candidates = p_candidates[valid_mask]
            costs = costs[valid_mask]

            # Final agent setting: stack p and costs
            agent_setting = np.hstack([p_candidates, costs.reshape(-1, 1)])

            # Normalize p rows to sum 1 and clip negatives (numerical safety)
            for i in range(agent_setting.shape[0]):
                p = agent_setting[i, :m]
                p = np.maximum(p, 0)
                s = p.sum()
                if s <= 0:
                    p = np.ones(m) / m
                else:
                    p /= s
                agent_setting[i, :m] = p

            # Final safety: costs >= 0
            agent_setting[:, -1] = np.maximum(agent_setting[:, -1], 0)

            return agent_setting

        else:
            # infeasible, try fewer clusters for simpler explanation
            max_K -= 1
            attempt += 1

    # Fallback: single uniform action with zero cost
    empirical_counts = np.zeros(m)
    for idx_i in accepted_idx:
        best_outcome = np.argmax(contracts[idx_i])
        empirical_counts[best_outcome] += 1
    if empirical_counts.sum() > 0:
        empirical_p = empirical_counts / empirical_counts.sum()
    else:
        empirical_p = np.ones(m) / m
    return np.hstack([empirical_p.reshape(1, -1), np.array([[0.0]])])
```
