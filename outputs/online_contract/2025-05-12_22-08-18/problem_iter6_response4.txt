```python
import numpy as np
from sklearn.cluster import KMeans
from scipy.optimize import linprog

def agent_solver_v2(v: np.ndarray, content: list[dict]) -> np.ndarray:
    """
    Infer a valid agent setting matrix (n_actions x 6) where each row is:
    [probabilities over 5 outcomes (sum to 1), cost ≥ 0].

    Inputs:
    - v: np.ndarray of shape (5,), principal's reward vector over outcomes.
    - content: list of dicts with keys:
        'Contract': list/array of length 5 (payment vector),
        'Principal Utility': float,
        'Agent Action': 1 (accept) or -1 (reject).

    Returns:
    - agent_setting: np.ndarray shape (n_actions, 6) with each row:
      [p_1,...,p_5, cost], p_i ≥ 0, sum p_i=1, cost ≥ 0.
    """
    np.random.seed(42)
    m = len(v)
    L = len(content)

    # Parse logs
    contracts = np.array([log['Contract'] for log in content], dtype=np.float64)  # (L,m)
    agent_actions = np.array([log['Agent Action'] for log in content], dtype=int)
    principal_utils = np.array([log['Principal Utility'] for log in content], dtype=np.float64)

    accepted_idx = np.where(agent_actions == 1)[0]
    rejected_idx = np.where(agent_actions == -1)[0]

    # If no accepted contracts, fallback trivial uniform action with zero cost
    if len(accepted_idx) == 0:
        uniform_p = np.ones(m) / m
        return np.hstack([uniform_p.reshape(1, -1), np.array([[0.0]])])

    accepted_contracts = contracts[accepted_idx]

    # Adaptive max clusters based on accepted count (min 2, max 8), at most number of accepted contracts
    max_K = min(8, max(2, len(accepted_idx)//10))
    max_K = min(max_K, len(accepted_idx))
    if max_K < 1:
        max_K = 1

    eps = 1e-6  # small margin for strict inequalities
    max_attempts = 8
    attempt = 0

    while attempt < max_attempts and max_K >= 1:
        try:
            # Cluster accepted contracts using kmeans on payment vectors
            if max_K == 1:
                # When cluster count=1, just take mean of accepted contracts
                centers_w = accepted_contracts.mean(axis=0, keepdims=True)
                assigned_clusters = np.zeros(len(accepted_idx), dtype=int)
            else:
                kmeans = KMeans(n_clusters=max_K, random_state=0, n_init=20).fit(accepted_contracts)
                centers_w = kmeans.cluster_centers_  # (max_K, m)
                assigned_clusters = kmeans.predict(accepted_contracts)
        except Exception:
            max_K -= 1
            attempt += 1
            continue

        # Infer p_k for each cluster center w_k by LP: maximize p·w_k s.t p≥0 sum p=1
        p_candidates = np.zeros((max_K, m), dtype=np.float64)
        lp_failed = False
        for k in range(max_K):
            w_k = centers_w[k]
            res = linprog(
                c=-w_k,
                A_eq=[np.ones(m)],
                b_eq=[1.0],
                bounds=[(0, 1)] * m,
                method='highs',
            )
            if not res.success or res.fun is None or np.any(res.x < -1e-10):
                # Fallback: put all mass on max w_k coordinate
                p = np.zeros(m)
                max_idx = np.argmax(w_k)
                p[max_idx] = 1.0
                p_candidates[k] = p
            else:
                p_candidates[k] = res.x.clip(min=0)
                s = p_candidates[k].sum()
                if s <= 1e-12:
                    p_candidates[k] = np.ones(m) / m
                else:
                    p_candidates[k] /= s

        # Build IR constraints (accepted contracts):
        # For each accepted contract i assigned to cluster k:
        # p_k·contract_i - cost_k >= 0  =>  cost_k <= p_k·contract_i
        accepted_rows = []
        accepted_bounds = []
        for idx_i, cluster_k in zip(accepted_idx, assigned_clusters):
            row = np.zeros(max_K, dtype=np.float64)
            row[cluster_k] = -1.0  # -cost_k
            bound = -np.dot(p_candidates[cluster_k], contracts[idx_i])
            accepted_rows.append(row)
            accepted_bounds.append(bound)
        if accepted_rows:
            accepted_rows = np.array(accepted_rows)
            accepted_bounds = np.array(accepted_bounds)
        else:
            accepted_rows = np.empty((0, max_K))
            accepted_bounds = np.array([])

        # Build IC constraints for rejection:
        # For each rejected contract j and each cluster k:
        # p_k·contract_j - cost_k < 0 => cost_k > p_k·contract_j
        # Approximated as:
        # -cost_k <= -p_k·contract_j - eps
        rejected_rows = []
        rejected_bounds = []
        for idx_j in rejected_idx:
            contract_j = contracts[idx_j]
            for k in range(max_K):
                row = np.zeros(max_K, dtype=np.float64)
                row[k] = -1.0  # -cost_k
                bound = -(np.dot(p_candidates[k], contract_j) + eps)
                rejected_rows.append(row)
                rejected_bounds.append(bound)
        if rejected_rows:
            rejected_rows = np.array(rejected_rows)
            rejected_bounds = np.array(rejected_bounds)
        else:
            rejected_rows = np.empty((0, max_K))
            rejected_bounds = np.array([])

        # Combine inequality constraints
        if accepted_rows.size > 0 and rejected_rows.size > 0:
            A_ub = np.vstack([accepted_rows, rejected_rows])
            b_ub = np.hstack([accepted_bounds, rejected_bounds])
        elif accepted_rows.size > 0:
            A_ub = accepted_rows
            b_ub = accepted_bounds
        elif rejected_rows.size > 0:
            A_ub = rejected_rows
            b_ub = rejected_bounds
        else:
            # No constraints => trivial zero costs?
            costs = np.zeros(max_K)
            p_candidates = np.clip(p_candidates, 0, None)
            for i in range(p_candidates.shape[0]):
                p = p_candidates[i]
                s = p.sum()
                p_candidates[i] = p / s if s > 1e-12 else np.ones(m) / m
            agent_setting = np.hstack([p_candidates, costs.reshape(-1, 1)])
            return agent_setting

        # Costs bounds: costs_k ≥ 0
        bounds_costs = [(0, None)] * max_K

        # Objective: minimize sum of costs (parsimonious)
        c_obj = np.ones(max_K, dtype=np.float64)

        res_cost = linprog(
            c=c_obj,
            A_ub=A_ub,
            b_ub=b_ub,
            bounds=bounds_costs,
            method='highs',
        )

        if not res_cost.success or res_cost.x is None:
            # Failed LP solve => reduce cluster count and retry
            max_K -= 1
            attempt += 1
            continue

        costs = res_cost.x

        # Validate costs feasibility
        if np.any(costs < -1e-10) or not np.all(np.isfinite(costs)):
            max_K -= 1
            attempt += 1
            continue

        costs = np.maximum(costs, 0)

        # Normalize p_candidates rows to simplex, clip small negatives
        for i in range(p_candidates.shape[0]):
            p = p_candidates[i]
            p = np.maximum(p, 0)
            s = p.sum()
            if s <= 1e-12:
                p = np.ones(m) / m
            else:
                p /= s
            p_candidates[i] = p

        # Enforce strict rejection constraints by bumping costs if needed
        if len(rejected_idx) > 0:
            slack = 1e-5
            for i in range(len(costs)):
                max_rej_util = max((p_candidates[i] @ contracts[j]) for j in rejected_idx)
                if costs[i] <= max_rej_util:
                    costs[i] = max_rej_util + slack

        # Final output: agent_setting matrix n_actions x (m+1)
        agent_setting = np.hstack([p_candidates, costs.reshape(-1, 1)])

        # Validate all accepted contracts are rationalized by some action (agent utility ≥0)
        def contract_accepted_by_some_action(w_i):
            for p_, c_ in zip(p_candidates, costs):
                if p_ @ w_i - c_ >= -1e-9:
                    return True
            return False

        all_accepted_explained = all(contract_accepted_by_some_action(contracts[i]) for i in accepted_idx)
        if all_accepted_explained:
            return agent_setting
        else:
            # Add exact matching actions for non-explained accepted contracts
            for i in accepted_idx:
                w_i = contracts[i]
                if not contract_accepted_by_some_action(w_i):
                    p_new = np.maximum(w_i, 0)
                    s = p_new.sum()
                    if s <= 1e-12:
                        p_new = np.ones(m) / m
                    else:
                        p_new /= s
                    c_new = p_new @ w_i
                    agent_setting = np.vstack([agent_setting, np.hstack([p_new, c_new])])
            return agent_setting

    # Fallback if no feasible solution found after retries:
    # Use empirical distribution of "best outcomes" from accepted contracts as a single action with zero cost
    outcome_counts = np.zeros(m, dtype=np.float64)
    for idx_i in accepted_idx:
        best_outcome = np.argmax(contracts[idx_i])
        outcome_counts[best_outcome] += 1
    if outcome_counts.sum() > 0:
        empirical_p = outcome_counts / outcome_counts.sum()
    else:
        empirical_p = np.ones(m) / m
    return np.hstack([empirical_p.reshape(1, -1), np.array([[0.0]])])
```
