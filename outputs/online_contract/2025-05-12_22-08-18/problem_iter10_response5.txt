```python
import numpy as np
from sklearn.cluster import AgglomerativeClustering
from scipy.optimize import linprog

def agent_solver_v2(v: np.ndarray, content: list[dict]) -> np.ndarray:
    """
    Improved inference of valid agent setting consistent with historical logs.
    Key enhancements:
    - Weight clustering by principal utility variance (importance weighting)
    - Iterative addition of dummy actions until all accepted contracts rationalized
    - Tighter IR/IC constraints enforcing universal agent rationality and incentive compatibility
    - Final normalization of probabilities guaranteeing simplex conditions

    Args:
        v (np.ndarray): Principal's reward vector over 5 outcomes, shape (5,)
        content (list[dict]): Each dict with keys:
            'Contract' (list or np.ndarray length 5),
            'Principal Utility' (float),
            'Agent Action' (1 or -1)

    Returns:
        np.ndarray: (n_actions x 6) matrix where rows are [p_1,...,p_5, cost],
                    p_i >= 0, sum p_i = 1, cost >= 0
    """

    m = v.size
    L = len(content)

    # Handle empty input: trivial uniform action zero cost
    if L == 0:
        uniform_p = np.ones(m) / m
        return np.hstack([uniform_p.reshape(1, -1), np.array([[0.0]])])

    # Extract arrays
    contracts = np.array([log['Contract'] for log in content], dtype=np.float64)  # (L, m)
    ag_actions = np.array([log['Agent Action'] for log in content], dtype=int)    # (L,)
    p_utils = np.array([log['Principal Utility'] for log in content], dtype=np.float64)  # (L,)

    accepted_ix = np.where(ag_actions == 1)[0]
    rejected_ix = np.where(ag_actions == -1)[0]

    # If no accepted contracts: trivial uniform action zero cost
    if accepted_ix.size == 0:
        uniform_p = np.ones(m) / m
        return np.hstack([uniform_p.reshape(1, -1), np.array([[0.0]])])

    # Prepare accepted contracts and principal utils
    accepted_w = contracts[accepted_ix]  # (num_accepted, m)
    accepted_pu = p_utils[accepted_ix]

    # Normalize accepted contracts to simplex for clustering (avoid zero sums)
    accepted_sum = accepted_w.sum(axis=1, keepdims=True)
    accepted_sum[accepted_sum < 1e-12] = 1.0
    norm_w = accepted_w / accepted_sum

    # Determine adaptive number of clusters:
    n_accepted = accepted_w.shape[0]
    max_clusters = max(1, min(10, n_accepted, int(np.sqrt(n_accepted))))
    clustering = AgglomerativeClustering(n_clusters=max_clusters, linkage='average')
    labels = clustering.fit_predict(norm_w)

    # Weight clustering by principal utility variance (importance)
    # Compute variance of p_utils in each cluster; weight higher variance clusters more
    p_candidates = []
    costs_lb = []

    # Compute global principal utility variance for scaling weights
    global_pu_var = np.var(accepted_pu) if n_accepted > 1 else 0.0
    global_pu_var = max(global_pu_var, 1e-6)  # avoid zero division

    # For each cluster, compute weighted average centroid and cost lower bound
    for c in range(max_clusters):
        mask = (labels == c)
        if not np.any(mask):
            continue
        cluster_idx = accepted_ix[mask]
        cluster_w = contracts[cluster_idx]
        cluster_pu = p_utils[cluster_idx]

        # Weight each accepted contract in cluster by its principal utility's relative variance:
        # weight_i = 1 + ( (pu_i - mean_pu_cluster)^2 / global_pu_var )
        mean_pu_cluster = cluster_pu.mean()
        weights = 1 + ((cluster_pu - mean_pu_cluster) ** 2) / global_pu_var

        # Compute weighted average contract vector p (before projection)
        avg_w = np.average(cluster_w, axis=0, weights=weights)

        # Project to simplex: clip negatives & normalize strictly
        p = np.clip(avg_w, 0, None)
        s = p.sum()
        if s < 1e-12:
            p = np.ones(m) / m
        else:
            p /= s
        p_candidates.append(p)

        # Cost lower bound from accepted contracts in cluster (utility≥0): cost ≤ min_i p @ w_i
        costs_cluster = np.array([p @ contracts[i] for i in cluster_idx])
        min_cost = costs_cluster.min()
        costs_lb.append(min_cost)

    if len(p_candidates) == 0:
        # Defensive fallback uniform zero cost
        uniform_p = np.ones(m) / m
        return np.hstack([uniform_p.reshape(1, -1), np.array([[0.0]])])

    p_candidates = np.array(p_candidates)  # shape (n_actions, m)
    costs_lb = np.array(costs_lb)          # shape (n_actions,)

    # Handle rejected contracts constraints: cost > p @ w_r for all rejected contracts r (strict)
    if rejected_ix.size > 0:
        rejected_w = contracts[rejected_ix]  # (n_rejected, m)
        p_w_rej = p_candidates @ rejected_w.T  # (n_actions, n_rejected)
        c_rej_min = p_w_rej.max(axis=1) + 1e-6  # margin epsilon
    else:
        c_rej_min = np.zeros(len(p_candidates))

    # Initialize costs >= max(lower bound on accepted, rejection constraints)
    costs = np.maximum(costs_lb, c_rej_min)
    costs = np.maximum(costs, 0)

    # Helper: Check if any action rationalizes contract w_i with utility ≥ 0
    def has_action_rationalizing(w_i, p_set, c_set):
        for a in range(len(c_set)):
            if p_set[a] @ w_i - c_set[a] >= -1e-12:
                return True
        return False

    # Iteratively add dummy actions for unexplained accepted contracts until convergence or max iter
    max_dummy_iters = 10
    unchanged_iters = 0
    prev_n_actions = len(costs)

    for _ in range(max_dummy_iters):
        unexplained = [i for i in accepted_ix if not has_action_rationalizing(contracts[i], p_candidates, costs)]
        if not unexplained:
            break  # all explained

        # Add one dummy action per unexplained contract
        for i in unexplained:
            w_i = contracts[i]
            p_new = np.clip(w_i, 0, None)
            s = p_new.sum()
            if s < 1e-12:
                p_new = np.ones(m) / m
            else:
                p_new /= s
            c_new = p_new @ w_i  # cost to make agent utility exactly zero on contract i
            p_candidates = np.vstack([p_candidates, p_new])
            costs = np.append(costs, c_new)

        # Enforce rejection constraints for new actions
        if rejected_ix.size > 0:
            p_w_rej = p_candidates @ contracts[rejected_ix].T  # (n_actions, n_rejected)
            for a in range(len(costs)):
                max_rej_util = p_w_rej[a].max()
                if costs[a] < max_rej_util + 1e-8:
                    costs[a] = max_rej_util + 1e-4

        # Check for convergence (no new actions added or no growth)
        if len(costs) == prev_n_actions:
            unchanged_iters += 1
            if unchanged_iters >= 2:
                break
        else:
            prev_n_actions = len(costs)
            unchanged_iters = 0

    n_actions = len(costs)

    # Formulate LP to refine costs ensuring:
    # - For every accepted contract i: ∃ action a s.t. p_a @ w_i - cost_a ≥ 0
    #   Implemented as: for each accepted i, min_a (cost_a - p_a@w_i) ≤ 0
    #   This is a disjunctive constraint, approximated conservatively by:
    #   cost_a ≤ p_a @ w_i for ALL accepted i and actions a (overly strong but safe)
    #
    # - For every rejected contract r and every action a: cost_a ≥ p_a @ w_r + ε
    # - cost_a ≥ 0

    epsilon = 1e-5

    # Construct inequalities A_ub x ≤ b_ub
    # For rejections:
    #   -cost_a ≤ - (p_a @ w_r + ε)  => row with -1 at a-th pos, rhs = -val
    A_ub = []
    b_ub = []

    for a in range(n_actions):
        for r in rejected_ix:
            val = p_candidates[a] @ contracts[r] + epsilon
            row = np.zeros(n_actions)
            row[a] = -1
            A_ub.append(row)
            b_ub.append(-val)

    # For accepted contracts IR constraints approximated conservatively:
    # cost_a ≤ p_a @ w_i  => cost_a - p_a @ w_i ≤ 0  => row with +1 at a-th pos, rhs = p_a @ w_i

    for a in range(n_actions):
        for i in accepted_ix:
            val = p_candidates[a] @ contracts[i]
            row = np.zeros(n_actions)
            row[a] = 1
            A_ub.append(row)
            b_ub.append(val)

    A_ub = np.array(A_ub) if A_ub else None
    b_ub = np.array(b_ub) if b_ub else None

    bounds = [(0, None)] * n_actions

    # Objective: minimize L1 norm of costs (sum costs) to keep parsimonious
    c_obj = np.ones(n_actions)

    res = linprog(c=c_obj, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')

    if res.success and res.x is not None and np.all(np.isfinite(res.x)):
        refined_costs = np.maximum(res.x, 0)
        # Validate all accepted contracts have at least one rationalizing action with refined costs
        all_accepted_explained = True
        for i in accepted_ix:
            w_i = contracts[i]
            if not has_action_rationalizing(w_i, p_candidates, refined_costs):
                all_accepted_explained = False
                break
        if all_accepted_explained:
            costs = refined_costs
        # else fallback to previous (conservative) costs
    # else fallback to previous costs

    # Final normalization of probability vectors to simplex strictly
    p_candidates = np.clip(p_candidates, 0, None)
    sums = p_candidates.sum(axis=1, keepdims=True)
    sums[sums < 1e-12] = 1.0
    p_candidates /= sums

    agent_setting = np.hstack([p_candidates, costs.reshape(-1, 1)])
    return agent_setting
```
