```python
import numpy as np
from sklearn.cluster import AgglomerativeClustering
from scipy.optimize import linprog

def agent_solver_v2(v: np.ndarray, content: list[dict]) -> np.ndarray:
    """
    Infer a valid agent setting (actions = distributions + cost) consistent with historical contract logs,
    enforcing global IR/IC constraints via LP, adaptively clustering with weighted centroids
    emphasizing principal utility, adding minimal dummy actions only for unexplained contracts,
    refining costs iteratively using rejection slacks, and precise normalization.

    Params:
        v (np.ndarray): Principal's value vector (length 5)
        content (list[dict]): each dict has keys: 'Contract' (list of 5),
                              'Principal Utility' (float),
                              'Agent Action' (1 or -1)
    Returns:
        np.ndarray: n_actions x 6 (5 probabilities + 1 cost)
    """
    m_outcomes = v.size
    L = len(content)

    contracts = np.array([log['Contract'] for log in content])  # (L,5)
    ag_actions = np.array([log['Agent Action'] for log in content])  # (L,)
    p_util = np.array([log['Principal Utility'] for log in content])  # (L,)

    accepted_ix = np.where(ag_actions == 1)[0]
    rejected_ix = np.where(ag_actions == -1)[0]

    # If no accepted contracts, return trivial uniform action with zero cost
    if accepted_ix.size == 0:
        return np.hstack([np.ones((1, m_outcomes)) / m_outcomes, np.array([[0]])])

    accepted_w = contracts[accepted_ix]

    # Normalize accepted contracts to simplex for clustering
    norm_w = accepted_w / (accepted_w.sum(axis=1, keepdims=True) + 1e-12)

    # Adaptive cluster count: min(10, #accepted, ceil(sqrt(#accepted)))
    n_max_actions = max(1, min(10, int(np.ceil(np.sqrt(len(accepted_ix)))), len(accepted_ix)))

    clustering = AgglomerativeClustering(n_clusters=n_max_actions, linkage='average')
    labels = clustering.fit_predict(norm_w)

    p_candidates = []
    costs_lower_bound = []

    # Build initial candidates by weighted principal utility averaging in clusters
    for c in range(n_max_actions):
        cluster_idx = accepted_ix[labels == c]
        if cluster_idx.size == 0:
            continue
        cluster_w = contracts[cluster_idx]

        # Weights favoring better principal utilities (shifted and scaled)
        weights = p_util[cluster_idx] - p_util[cluster_idx].min() + 1
        avg_w = np.average(cluster_w, axis=0, weights=weights)
        p = np.clip(avg_w, 0, None)
        s = p.sum()
        if s < 1e-12:
            p = np.ones(m_outcomes) / m_outcomes
        else:
            p = p / s

        p_candidates.append(p)

        # Cost lower bound: max over accepted contracts in cluster of (p @ w_i - 0)
        # Agent utility >=0 => cost <= p @ w_i for acceptance
        costs_cluster = np.array([p @ contracts[i] for i in cluster_idx])
        min_cost = costs_cluster.min()  # minimal to ensure IR for cluster
        costs_lower_bound.append(min_cost)

    p_candidates = np.array(p_candidates)
    costs_lower_bound = np.array(costs_lower_bound)

    # Handle rejected contracts: agent utility < 0 for all inferred actions
    if rejected_ix.size > 0:
        reject_contracts = contracts[rejected_ix]  # (#rej,5)
        # Shape (n_actions, #rej)
        p_w_rej = p_candidates @ reject_contracts.T
        # Each action's cost must be > max rejected contract utility to reject all
        c_rej_min = p_w_rej.max(axis=1) + 1e-6
    else:
        c_rej_min = np.zeros(len(p_candidates))

    # Preliminary costs lower bounded by acceptance and rejection constraints
    costs = np.maximum(costs_lower_bound, c_rej_min)
    costs = np.maximum(costs, 0)

    # Construct global LP to refine costs enforcing IR/IC constraints for accepted contracts
    # Variables: costs for each action
    # Constraints:
    # 1) For accepted contracts i: ∃ a s.t. p_a @ w_i - cost_a >= 0 (utility ≥ 0)
    # 2) For rejected contracts r and all actions a: p_a @ w_r - cost_a < 0 (utility < 0)
    # We enforce 1) via introducing binary assignment variables fails LP, so approximate by:
    # For each accepted i: max_a (p_a @ w_i - cost_a) >= 0
    # For each rejected r,a: p_a @ w_r - cost_a <= -margin < 0
    # We linearize by approximating costs with LP minimizing sum costs given constraints.

    # Build matrix of p_a @ w_i for all a, i (accepted)
    p_w_acc = p_candidates @ contracts[accepted_ix].T  # shape (n_actions, n_accepted)

    # Build matrix of p_a @ w_r for all a, r (rejected)
    if rejected_ix.size > 0:
        p_w_rej = p_candidates @ contracts[rejected_ix].T  # shape (n_actions, n_rejected)
    else:
        p_w_rej = np.empty((len(p_candidates), 0))

    n_actions = len(p_candidates)
    n_accepted = len(accepted_ix)
    n_rejected = len(rejected_ix)

    # LP variables: costs vector c_a (length n_actions)
    # Objective: minimize sum of costs (or zero vector to just find feasible)
    c_obj = np.ones(n_actions)

    # Constraints:

    # 1) For each accepted contract i:
    # max_a (p_a @ w_i - c_a) >= 0  <=>  exists a with c_a <= p_a @ w_i
    # We enforce: for each i, min over a of c_a <= max_a p_a @ w_i (since c_a non-negative)
    # But LP can't handle max or min directly, so we create for each i constraints:
    # There exists a so that c_a <= p_a @ w_i
    # We encode by auxiliary binary variables but here approximate by:
    # For each i and each a: c_a <= p_a @ w_i + M*(1 - z_ai), with z_ai binary
    # To avoid complexity, approximate by:
    # For each i: min_a c_a <= max_a p_a @ w_i
    # So for each i and a: c_a <= p_a @ w_i + slack_i,a
    # Then minimize sum slack_i,a and costs, but we'll just enforce c_a <= p_a @ w_i + big margin
    # Instead, we'll enforce for each i, at least one a fulfills: c_a <= p_a @ w_i

    # To approximate, enforce:
    # For each i and a: c_a <= p_a @ w_i + big_margin
    # And for each i: min_a c_a <= max_a p_a @ w_i
    # The first constraints guarantee costs don't exceed p_a @ w_i by too much.

    big_margin = 1e2

    A_ub = []
    b_ub = []

    # Constraint: For each a and each rejected contract r:
    # p_a @ w_r - c_a < 0  =>  c_a > p_a @ w_r
    # In LP form: c_a - p_a @ w_r >= margin > 0  => -c_a + p_a @ w_r <= -margin
    # We'll enforce c_a >= p_a @ w_r + margin
    margin = 1e-4
    for a in range(n_actions):
        for r in range(n_rejected):
            row = np.zeros(n_actions)
            row[a] = -1  # -c_a
            A_ub.append(row)
            b_ub.append(-p_w_rej[a, r] - margin)  # <= -p_a@w_r - margin

    # Constraint: costs >= 0
    # This will be imposed as bounds in linprog

    # Constraint: for each accepted i and each a: c_a <= p_a @ w_i + big_margin
    # => c_a - p_a @ w_i <= big_margin
    for a in range(n_actions):
        for i_acc in range(n_accepted):
            row = np.zeros(n_actions)
            row[a] = 1  # c_a
            A_ub.append(row)
            b_ub.append(p_w_acc[a, i_acc] + big_margin)

    A_ub = np.array(A_ub)
    b_ub = np.array(b_ub)

    bounds = [(0, None) for _ in range(n_actions)]

    # Solve LP minimizing sum costs subject to constraints
    res = linprog(c=c_obj, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')

    if res.success:
        costs = res.x
    else:
        # fallback: use previous costs, add small margin for rejected
        costs = np.maximum(costs, 0)
        if rejected_ix.size > 0:
            for a in range(n_actions):
                max_rej = p_w_rej[a].max() if n_rejected > 0 else 0
                if costs[a] <= max_rej + margin:
                    costs[a] = max_rej + 10 * margin

    # Validate accepted contracts: each must be rationalized by some action (utility ≥ -epsilon)
    def valid_action_for_contract(w_i):
        for a, (p, c) in enumerate(zip(p_candidates, costs)):
            util = p @ w_i - c
            if util >= -1e-10:
                return a
        return None

    # Add minimal dummy actions for unexplained accepted contracts
    for i in accepted_ix:
        w_i = contracts[i]
        if valid_action_for_contract(w_i) is None:
            p_new = w_i.copy()
            s = p_new.sum()
            if s < 1e-12:
                p_new = np.ones(m_outcomes) / m_outcomes
            else:
                p_new = p_new / s
            c_new = p_new @ w_i
            p_candidates = np.vstack([p_candidates, p_new])
            costs = np.append(costs, c_new)

    # Iteratively refine costs to satisfy rejection constraints strictly
    # Recompute p_w_rej with updated actions
    n_actions = len(p_candidates)
    if rejected_ix.size > 0:
        reject_contracts = contracts[rejected_ix]
        p_w_rej = p_candidates @ reject_contracts.T
        for _ in range(5):  # fixed iterations
            updated = False
            for a in range(n_actions):
                max_rej_util = p_w_rej[a].max() if n_rejected > 0 else -np.inf
                if costs[a] < max_rej_util + 1e-8:
                    costs[a] = max_rej_util + 1e-4
                    updated = True
            if not updated:
                break

    # Final normalization of probabilities
    p_candidates = np.clip(p_candidates, 0, None)
    p_sums = p_candidates.sum(axis=1, keepdims=True)
    zero_sum = p_sums < 1e-12
    p_candidates[zero_sum[:, 0], :] = 1.0 / m_outcomes
    p_sums[zero_sum] = 1.0
    p_candidates /= p_sums

    # Assemble final agent setting matrix (n_actions x 6)
    agent_setting = np.hstack([p_candidates, costs[:, None]])

    return agent_setting
```
