```python
import numpy as np
from scipy.optimize import linprog, minimize
from sklearn.cluster import KMeans

def agent_solver(v: np.ndarray, content: list[dict]) -> np.ndarray:
    """
    Infer a valid agent setting (probabilities over outcomes + cost) given:
    - v: principal's reward vector over outcomes (length 5)
    - content: list of logs, each dict with keys 'Contract', 'Principal Utility', 'Agent Action'

    Returns:
    - agent_setting: n x 6 array with rows: [p_1,...,p_5, cost], where p_i >=0, sum p_i =1, cost >=0.
    """
    np.random.seed(42)
    m = len(v)  # number of outcomes = 5
    L = len(content)

    # Parse logs into arrays for faster indexing:
    contracts = np.array([log['Contract'] for log in content])    # L x 5
    principal_utils = np.array([log['Principal Utility'] for log in content])  # L,
    agent_actions = np.array([log['Agent Action'] for log in content])  # L,

    # We seek to infer a discrete set of agent actions with:
    # - a probability distribution p over outcomes (sum=1,p≥0)
    # - a cost c≥0
    # Let the number of agent actions, K, be adaptive.
    # Set K to be the number of distinct patterns needed to explain data; start small and increase if needed.

    # Step 1: Extract accepted contracts
    accepted_idx = np.where(agent_actions == 1)[0]
    accepted_contracts = contracts[accepted_idx]
    accepted_pr_utils = principal_utils[accepted_idx]

    # Step 2: Cluster accepted contracts by the offered wages to detect meaningful output distributions
    # We guess K adaptively using gap heuristic or fixed max
    max_K = min(8, max(2, len(accepted_idx)//10))
    if max_K < 2:
        max_K = 2

    # Cluster the accepted contracts' payments (Lx5) -> find K clusters
    kmeans = KMeans(n_clusters=max_K, random_state=0, n_init=20).fit(accepted_contracts)
    centers_w = kmeans.cluster_centers_  # max_K x 5

    # Step 3: Candidate agent actions initialization:
    # Infer probability vectors from each cluster center wage vector:
    # For given wage w and agent action with distribution p and cost c,
    # acceptance implies p∙w - c >= 0 (IR constraint)
    # principal utility might be known but doesn't define p strictly.

    # We want to find p (distribution) and c≥0 for each action such that:
    # For accepted contracts with index i assigned to cluster k,
    # expected agent utility: p_k.dot(contract_i) - c_k ≥ 0
    # For rejected contracts: max_k (p_k.dot(contract_i) - c_k) < 0

    # Step 4: Use Linear Programming to find p_k for each cluster center wage vector.
    # We want p*centers_w[k] minimal cost c_k so that p is probability distribution.

    # mini function: given wage vector w_k, find p_k with p_k∙w_k maximal (maximize agent utility under IR)
    # Or equivalently, simply take p_k as 1-hot vector on index argmax w_k for maximal agent utility.
    # But more nuanced is to solve: maximize p @ w_k s.t p≥0, sum p=1.

    # For diversity, solve:
    # maximize p @ w_k subject to p≥0, sum p=1 using linprog bounds and objective

    # Actually, linprog by default minimizes. So minimize -p@w_k

    p_candidates = []
    for k in range(max_K):
        w_k = centers_w[k]
        res = linprog(c=-w_k, A_eq=[np.ones(m)], b_eq=[1.0], bounds=[(0,1)]*m, method='highs')
        if res.success:
            p_candidates.append(res.x)
        else:
            # Fallback to 1-hot at max index
            p = np.zeros(m)
            p[np.argmax(w_k)] = 1.0
            p_candidates.append(p)
    p_candidates = np.array(p_candidates)  # max_K x 5

    # Step 5: Given p_candidates, formulate constraints on costs c_k
    # We construct linear constraints on cost c (variables c_0 .. c_{K-1})

    # For each accepted contract i assigned cluster k:
    # agent utility: p_k @ contract_i - c_k ≥ 0  =>  c_k ≤ p_k @ contract_i

    # For each rejected contract j:
    # For all k, p_k @ contract_j - c_k < 0 => c_k > p_k @ contract_j

    # Since strict inequalities are practically approximated with ≥ epsilon

    # Step 6: Assign each accepted contract to closest cluster by Euclidean distance on wage vector
    assigned_clusters = kmeans.predict(accepted_contracts)  # len accepted_idx

    # Variable c_k: costs of agent actions (K, shape)
    # Build constraint matrices:

    # Inequalities c_k ≤ p_k @ contract_i for accepted logs assigned k
    # So for accepted contract i assigned to cluster k:
    # -c_k ≤ - p_k @ contract_i

    # Construct inequality matrices for all accepted contracts
    # Variables: costs c vector length K

    # For accepted constraints: matrix A_ub * c ≤ b_ub
    # For each accepted contract i assigned k:
    # A_ub row = zeros except -1 at position k
    # b_ub = - p_k @ contract_i

    accepted_rows = []
    accepted_bounds = []
    for idx_i, c_k in zip(accepted_idx, assigned_clusters):
        row = np.zeros(max_K)
        row[c_k] = -1
        p_k = p_candidates[c_k]
        b = -np.dot(p_k, contracts[idx_i])
        accepted_rows.append(row)
        accepted_bounds.append(b)
    accepted_rows = np.array(accepted_rows)
    accepted_bounds = np.array(accepted_bounds)

    # For rejected logs, agent utility <0 for all k => p_k.dot(contract_j) - c_k < 0 =>
    # c_k > p_k @ contract_j
    # We write as c_k ≥ p_k @ contract_j + eps (eps small positive)
    # Inequality format: -c_k ≤ - (p_k@contract_j + eps)

    rejected_idx = np.where(agent_actions == -1)[0]
    rejected_rows = []
    rejected_bounds = []
    eps = 1e-5
    for idx_j in rejected_idx:
        c_j = contracts[idx_j]
        for k in range(max_K):
            row = np.zeros(max_K)
            row[k] = 1
            # Will convert to upper bound as -c_k ≤ - (p_k@contract_j + eps)
            rejected_rows.append(-row)  # -c_k
            rejected_bounds.append(-(np.dot(p_candidates[k], c_j) + eps))
    if rejected_rows:
        rejected_rows = np.array(rejected_rows)
        rejected_bounds = np.array(rejected_bounds)
    else:
        rejected_rows = np.empty((0, max_K))
        rejected_bounds = np.array([])

    # Also costs c_k ≥ 0
    bounds_c = [(0, None)] * max_K

    # Assemble all inequalities:
    A_ub = np.vstack([accepted_rows, rejected_rows])
    b_ub = np.hstack([accepted_bounds, rejected_bounds])

    # Step 7: Solve linear feasibility problem on c_k costs
    # Solve min sum(c_k) s.t A_ub c ≤ b_ub, c≥0 to find costs that meet constraints
    # If infeasible, reduce K or fallback.

    obj = np.ones(max_K)
    feas_res = linprog(c=obj, A_ub=A_ub, b_ub=b_ub, bounds=bounds_c, method='highs')

    # If infeasible or error, try reducing number of clusters
    attempt = 0
    while not feas_res.success and max_K > 1 and attempt < 3:
        max_K -= 1
        kmeans = KMeans(n_clusters=max_K, random_state=0, n_init=20).fit(accepted_contracts)
        centers_w = kmeans.cluster_centers_

        p_candidates = []
        for k in range(max_K):
            w_k = centers_w[k]
            res = linprog(c=-w_k, A_eq=[np.ones(m)], b_eq=[1.0], bounds=[(0,1)]*m, method='highs')
            if res.success:
                p_candidates.append(res.x)
            else:
                p = np.zeros(m)
                p[np.argmax(w_k)] = 1.0
                p_candidates.append(p)
        p_candidates = np.array(p_candidates)

        assigned_clusters = kmeans.predict(accepted_contracts)

        accepted_rows = []
        accepted_bounds = []
        for idx_i, c_k in zip(accepted_idx, assigned_clusters):
            row = np.zeros(max_K)
            row[c_k] = -1
            p_k = p_candidates[c_k]
            b = -np.dot(p_k, contracts[idx_i])
            accepted_rows.append(row)
            accepted_bounds.append(b)
        accepted_rows = np.array(accepted_rows)
        accepted_bounds = np.array(accepted_bounds)

        rejected_rows = []
        rejected_bounds = []
        for idx_j in rejected_idx:
            c_j = contracts[idx_j]
            for k in range(max_K):
                row = np.zeros(max_K)
                row[k] = 1
                rejected_rows.append(-row)
                rejected_bounds.append(-(np.dot(p_candidates[k], c_j) + eps))
        if rejected_rows:
            rejected_rows = np.array(rejected_rows)
            rejected_bounds = np.array(rejected_bounds)
        else:
            rejected_rows = np.empty((0, max_K))
            rejected_bounds = np.array([])

        bounds_c = [(0, None)] * max_K

        A_ub = np.vstack([accepted_rows, rejected_rows])
        b_ub = np.hstack([accepted_bounds, rejected_bounds])

        obj = np.ones(max_K)
        feas_res = linprog(c=obj, A_ub=A_ub, b_ub=b_ub, bounds=bounds_c, method='highs')
        attempt += 1

    if not feas_res.success:
        # As fallback, create one action with empirical best distribution and zero cost
        empirical_p = np.zeros(m)
        counts = np.zeros(m)
        for idx_i in accepted_idx:
            best_outcome = np.argmax(contracts[idx_i])
            counts[best_outcome] += 1
        if counts.sum() > 0:
            empirical_p = counts / counts.sum()
        else:
            empirical_p = np.ones(m) / m
        return np.hstack([empirical_p.reshape(1, -1), np.zeros((1,1))])

    costs = feas_res.x

    # Step 8: Validate IR and IC constraints with found p, c for safety
    # Remove actions with cost > huge or NaN
    valid_mask = np.isfinite(costs) & (costs >= 0)
    p_candidates = p_candidates[valid_mask]
    costs = costs[valid_mask]
    if len(costs) == 0:
        # fallback trivial
        empirical_p = np.ones(m) / m
        return np.hstack([empirical_p.reshape(1, -1), np.zeros((1,1))])

    agent_setting = np.hstack([p_candidates, costs.reshape(-1,1)])
    # Normalize p just in case numerics
    for i, row in enumerate(agent_setting):
        p = row[:m]
        p = np.maximum(p, 0)
        p_sum = p.sum()
        if p_sum <= 0:
            p = np.ones(m)/m
        else:
            p = p / p_sum
        agent_setting[i,:m] = p

    return agent_setting
```
