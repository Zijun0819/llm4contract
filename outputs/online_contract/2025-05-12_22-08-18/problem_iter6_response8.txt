```python
import numpy as np
from sklearn.cluster import AgglomerativeClustering

def agent_solver_v2(v: np.ndarray, content: list[dict]) -> np.ndarray:
    """
    Infer a valid agent setting (actions = distributions + cost)
    consistent with historical contract logs. Improvements:
    - Iterative clustering stability with silhouette-like heuristic
    - Stricter IR/IC margins for acceptance/rejection
    - Dummy actions for unexplained accepted contracts
    - Iterative cost refinement for robust rejection handling
    - Projection to simplex for outcome distributions
    - Prune near-zero clusters for parsimony

    Params:
        v (np.ndarray): Principal's value vector (length 5)
        content (list[dict]): each dict has keys:
            'Contract' (list of 5 floats),
            'Principal Utility' (float),
            'Agent Action' (1 or -1)

    Returns:
        np.ndarray: n_actions x 6 (5 probabilities + 1 cost)
    """
    # Utilities
    def proj_simplex(y):
        # Project vector y onto probability simplex (nonnegative, sum=1)
        # Algorithm from [Duchi et al 2008]
        if np.all(y >= 0) and abs(y.sum() - 1) < 1e-12:
            return y.copy()
        m = y.size
        u = np.sort(y)[::-1]
        cssv = np.cumsum(u) - 1
        ind = np.arange(m) + 1
        cond = u - cssv / ind > 0
        rho = ind[cond][-1]
        theta = cssv[cond][-1] / rho
        return np.maximum(y - theta, 0)

    m_outcomes = v.size
    L = len(content)

    contracts = np.array([log['Contract'] for log in content])  # shape (L,5)
    ag_actions = np.array([log['Agent Action'] for log in content])  # (L,)
    p_util = np.array([log['Principal Utility'] for log in content])  # (L,)

    accepted_ix = np.where(ag_actions == 1)[0]
    rejected_ix = np.where(ag_actions == -1)[0]

    # If no accepted contracts, trivial uniform action with zero cost
    if accepted_ix.size == 0:
        uniform_p = np.ones(m_outcomes) / m_outcomes
        return np.hstack([uniform_p.reshape(1, -1), np.zeros((1,1))])

    accepted_w = contracts[accepted_ix]

    # Normalize accepted contracts to avoid scale bias in clustering
    norm_w = accepted_w / (accepted_w.sum(axis=1, keepdims=True) + 1e-12)

    max_clusters_upper = min(10, len(accepted_ix), max(1, int(np.sqrt(len(accepted_ix)))))
    max_clusters_lower = 1

    def cluster_and_centroids(nc):
        if nc == 1:
            p_mean = norm_w.mean(axis=0)
            p_proj = proj_simplex(p_mean)
            return np.array([p_proj])
        clustering = AgglomerativeClustering(n_clusters=nc, linkage='average')
        labels = clustering.fit_predict(norm_w)
        p_list = []
        for c in range(nc):
            cluster_mask = (labels == c)
            if not np.any(cluster_mask):
                continue
            cluster_idx = np.where(cluster_mask)[0]
            cluster_w = accepted_w[cluster_idx]
            weights = p_util[accepted_ix][cluster_idx]
            weights = weights - weights.min() + 1.0  # Shift to positive weights
            avg_w = np.average(cluster_w, axis=0, weights=weights)
            p_proj = proj_simplex(avg_w)
            p_list.append(p_proj)
        if len(p_list) == 0:
            # fallback uniform single cluster
            return np.array([np.ones(m_outcomes) / m_outcomes])
        return np.array(p_list)

    # Stability measure: average min pairwise l2 distance between cluster sets
    def cluster_stability(p_old, p_new):
        if p_old.shape[0] == 0 or p_new.shape[0] == 0:
            return np.inf
        dists = []
        for p_o in p_old:
            dists.append(np.min(np.linalg.norm(p_new - p_o, axis=1)))
        return np.mean(dists)

    chosen_p_candidates = None
    prev_p_candidates = np.empty((0,m_outcomes))
    tol_stability = 1e-2

    # Attempt clustering from max down to min clusters, pick most parsimonious stable
    for nc in range(max_clusters_upper, max_clusters_lower - 1, -1):
        p_candidates = cluster_and_centroids(nc)
        # Prune near-duplicates by merging clusters closer than 1e-3
        to_keep = []
        for i, p_c in enumerate(p_candidates):
            if all(np.linalg.norm(p_c - p_candidates[j]) > 1e-3 for j in to_keep):
                to_keep.append(i)
        p_candidates = p_candidates[to_keep]

        if prev_p_candidates.shape[0] > 0:
            stability = cluster_stability(prev_p_candidates, p_candidates)
            if stability < tol_stability:
                chosen_p_candidates = p_candidates
                break
        prev_p_candidates = p_candidates
    if chosen_p_candidates is None:
        chosen_p_candidates = prev_p_candidates
    p_candidates = chosen_p_candidates

    n_actions = p_candidates.shape[0]

    # Compute cost lower bounds from accepted contracts (agent utility >=0)
    costs_lower_bound = np.full(n_actions, -np.inf)
    for a in range(n_actions):
        p = p_candidates[a]
        # Agent utility = p @ w_i - cost >= 0 => cost <= p @ w_i
        accepted_utils = np.array([p @ accepted_w[i] for i in range(len(accepted_w))])
        costs_lower_bound[a] = accepted_utils.min()

    # For rejected contracts, agent utility < 0 for all actions => cost > max p @ w_i
    if rejected_ix.size > 0:
        reject_w = contracts[rejected_ix]
        reject_vals = p_candidates @ reject_w.T  # shape (n_actions, #rejected)
        rejection_bounds = reject_vals.max(axis=1) + 1e-5  # small margin for strictness
    else:
        rejection_bounds = np.zeros(n_actions)

    # Initial costs respect both constraints nonnegative
    costs = np.maximum(costs_lower_bound, rejection_bounds)
    costs = np.maximum(costs, 0)

    # Helper: check if accepted contract w_i explained by some action
    def action_explains(w_i, eps=1e-9):
        for a, (p, c) in enumerate(zip(p_candidates, costs)):
            if (p @ w_i - c) >= -eps:
                return True
        return False

    # Add dummy actions for accepted contracts unexplained by current actions
    unexplained_idx = [i for i in range(len(accepted_w)) if not action_explains(accepted_w[i])]
    for i in unexplained_idx:
        w_i = accepted_w[i]
        p_new = proj_simplex(w_i)
        c_new = p_new @ w_i
        p_candidates = np.vstack([p_candidates, p_new])
        costs = np.append(costs, c_new)

    # Update n_actions after augmentation
    n_actions = p_candidates.shape[0]

    # Iteratively refine costs to satisfy rejection and acceptance constraints
    max_iter = 50
    tol_cost = 1e-7

    if rejected_ix.size > 0:
        reject_w = contracts[rejected_ix]
    else:
        reject_w = None

    for _ in range(max_iter):
        costs_prev = costs.copy()
        # Rejection constraints: cost > max p @ w for rejected contracts
        if reject_w is not None:
            pwr = p_candidates @ reject_w.T  # (n_actions, #reject)
            max_rej = pwr.max(axis=1)
            costs = np.maximum(costs, max_rej + 1e-5)

        # Acceptance constraints: cost <= min p @ w for accepted contracts rationalized by action
        for a in range(n_actions):
            p = p_candidates[a]
            # For accepted contracts, agent utility >=0 => cost <= p @ w_i
            # We only enforce that cost doesn't exceed minimal p @ w_i in accepted contracts that this action can explain
            # Accepted contracts explained by action: p@w_i - cost >= 0 => cost <= p@w_i
            # But at least should not be larger than minimal p@w_i over all accepted contracts (a relaxed condition)
            costs[a] = max(costs[a], 0)  # costs nonnegative
            costs[a] = min(costs[a], np.min(p @ accepted_w.T))  # cannot exceed minimal p@w_i

        # Costs must be consistent with IR/IC: also >= lower bounds from accepted contracts and rejection
        costs = np.maximum(costs, costs_lower_bound)
        costs = np.maximum(costs, rejection_bounds)
        costs = np.maximum(costs, 0)

        # Check convergence
        if np.max(np.abs(costs - costs_prev)) < tol_cost:
            break

    # Final projection of p_candidates on simplex to fix numerical drift
    for a in range(n_actions):
        p_candidates[a] = proj_simplex(p_candidates[a])

    agent_setting = np.hstack([p_candidates, costs.reshape(-1,1)])
    return agent_setting
```
