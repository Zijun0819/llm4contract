```python
import numpy as np
import pandas as pd
from sklearn.cluster import AgglomerativeClustering
from sklearn.metrics import silhouette_score
from scipy.optimize import linprog
from sklearn.metrics.pairwise import cosine_similarity

def agent_solver_v2(v: np.ndarray, content: list[dict]) -> np.ndarray:
    """
    Infer a valid agent setting (probability distributions over outcomes + costs)
    explaining the historical interaction logs between principal and agent,
    by clustering accepted logs' inferred outcome distributions and inferring costs
    to satisfy IR and IC constraints for accepted and rejected contracts.

    Uses hierarchical clustering with adaptive cluster number selection via silhouette score,
    assigns rejected logs constraints in LP to refine costs, and enforces strict IR/IC constraints.

    Args:
        v (np.ndarray): Principal's reward vector for 5 outcomes, shape (5,)
        content (list[dict]): Each dict contains:
            - 'Contract': 5-dim payment vector,
            - 'Principal Utility': principal utility under contract,
            - 'Agent Action': 1 for accept, -1 for reject.

    Returns:
        np.ndarray: n x 6 matrix: first 5 cols are outcome probabilities (sum=1),
                    last column is agent cost (â‰¥0).
    """
    m_outcomes = v.shape[0]
    logs_df = pd.DataFrame(content)
    accepted = logs_df[logs_df['Agent Action'] == 1].reset_index(drop=True)
    rejected = logs_df[logs_df['Agent Action'] == -1].reset_index(drop=True)

    # If no accepted contracts, return trivial agent with uniform dist and zero cost
    if accepted.empty:
        return np.hstack([np.ones((1, m_outcomes)) / m_outcomes, np.zeros((1, 1))])

    # Step 1: Infer p for each accepted contract by LP
    def infer_p_for_log(w, u_p):
        # variables: p (length m_outcomes)
        # constraints:
        #   sum p = 1
        #   p @ (v - w) = u_p
        # bounds: p_i in [0,1]
        # objective: maximize p @ w (agent expected payment)
        c_obj = -np.array(w)
        A_eq = [np.ones(m_outcomes), v - np.array(w)]
        b_eq = [1.0, u_p]
        bounds = [(0, 1) for _ in range(m_outcomes)]
        res = linprog(c=c_obj, A_eq=A_eq, b_eq=b_eq, bounds=bounds, method='highs')
        if res.success:
            p = res.x
            p = np.clip(p, 0, None)
            s = p.sum()
            if s > 0:
                p /= s
            else:
                p = np.ones(m_outcomes) / m_outcomes
            return p
        else:
            return np.ones(m_outcomes) / m_outcomes

    p_list = [infer_p_for_log(row['Contract'], row['Principal Utility']) for _, row in accepted.iterrows()]
    p_array = np.vstack(p_list)  # shape (n_accept, m_outcomes)

    # Step 2: Adaptive hierarchical clustering with silhouette score to select number of clusters
    max_clusters = min(10, len(p_array))  # max clusters capped at 10 or number of samples
    best_n_clusters = 1
    best_sil = -1
    best_labels = None

    # Use cosine distance (1 - cosine similarity) as metric
    # AgglomerativeClustering uses affinity='precomputed' or 'cosine' in sklearn >=0.22
    # Since 'cosine' affinity is deprecated, we compute distance matrix manually
    cos_sim = cosine_similarity(p_array)
    cos_dist = 1 - cos_sim  # distance matrix

    for n_clusters in range(2, max_clusters + 1):
        # Agglomerative clustering with precomputed distance matrix
        clustering = AgglomerativeClustering(n_clusters=n_clusters, affinity='precomputed', linkage='average')
        labels = clustering.fit_predict(cos_dist)
        # silhouette_score requires distance metric, use 'precomputed' with cos_dist
        try:
            sil = silhouette_score(p_array, labels, metric='cosine')
            if sil > best_sil:
                best_sil = sil
                best_n_clusters = n_clusters
                best_labels = labels.copy()
        except Exception:
            continue

    if best_labels is None:
        # fallback: all in one cluster
        best_labels = np.zeros(len(p_array), dtype=int)
        best_n_clusters = 1

    labels = best_labels
    n_actions = best_n_clusters

    # Step 3: Compute cluster centers (mean p per cluster), normalize to sum=1 and clip negatives
    centers = np.zeros((n_actions, m_outcomes))
    for a in range(n_actions):
        cluster_ps = p_array[labels == a]
        center = cluster_ps.mean(axis=0)
        center = np.clip(center, 0, None)
        s = center.sum()
        if s > 0:
            center /= s
        else:
            center = np.ones(m_outcomes) / m_outcomes
        centers[a] = center

    # Step 4: Assign rejected logs to closest cluster center by cosine similarity
    contract_rej = np.array(rejected['Contract'].tolist()) if not rejected.empty else np.empty((0, m_outcomes))
    if contract_rej.shape[0] > 0:
        sim = cosine_similarity(contract_rej, centers)  # shape (n_reject, n_actions)
        rej_assign_labels = sim.argmax(axis=1)
    else:
        rej_assign_labels = np.array([], dtype=int)

    contract_acc = np.array(accepted['Contract'].tolist())

    # Step 5: Infer minimal costs c_a satisfying IR and IC constraints via LP
    # Variables: costs c_a >=0 for each action a
    # Constraints:
    # IR for accepted assigned to action a: p_a @ w - c_a >= 0  => c_a <= p_a @ w
    # IC for rejected assigned to action a: p_a @ w - c_a < 0 => c_a > p_a @ w
    # To enforce strict inequalities, add small margin eps_cost

    eps_cost = 1e-8
    # Build LP matrices
    # Objective: minimize sum of costs (or zero vector since we want feasible)
    c_obj = np.zeros(n_actions)

    # Inequality constraints: A_ub x <= b_ub
    # IR: c_a <= min_{accepted assigned to a} p_a @ w
    # IC: c_a >= max_{rejected assigned to a} p_a @ w + eps_cost  => -c_a <= - (max + eps_cost)
    # So for each action a, two inequalities:
    # c_a <= IR_bound_a
    # -c_a <= -IC_bound_a

    A_ub = []
    b_ub = []

    # Collect bounds per action
    IR_bounds = np.full(n_actions, np.inf)
    IC_bounds = np.full(n_actions, -np.inf)

    # IR bounds from accepted logs
    for a in range(n_actions):
        idx_acc = np.where(labels == a)[0]
        if idx_acc.size > 0:
            w_acc = contract_acc[idx_acc]  # shape (num_acc_a, m_outcomes)
            vals = w_acc @ centers[a]  # shape (num_acc_a,)
            IR_bounds[a] = np.min(vals)
        else:
            # No accepted logs assigned, IR bound is +inf (no upper bound)
            IR_bounds[a] = np.inf

    # IC bounds from rejected logs
    for a in range(n_actions):
        idx_rej = np.where(rej_assign_labels == a)[0]
        if idx_rej.size > 0:
            w_rej = contract_rej[idx_rej]
            vals = w_rej @ centers[a]
            IC_bounds[a] = np.max(vals) + eps_cost
        else:
            IC_bounds[a] = -np.inf  # no rejected assigned, no lower bound

    # Build constraints
    # c_a <= IR_bounds[a]
    for a in range(n_actions):
        if np.isfinite(IR_bounds[a]):
            cons = np.zeros(n_actions)
            cons[a] = 1.0
            A_ub.append(cons)
            b_ub.append(IR_bounds[a])

    # -c_a <= -IC_bounds[a]  => c_a >= IC_bounds[a]
    for a in range(n_actions):
        if IC_bounds[a] > -np.inf:
            cons = np.zeros(n_actions)
            cons[a] = -1.0
            A_ub.append(cons)
            b_ub.append(-IC_bounds[a])

    A_ub = np.array(A_ub) if A_ub else None
    b_ub = np.array(b_ub) if b_ub else None

    bounds = [(0, None) for _ in range(n_actions)]  # costs >=0

    # Solve LP to find feasible costs
    res = linprog(c=c_obj, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')

    if res.success:
        costs = res.x
    else:
        # fallback: set costs as max(IC_bounds, 0) or 0 if no rejected logs
        costs = np.maximum(IC_bounds, 0)
        costs[np.isinf(costs)] = 0.0

    # Step 6: Validate and refine costs iteratively to ensure all IR and IC hold strictly
    max_iter = 30
    for _ in range(max_iter):
        # Accepted logs: must have some action a with p_a @ w - c_a >= 0
        accept_utils = contract_acc @ centers.T - costs  # shape (n_accept, n_actions)
        accept_feasible = (accept_utils >= -eps_cost).any(axis=1)

        # Rejected logs: must have all actions a with p_a @ w - c_a < 0
        if contract_rej.shape[0] > 0:
            reject_utils = contract_rej @ centers.T - costs  # shape (n_reject, n_actions)
            reject_feasible = (reject_utils < eps_cost).all(axis=1)
        else:
            reject_feasible = np.array([True])

        if accept_feasible.all() and reject_feasible.all():
            break

        # Increase costs slightly to enforce constraints
        costs += eps_cost * 10
        costs = np.maximum(costs, 0.0)

    # Final normalization for numerical stability
    centers = np.clip(centers, 0, None)
    centers /= centers.sum(axis=1, keepdims=True)
    costs = np.maximum(costs, 0.0)

    agent_setting = np.hstack([centers, costs[:, None]])
    return agent_setting
```
