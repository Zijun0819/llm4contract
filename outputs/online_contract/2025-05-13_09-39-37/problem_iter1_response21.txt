```python
import numpy as np
import pandas as pd
from sklearn.cluster import KMeans
from scipy.optimize import linprog


def agent_solver_v2(v: np.ndarray, content: list[dict]) -> np.ndarray:
    """
    Infer a valid agent setting from historical logs.
    Returns an n x 6 matrix: [p_1,...,p_5, cost] per action.
    """

    m = v.shape[0]
    L = len(content)
    contracts = np.array([log['Contract'] for log in content])
    actions = np.array([log['Agent Action'] for log in content])
    putils = np.array([log['Principal Utility'] for log in content])

    # Step 1: Separate accepted and rejected logs
    accepted_idx = np.where(actions == 1)[0]
    rejected_idx = np.where(actions == -1)[0]

    # If no accepted logs, fallback to trivial setting
    if len(accepted_idx) == 0:
        # Single action: uniform distribution and zero cost
        uniform_p = np.ones(m) / m
        return np.hstack([uniform_p, [0.0]])

    # Step 2: Cluster accepted logs' contracts weighted by principal utility,
    # to find plausible agent outcome distributions.
    # Weights: higher principal utility likely corresponds to more confident agent action.
    weights = putils[accepted_idx] - putils[accepted_idx].min() + 1e-3  # shift positive
    accepted_contracts = contracts[accepted_idx]

    # Choose n_clusters adaptively: min(5, accepted samples)
    n_clusters = min(5, len(accepted_idx))
    kmeans = KMeans(n_clusters=n_clusters, random_state=42, n_init=20)
    kmeans.fit(accepted_contracts, sample_weight=weights)
    centers = kmeans.cluster_centers_  # shape (n_clusters, m)

    # Step 3: For each cluster center (candidate agent p), solve for best cost c:
    # cost <= p @ w for all accepted contracts assigned to this cluster (IR)
    # cost > p @ w for all rejected contracts (IC rejection)
    # Formulate as linear program to find minimal cost per action

    assignments = kmeans.labels_
    agent_ps = []
    agent_costs = []

    for a in range(n_clusters):
        idx_a = accepted_idx[assignments == a]
        p = centers[a].copy()

        # Project p to simplex if needed
        p = np.clip(p, 0, None)
        p /= p.sum()

        # Constraints:
        # For each accepted contract assigned to this action:
        # cost <= p @ w_i  (agent IR)
        # For each rejected contract:
        # cost > p @ w_j  (agent IC)
        # We want minimal cost satisfying constraints.

        # IR constraints: cost <= min_i p @ w_i
        if len(idx_a) > 0:
            p_dot_acc = np.dot(contracts[idx_a], p)  # shape (|idx_a|,)
            cost_ub = p_dot_acc.min()
        else:
            cost_ub = np.inf

        # IC rejection constraints: cost > max_j p @ w_j for rejected logs
        if len(rejected_idx) > 0:
            p_dot_rej = np.dot(contracts[rejected_idx], p)
            cost_lb = p_dot_rej.max()
        else:
            cost_lb = -np.inf

        # Feasibility check: cost_lb < cost_ub
        if cost_lb >= cost_ub:
            # Try to adjust p slightly to find feasibility

            # Solve LP to find p in simplex satisfying:
            # For accepted logs a_i: p @ w_i >= c (c arbitrary)
            # For rejected logs r_j: p @ w_j <= c - eps
            # but here simpler: minimize violation slack

            # Set up LP variables: p (length m)
            # Constraints:
            # sum(p) = 1
            # p >= 0
            # p @ w_i >= cost_lb + eps for all rejected i -> no, we want cost > rejected, so p @ w_j <= cost - eps => cost_lb < cost_ub contradicts

            # Instead, try a small perturbation of p toward uniform to relax
            uniform = np.ones(m) / m
            for alpha in np.linspace(0, 1, 20):
                p_test = (1 - alpha) * p + alpha * uniform
                p_test /= p_test.sum()
                p_dot_acc_test = np.dot(contracts[idx_a], p_test) if len(idx_a) > 0 else np.array([np.inf])
                p_dot_rej_test = np.dot(contracts[rejected_idx], p_test) if len(rejected_idx) > 0 else np.array([-np.inf])
                cost_ub_test = p_dot_acc_test.min() if len(p_dot_acc_test) > 0 else np.inf
                cost_lb_test = p_dot_rej_test.max() if len(p_dot_rej_test) > 0 else -np.inf
                if cost_lb_test < cost_ub_test:
                    p = p_test
                    cost_ub = cost_ub_test
                    cost_lb = cost_lb_test
                    break
            else:
                # If still infeasible, set cost conservatively as max cost_lb, and keep p normalized
                p = p / p.sum()
                cost_ub = np.inf
                cost_lb = np.inf

        # Cost must be at least 0
        cost = max(0, cost_lb + 1e-6) if cost_lb < cost_ub else max(0, cost_ub)

        agent_ps.append(p)
        agent_costs.append(cost)

    agent_ps = np.array(agent_ps)
    agent_costs = np.array(agent_costs)

    # Step 4: Check all accepted logs satisfy IR: p_a @ w_i >= cost_a
    # and all rejected logs satisfy IC: p_a @ w_j < cost_a for some a
    # If violated, we try to add new actions to cover violations

    # We'll add new actions for rejected logs violating IC (agent accepting rejected contracts)
    violated_rej = []
    for i in rejected_idx:
        w = contracts[i]
        # Check if exists action a with p_a @ w >= cost_a (agent utility ≥0) -> violates rejection
        utilities = agent_ps @ w - agent_costs
        if np.any(utilities >= 0):
            violated_rej.append(i)

    # Add one action for each violated rejected log using that contract as p, cost slightly above p@w
    for i in violated_rej:
        w = contracts[i]
        # Use normalized w as p if possible
        p_new = np.clip(w, 0, None)
        if p_new.sum() == 0:
            p_new = np.ones(m) / m
        else:
            p_new /= p_new.sum()
        cost_new = p_new @ w + 1e-3  # cost just above agent utility to reject
        agent_ps = np.vstack([agent_ps, p_new])
        agent_costs = np.append(agent_costs, cost_new)

    # Step 5: Normalize agent_ps rows to sum to 1 and ensure cost ≥0
    for i in range(agent_ps.shape[0]):
        p = agent_ps[i]
        p = np.clip(p, 0, None)
        s = p.sum()
        if s > 0:
            agent_ps[i] = p / s
        else:
            agent_ps[i] = np.ones(m) / m
        agent_costs[i] = max(0, agent_costs[i])

    # Final assembly
    agent_setting = np.hstack([agent_ps, agent_costs[:, None]])

    return agent_setting
```
