```python
import numpy as np
import pandas as pd
from scipy.optimize import linprog
from sklearn.cluster import KMeans


def agent_solver_v2(v: np.ndarray, content: list[dict]) -> np.ndarray:
    """
    Infer valid agent setting (actions: outcome distributions + costs) consistent with
    historical logs of contracts, principal utilities, and agent actions.

    Args:
        v: Principal's reward vector over 5 outcomes (shape: (5,))
        content: List of dicts with keys:
            - 'Contract': List[float], length 5 payment vector
            - 'Principal Utility': float
            - 'Agent Action': int, 1 for accept, -1 for reject

    Returns:
        agent_setting: np.ndarray with shape (n_actions, 6),
            where each row = [p1, p2, p3, p4, p5, cost],
            p_i >=0, sum p_i=1, cost>=0,
            consistent with IR and IC constraints implied by logs.
    """
    m = len(v)  # number of outcomes (should be 5)
    L = len(content)

    # Extract contracts, utilities, and actions
    contracts = np.array([log['Contract'] for log in content])  # shape (L, m)
    utilities = np.array([log['Principal Utility'] for log in content])  # shape (L,)
    agent_actions = np.array([log['Agent Action'] for log in content])  # shape (L,)

    # Step 1: Separate accepted and rejected logs
    accept_idx = np.where(agent_actions == 1)[0]
    reject_idx = np.where(agent_actions == -1)[0]

    # If no acceptances, no info to infer agent strategies
    if len(accept_idx) == 0:
        # Return trivial single action: uniform distribution, zero cost
        p_uniform = np.ones(m) / m
        return np.hstack([p_uniform, 0.0])[np.newaxis, :]

    # Step 2: Infer agent outcome distributions for accepted contracts
    # We assume agent accepts contract if expected payoff - cost >= 0:
    # Expected payoff = p @ contract, cost unknown, so approximate p
    # Use LP to find p maximizing discrepancy between contract payments and principal utility,
    # ensuring p is a valid distribution.

    inferred_ps = []
    for i in accept_idx:
        w = contracts[i]
        # Solve LP: find p >=0, sum p=1, such that p @ w = agent payoff = principal utility + agent cost
        # But agent cost unknown, so find plausible p close to maximizing agent payoff under contract.
        # We try to find p maximizing p @ w subject to p @ v = principal utility + agent cost unknown,
        # but since unknown cost, focus on plausible p close to contract payments.
        # Instead, fit p to maximize correlation with contract payments.

        # Here, solve:
        # max c^T p with c = w (agent prefers higher payment outcomes)
        # s.t sum p = 1, p >=0
        # Because agent utility unknown, just pick p maximizing p @ w (which is w's max coordinate)
        # This is a simplification; more complex would require additional constraints.

        # But we want p explaining agent behavior: expected utility >=0 and principal utility is given.

        # We will solve LP to find p minimizing ||p - w_scaled||_2, where w_scaled = w / sum(w)
        # but constrained to simplex.

        # Instead, pick p = softmax of contract payments to reflect stochasticity.
        exp_w = np.exp(w - np.max(w))
        p_i = exp_w / exp_w.sum()
        inferred_ps.append(p_i)

    inferred_ps = np.array(inferred_ps)  # shape (num_accept, m)

    # Step 3: Cluster inferred distributions into n_actions groups
    # Choose n_actions adaptively: e.g. min(7, number of unique inferred_ps clusters)
    n_actions_max = 7
    n_actions = min(n_actions_max, max(1, len(inferred_ps) // 10))

    if n_actions == 1:
        # single cluster means average p
        p_centers = np.mean(inferred_ps, axis=0, keepdims=True)
    else:
        kmeans = KMeans(n_clusters=n_actions, random_state=42, n_init=10).fit(inferred_ps)
        p_centers = kmeans.cluster_centers_  # shape (n_actions, m)

    # Ensure p_centers are valid distributions (non-negative, sum=1)
    p_centers = np.clip(p_centers, 0, None)
    p_centers = p_centers / p_centers.sum(axis=1, keepdims=True)

    # Step 4: Assign each accepted contract to nearest cluster (action) by L2 distance
    assign_accept = np.zeros(len(accept_idx), dtype=int)
    for idx_i, log_i in enumerate(accept_idx):
        p_candidate = inferred_ps[idx_i]
        dists = np.linalg.norm(p_centers - p_candidate, axis=1)
        assign_accept[idx_i] = np.argmin(dists)

    # Step 5: For each action, estimate minimal cost consistent with IR and IC

    # IR: For accepted contracts assigned to action a,
    # agent payoff (p_a @ w) - cost >= 0 => cost <= p_a @ w

    # IC: For rejected contracts, for all actions a,
    # agent payoff (p_a @ w_rej) - cost < 0 => cost > max over rejection contracts of p_a @ w_rej

    # We estimate cost_a as maximum of:
    #   - max over rejected contracts of p_a @ w_rej (strictly greater than)
    #   - min over accepted contracts assigned to a of p_a @ w_acc (upper bound)

    # Practically, to satisfy all IR and IC constraints, we pick cost_a:
    # cost_a in [max_rej, min_acc]
    # If empty interval, adjust cost_a accordingly (may increase cost_a)

    # Extract contracts for accepted actions:
    costs = np.zeros(n_actions)
    for a in range(n_actions):
        # contracts accepted assigned to action a
        accepted_contracts_a = contracts[accept_idx][assign_accept == a]  # shape (num_a, m)
        p_a = p_centers[a]

        if accepted_contracts_a.shape[0] == 0:
            # no data for this action, assign cost zero
            costs[a] = 0.0
            continue

        payoffs_accept = accepted_contracts_a @ p_a  # shape (num_a,)
        cost_upper = payoffs_accept.min()  # cost ≤ min payoff over accepted contracts

        # rejected contracts payoffs
        if len(reject_idx) > 0:
            rejected_contracts = contracts[reject_idx]  # shape (num_rej, m)
            payoffs_reject = rejected_contracts @ p_a  # shape (num_rej,)
            cost_lower = payoffs_reject.max()  # cost > max payoff over rejected contracts
        else:
            cost_lower = 0.0

        # feasible interval for cost_a: (cost_lower, cost_upper]
        if cost_upper < cost_lower:
            # no feasible cost, relax by setting cost = cost_upper (accept IR violation minimal)
            cost_a = cost_upper
        else:
            # pick cost_a slightly above cost_lower to separate accept and reject
            cost_a = max(cost_lower + 1e-6, 0.0)
            if cost_a > cost_upper:
                cost_a = cost_upper

        # cost must be non-negative
        costs[a] = max(cost_a, 0.0)

    # Step 6: Validate that for rejected contracts, no action yields agent utility ≥ 0
    # If violated, increase costs accordingly

    for i in reject_idx:
        w_rej = contracts[i]
        payoff_candidates = p_centers @ w_rej  # shape (n_actions,)
        utilities_candidates = payoff_candidates - costs  # agent utility = payoff - cost
        # For rejection, expect all utilities < 0
        if np.any(utilities_candidates >= 0.0):
            # Increase cost for offending actions
            for a in np.where(utilities_candidates >= 0)[0]:
                # Increase cost to just above payoff
                costs[a] = payoff_candidates[a] + 1e-6

    # Step 7: Final sanity check: probabilities sum to 1, costs ≥0
    p_centers = np.clip(p_centers, 0, None)
    p_centers /= p_centers.sum(axis=1, keepdims=True)
    costs = np.clip(costs, 0, None)

    agent_setting = np.hstack([p_centers, costs[:, None]])

    return agent_setting
```
