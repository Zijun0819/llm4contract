```python
import numpy as np
import pandas as pd
from scipy.optimize import linprog
from sklearn.cluster import AgglomerativeClustering


def agent_solver_v2(v: np.ndarray, content: list[dict]) -> np.ndarray:
    """
    Infer a valid agent setting (actions as outcome distributions + costs) consistent with historical logs.
    Uses hierarchical clustering and LP-based feasibility checks to adaptively select number of actions.
    Ensures IR (individual rationality) and IC (incentive compatibility) constraints hold on logs.
    """
    m = v.size
    L = len(content)

    # Parse logs into arrays for convenience
    contracts = np.array([log['Contract'] for log in content])  # shape (L, m)
    p_utilities = np.array([log['Principal Utility'] for log in content])  # shape (L,)
    agent_actions = np.array([log['Agent Action'] for log in content])  # shape (L,)

    # Separate accepted and rejected logs
    accepted_idx = np.where(agent_actions == 1)[0]
    rejected_idx = np.where(agent_actions == -1)[0]
    if accepted_idx.size == 0:
        raise ValueError("No accepted contracts in logs to infer agent behavior.")

    # Step 1: For accepted logs, estimate agent outcome distributions (p) via LP:
    # Solve: find p (distribution) s.t. p @ contract = agent utility + cost (unknown),
    # but agent utility unknown. Instead: approximate p by maximizing likelihood of outcome under contract.
    # Here, we do a proxy: use contract normalized as proxy for p since agent accepted only if expected utility >=0.
    # More robust: solve LP that finds p s.t. p sums to 1 and p @ contract ~= agent utility (approximate).
    # We approximate p_i by normalizing contract i to sum 1 (heuristic).
    p_candidates = []
    for i in accepted_idx:
        w = contracts[i]
        # Normalize contract (shift to positive if needed)
        w_min = w.min()
        shifted_w = w - w_min if w_min < 0 else w
        # Normalize to sum to 1 as proxy for p
        s = shifted_w.sum()
        if s <= 0:
            # fallback uniform
            p_candidates.append(np.ones(m) / m)
        else:
            p_candidates.append(shifted_w / s)
    p_candidates = np.array(p_candidates)  # shape (#accepted, m)

    # Step 2: Cluster p_candidates by similarity to find candidate agent actions adaptively
    # Use Agglomerative Clustering with distance threshold to let n_clusters adapt
    clustering = AgglomerativeClustering(n_clusters=None, distance_threshold=0.15, linkage='ward')
    labels = clustering.fit_predict(p_candidates)
    unique_labels = np.unique(labels)
    n_actions = unique_labels.size

    # Step 3: For each cluster, compute centroid as outcome distribution p_a
    p_actions = np.zeros((n_actions, m))
    for a in unique_labels:
        members = p_candidates[labels == a]
        centroid = members.mean(axis=0)
        # Renormalize centroid to sum 1 and nonnegativity
        centroid[centroid < 0] = 0
        s = centroid.sum()
        if s == 0:
            centroid = np.ones(m) / m
        else:
            centroid /= s
        p_actions[a] = centroid

    # Step 4: Infer action costs by solving feasibility LP incorporating IR and IC constraints from logs
    # Variables: c_a for each action (agent cost, >=0)
    # Constraints:
    #   For accepted logs with assigned action a: p_a @ w_i - c_a >= 0 (IR)
    #   For rejected logs: max_a (p_a @ w_j - c_a) < 0 (reject utility < 0)
    #   For IC: no action yields strictly better utility than chosen action on accepted logs:
    #       For accepted log i assigned to a_i: For all b != a_i:
    #           p_b @ w_i - c_b <= p_a_i @ w_i - c_a_i

    # Assign accepted logs to closest action by dot product p_a @ w_i
    assigned_actions = np.zeros(L, dtype=int) - 1
    for i in accepted_idx:
        utilities = p_actions @ contracts[i]
        assigned_actions[i] = int(np.argmax(utilities))

    # Build LP matrices for costs c = [c_0, ..., c_{n_actions-1}]
    # Objective: minimize sum c to find minimal costs explaining data
    c_obj = np.ones(n_actions)

    # Inequality constraints: A_ub c <= b_ub
    A_ub = []
    b_ub = []

    # 1) IR constraints: p_a @ w_i - c_a >= 0 => -c_a >= -p_a @ w_i
    # => c_a <= p_a @ w_i for accepted logs i assigned to a
    for i in accepted_idx:
        a = assigned_actions[i]
        row = np.zeros(n_actions)
        row[a] = 1
        A_ub.append(row)
        b_ub.append(p_actions[a] @ contracts[i])

    # 2) IC constraints: For accepted i assigned to a,
    # For all b != a: p_b @ w_i - c_b <= p_a @ w_i - c_a
    # => (c_b - c_a) >= (p_b - p_a) @ w_i
    # => -(c_b - c_a) <= - (p_b - p_a) @ w_i
    for i in accepted_idx:
        a = assigned_actions[i]
        for b in range(n_actions):
            if b == a:
                continue
            row = np.zeros(n_actions)
            row[b] = -1
            row[a] = 1
            rhs = -(p_actions[b] - p_actions[a]) @ contracts[i]
            A_ub.append(row)
            b_ub.append(rhs)

    # 3) Rejection constraints: For rejected logs j,
    # max_a (p_a @ w_j - c_a) < 0 => p_a @ w_j - c_a < 0 for all a
    # => c_a > p_a @ w_j for all a, or c_a >= p_a @ w_j + epsilon (epsilon small > 0)
    # For strictness, use small margin 1e-5
    margin = 1e-5
    for j in rejected_idx:
        for a in range(n_actions):
            row = np.zeros(n_actions)
            row[a] = -1
            rhs = -(p_actions[a] @ contracts[j] + margin)
            A_ub.append(row)
            b_ub.append(rhs)

    # 4) Costs nonnegative: c_a >= 0 => -c_a <= 0
    for a in range(n_actions):
        row = np.zeros(n_actions)
        row[a] = -1
        A_ub.append(row)
        b_ub.append(0.0)

    A_ub = np.array(A_ub)
    b_ub = np.array(b_ub)

    # Solve LP: minimize sum c subject to constraints
    res = linprog(c=c_obj, A_ub=A_ub, b_ub=b_ub, bounds=[(0, None)]*n_actions, method='highs')

    if not res.success:
        # If infeasible, relax margin and retry once
        margin = 1e-8
        for i, (row, rhs) in enumerate(zip(A_ub, b_ub)):
            if np.all(row <= 0):  # rejection constraints rows have negative entries
                b_ub[i] = rhs + (1e-8 - 1e-5)
        res = linprog(c=c_obj, A_ub=A_ub, b_ub=b_ub, bounds=[(0, None)]*n_actions, method='highs')
        if not res.success:
            # fallback: assign zero costs, might violate IR or IC but no better guess
            costs = np.zeros(n_actions)
        else:
            costs = res.x
    else:
        costs = res.x

    # Final agent setting matrix: n_actions x (m + 1)
    agent_setting = np.hstack([p_actions, costs[:, np.newaxis]])

    return agent_setting
```
