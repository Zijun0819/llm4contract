```python
import numpy as np
import pandas as pd
from scipy.optimize import linprog
from sklearn.cluster import DBSCAN
from sklearn.metrics import silhouette_score
from scipy.spatial.distance import cdist

def agent_solver(v: np.ndarray, content: list[dict]) -> np.ndarray:
    """
    Infer a valid agent setting (probabilities over outcomes + costs)
    explaining the historical interaction logs between principal and agent,
    using adaptive clustering and robust cost refinement.

    Args:
        v (np.ndarray): Principal's reward vector for 5 outcomes, shape (5,)
        content (list[dict]): Each dict contains:
            - 'Contract': 5-dim payment vector,
            - 'Principal Utility': principal utility under contract,
            - 'Agent Action': 1 for accept, -1 for reject.

    Returns:
        np.ndarray: n x 6 matrix: first 5 cols are outcome probabilities (sum=1),
                    last column is agent cost (â‰¥0).
    """
    m_outcomes = v.shape[0]
    logs_df = pd.DataFrame(content)
    accepted = logs_df[logs_df['Agent Action'] == 1].reset_index(drop=True)
    rejected = logs_df[logs_df['Agent Action'] == -1].reset_index(drop=True)

    # If no accepted contracts, return trivial agent with uniform dist and zero cost
    if accepted.empty:
        uniform_p = np.ones(m_outcomes) / m_outcomes
        return np.hstack([uniform_p.reshape(1, -1), np.zeros((1, 1))])

    # LP to infer p for accepted contract (agent accepted => agent utility >=0)
    def infer_p_for_accept(w, u_p):
        c_obj = -np.array(w)
        A_eq = [np.ones(m_outcomes), v - np.array(w)]
        b_eq = [1.0, u_p]
        bounds = [(0, 1) for _ in range(m_outcomes)]
        res = linprog(c=c_obj, A_eq=A_eq, b_eq=b_eq, bounds=bounds, method='highs')
        if res.success:
            p = res.x
            p = np.clip(p, 0, None)
            s = p.sum()
            if s > 0:
                p /= s
            else:
                p = np.ones(m_outcomes) / m_outcomes
            return p
        else:
            return np.ones(m_outcomes) / m_outcomes

    # LP to infer p for rejected contract (agent rejected => agent utility < 0)
    def infer_p_for_reject(w):
        delta = 1e-7
        c_obj = -np.array(w)
        A_eq = [np.ones(m_outcomes)]
        b_eq = [1.0]
        A_ub = [-(v - np.array(w))]
        b_ub = [-delta]
        bounds = [(0, 1) for _ in range(m_outcomes)]
        res = linprog(c=c_obj, A_eq=A_eq, b_eq=b_eq, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')
        if res.success:
            p = res.x
            p = np.clip(p, 0, None)
            s = p.sum()
            if s > 0:
                p /= s
            else:
                p = np.ones(m_outcomes) / m_outcomes
            return p
        else:
            return np.ones(m_outcomes) / m_outcomes

    p_accept_list = [infer_p_for_accept(row['Contract'], row['Principal Utility']) for _, row in accepted.iterrows()]
    p_accept_array = np.vstack(p_accept_list)

    p_reject_array = np.empty((0, m_outcomes))
    if not rejected.empty:
        p_reject_list = [infer_p_for_reject(row['Contract']) for _, row in rejected.iterrows()]
        p_reject_array = np.vstack(p_reject_list)

    combined_p = np.vstack([p_accept_array, p_reject_array]) if p_reject_array.size else p_accept_array.copy()

    # Adaptive clustering with DBSCAN on combined p's
    best_eps = None
    best_score = -1
    eps_candidates = np.linspace(0.05, 0.3, 6)
    for eps in eps_candidates:
        clustering = DBSCAN(eps=eps, min_samples=2, metric='euclidean').fit(combined_p)
        labels = clustering.labels_
        n_clusters = len(set(labels)) - (1 if -1 in labels else 0)
        if n_clusters < 2:
            continue
        try:
            sil_score = silhouette_score(combined_p[labels != -1], labels[labels != -1])
            if sil_score > best_score:
                best_score = sil_score
                best_eps = eps
        except Exception:
            continue
    if best_eps is None:
        best_eps = 0.15

    clustering = DBSCAN(eps=best_eps, min_samples=2, metric='euclidean').fit(combined_p)
    labels = clustering.labels_
    valid_mask = labels != -1
    filtered_p = combined_p[valid_mask]
    filtered_labels = labels[valid_mask]

    if len(set(filtered_labels)) == 0:
        # fallback: one cluster - mean of accepted p's
        centers = np.mean(p_accept_array, axis=0, keepdims=True)
        centers = np.clip(centers, 0, None)
        s = centers.sum(axis=1, keepdims=True)
        centers /= np.where(s == 0, 1, s)
        n_actions = 1
    else:
        n_actions = len(set(filtered_labels))
        centers = np.zeros((n_actions, m_outcomes))
        for a in range(n_actions):
            cluster_ps = filtered_p[filtered_labels == a]
            c = cluster_ps.mean(axis=0)
            c = np.clip(c, 0, None)
            s = c.sum()
            if s > 0:
                c /= s
            else:
                c = np.ones(m_outcomes) / m_outcomes
            centers[a] = c

    # Assign accepted logs to closest cluster by Euclidean distance
    dist_accept = cdist(p_accept_array, centers, metric='euclidean')
    assigned_clusters = dist_accept.argmin(axis=1)

    accepted_contracts = np.array(accepted['Contract'].tolist())
    rejected_contracts = np.array(rejected['Contract'].tolist()) if not rejected.empty else np.empty((0, m_outcomes))

    # Initialize costs satisfying IR and IC constraints
    eps_cost = 1e-7
    costs = np.zeros(n_actions)
    for a in range(n_actions):
        p_a = centers[a]

        # Accepted contracts assigned to cluster a
        acc_idx = np.where(assigned_clusters == a)[0]
        if acc_idx.size > 0:
            acc_ws = accepted_contracts[acc_idx]
            acc_vals = acc_ws @ p_a
            max_acc = acc_vals.max()
        else:
            max_acc = 0.0

        # Rejected contracts
        if rejected_contracts.shape[0] > 0:
            rej_vals = rejected_contracts @ p_a
            max_rej = rej_vals.max()
        else:
            max_rej = -np.inf

        cost_a = max(max_acc, max_rej + eps_cost)
        costs[a] = max(cost_a, 0.0)

    # Iteratively refine costs to satisfy IR and IC with margin
    max_iters = 20
    for _ in range(max_iters):
        # Accepted logs: some action must have utility >= 0
        accept_utils = accepted_contracts @ centers.T - costs  # shape (n_accept, n_actions)
        max_accept_util = accept_utils.max(axis=1)
        accept_violations = max_accept_util < -eps_cost

        # Rejected logs: all actions must have utility < 0
        if rejected_contracts.shape[0] > 0:
            reject_utils = rejected_contracts @ centers.T - costs  # shape (n_reject, n_actions)
            max_reject_util = reject_utils.max(axis=1)
            reject_violations = max_reject_util >= -eps_cost
        else:
            reject_violations = np.array([], dtype=bool)

        if not accept_violations.any() and not reject_violations.any():
            break  # feasible

        # Fix accept violations by decreasing costs for assigned clusters
        if accept_violations.any():
            violation_idxs = np.where(accept_violations)[0]
            for idx in violation_idxs:
                a = assigned_clusters[idx]
                costs[a] = max(costs[a] - eps_cost * 10, 0.0)

        # Fix reject violations by increasing all costs slightly
        if reject_violations.any():
            costs += eps_cost * 10

    # Final normalization of centers and costs
    centers = np.clip(centers, 0, None)
    s = centers.sum(axis=1, keepdims=True)
    centers /= np.where(s == 0, 1, s)
    costs = np.maximum(costs, 0.0)

    agent_setting = np.hstack([centers, costs[:, None]])
    return agent_setting
```
