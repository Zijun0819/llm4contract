```python
import numpy as np
import pandas as pd
from scipy.optimize import linprog
from sklearn.cluster import DBSCAN
from sklearn.metrics import silhouette_score
from sklearn.metrics.pairwise import cosine_distances

def agent_solver_v2(v: np.ndarray, content: list[dict]) -> np.ndarray:
    """
    Infer a valid agent setting (probabilities over outcomes + costs)
    consistent with historical logs of contracts, principal utilities,
    and agent accept/reject actions.

    Args:
        v (np.ndarray): Principal's reward vector for 5 outcomes, shape (5,)
        content (list[dict]): Each dict with keys:
            - 'Contract': 5-dim payment vector,
            - 'Principal Utility': float,
            - 'Agent Action': int (1 accept, -1 reject)

    Returns:
        np.ndarray: n_actions x 6 matrix, each row:
            first 5 columns = outcome probabilities (sum=1),
            last column = agent cost (â‰¥0).
    """
    m = v.shape[0]
    logs_df = pd.DataFrame(content)
    accepted = logs_df[logs_df['Agent Action'] == 1].reset_index(drop=True)
    rejected = logs_df[logs_df['Agent Action'] == -1].reset_index(drop=True)

    # If no accepted contracts, return trivial uniform action with zero cost
    if accepted.empty:
        uniform_p = np.ones(m) / m
        return np.hstack([uniform_p, 0.0])[np.newaxis, :]

    # Step 1: Infer agent outcome distributions p for accepted contracts via LP
    def infer_p_accept(w, u_p):
        # LP:
        # maximize p @ w
        # s.t sum p = 1
        #     p @ (v - w) = u_p  (agent utility = principal utility)
        #     0 <= p_i <= 1
        c = -np.array(w, dtype=np.float64)  # maximize p@w = minimize -p@w
        A_eq = np.vstack([np.ones(m), v - w])
        b_eq = np.array([1.0, u_p], dtype=np.float64)
        bounds = [(0, 1) for _ in range(m)]
        res = linprog(c, A_eq=A_eq, b_eq=b_eq, bounds=bounds, method='highs')
        if res.success:
            p = res.x
            p = np.clip(p, 0, None)
            s = p.sum()
            if s > 0:
                p /= s
            else:
                p = np.ones(m) / m
            return p
        else:
            # fallback uniform distribution
            return np.ones(m) / m

    p_accept_list = []
    for _, row in accepted.iterrows():
        p_accept_list.append(infer_p_accept(row['Contract'], row['Principal Utility']))
    p_accept = np.vstack(p_accept_list)  # shape (num_accept, m)

    # Step 2: Infer proxy p for rejected contracts by minimizing expected payment
    reject_contracts = np.array(rejected['Contract'].tolist()) if not rejected.empty else np.empty((0, m))
    p_reject_list = []
    for w in reject_contracts:
        # LP: minimize p @ w s.t sum p=1, p>=0
        c = np.array(w, dtype=np.float64)
        A_eq = np.ones((1, m))
        b_eq = np.array([1.0])
        bounds = [(0, 1) for _ in range(m)]
        res = linprog(c, A_eq=A_eq, b_eq=b_eq, bounds=bounds, method='highs')
        if res.success:
            p = res.x
            p = np.clip(p, 0, None)
            s = p.sum()
            if s > 0:
                p /= s
            else:
                p = np.ones(m) / m
            p_reject_list.append(p)
        else:
            p_reject_list.append(np.ones(m) / m)
    p_reject = np.vstack(p_reject_list) if p_reject_list else np.empty((0, m))

    # Step 3: Combine accepted and rejected p's and cluster with DBSCAN (cosine metric)
    combined_p = np.vstack([p_accept, p_reject]) if p_reject.size else p_accept.copy()
    n_accept = p_accept.shape[0]
    n_reject = p_reject.shape[0]

    # Try multiple eps values for DBSCAN and pick best silhouette score
    eps_candidates = np.linspace(0.05, 0.3, 6)
    best_eps = None
    best_score = -1
    best_labels = None

    for eps in eps_candidates:
        clustering = DBSCAN(eps=eps, min_samples=2, metric='cosine').fit(combined_p)
        labels = clustering.labels_
        # Skip if all noise or single cluster
        if len(set(labels)) <= 1 or np.all(labels == -1):
            continue
        mask = labels != -1
        if np.sum(mask) < 2:
            continue
        try:
            score = silhouette_score(combined_p[mask], labels[mask], metric='cosine')
        except Exception:
            continue
        if score > best_score:
            best_score = score
            best_eps = eps
            best_labels = labels

    if best_labels is None:
        # fallback: all accepted in one cluster, rejected noise
        best_labels = np.concatenate([np.zeros(n_accept, dtype=int), -np.ones(n_reject, dtype=int)])

    labels = best_labels
    clustered_mask = labels != -1
    clustered_p = combined_p[clustered_mask]
    clustered_labels = labels[clustered_mask]
    n_actions = clustered_labels.max() + 1 if clustered_labels.size > 0 else 1
    if n_actions == 0:
        n_actions = 1

    # Step 4: Compute cluster centers (mean p per cluster)
    centers = np.zeros((n_actions, m))
    for a in range(n_actions):
        members = clustered_p[clustered_labels == a]
        if members.shape[0] == 0:
            centers[a] = np.ones(m) / m
        else:
            mean_p = members.mean(axis=0)
            mean_p = np.clip(mean_p, 0, None)
            s = mean_p.sum()
            if s > 0:
                mean_p /= s
            else:
                mean_p = np.ones(m) / m
            centers[a] = mean_p

    # Step 5: Assign accepted logs to closest cluster center by cosine distance
    dist_accept = cosine_distances(p_accept, centers)  # shape (n_accept, n_actions)
    assign_accept = dist_accept.argmin(axis=1)

    contract_accept = np.array(accepted['Contract'].tolist())
    contract_reject = reject_contracts

    eps_cost = 1e-9
    costs = np.zeros(n_actions)

    # Step 6: Compute minimal costs c_a per action satisfying IR and IC
    for a in range(n_actions):
        p_a = centers[a]

        # IR constraint: for accepted logs assigned to action a
        idx_acc = np.where(assign_accept == a)[0]
        if idx_acc.size > 0:
            w_acc = contract_accept[idx_acc]
            payoffs_acc = w_acc @ p_a
            max_acc_payoff = payoffs_acc.max()
        else:
            max_acc_payoff = 0.0

        # IC constraint: for all rejected logs
        if contract_reject.shape[0] > 0:
            payoffs_rej = contract_reject @ p_a
            max_rej_payoff = payoffs_rej.max()
        else:
            max_rej_payoff = -np.inf

        # Cost must satisfy: c_a >= max_acc_payoff (IR), c_a > max_rej_payoff (IC)
        cost_a = max(max_acc_payoff, max_rej_payoff + eps_cost)
        costs[a] = max(cost_a, 0.0)

    # Step 7: Validate and refine costs iteratively to fix violations
    max_iter = 15
    for _ in range(max_iter):
        violated = False
        # Check accepted logs: some action must have agent utility >= 0
        accept_utilities = contract_accept @ centers.T - costs  # shape (n_accept, n_actions)
        accept_max_util = accept_utilities.max(axis=1)
        if np.any(accept_max_util < -eps_cost):
            # Increase costs slightly to fix IR violation (reduce costs)
            # Actually to fix IR violation we need to reduce costs, but costs >=0
            # So we relax by decreasing costs where possible but keep >=0
            idx_violate = np.where(accept_max_util < -eps_cost)[0]
            for i in idx_violate:
                # Find action with max utility for this log
                max_a = accept_utilities[i].argmax()
                # Decrease cost if possible
                old_cost = costs[max_a]
                new_cost = max(old_cost + accept_utilities[i, max_a], 0)
                if new_cost < old_cost:
                    costs[max_a] = new_cost
                    violated = True
            if not violated:
                # Cannot fix by decreasing costs, break
                break

        # Check rejected logs: no action should have agent utility >= 0
        if contract_reject.shape[0] > 0:
            reject_utilities = contract_reject @ centers.T - costs  # shape (n_reject, n_actions)
            for i in range(contract_reject.shape[0]):
                viol_actions = np.where(reject_utilities[i] >= -eps_cost)[0]
                if viol_actions.size > 0:
                    violated = True
                    # Increase costs minimally for violating actions
                    for a in viol_actions:
                        costs[a] = max(costs[a], contract_reject[i] @ centers[a] + eps_cost)
                    # After update, break to re-check
                    break
            if violated:
                continue
        if not violated:
            break

    # Step 8: Final normalization and clipping
    centers = np.clip(centers, 0, None)
    centers /= centers.sum(axis=1, keepdims=True)
    costs = np.maximum(costs, 0)

    agent_setting = np.hstack([centers, costs[:, None]])
    return agent_setting
```
