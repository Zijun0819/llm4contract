```python
import numpy as np
import pandas as pd
from scipy.optimize import linprog
from sklearn.cluster import AgglomerativeClustering


def agent_solver_v2(v: np.ndarray, content: pd.DataFrame) -> np.ndarray:
    """
    Infer a valid agent setting matrix (actions x [5 outcomes + cost]) that explains historical logs.
    Uses outcome distributions and costs that satisfy IC and IR constraints from acceptance/rejection logs.

    Parameters:
    - v: principal's reward vector for 5 outcomes (shape (5,))
    - content: pd.DataFrame with columns ['Contract', 'Principal Utility', 'Agent Action'] and 100+ rows

    Returns:
    - agent_setting: ndarray of shape (n_actions, 6), each row is [p_1,...,p_5,cost]
    """
    m = v.shape[0]
    logs = content.copy()
    L = len(logs)

    # Extract contracts, utilities, actions
    contracts = np.array(logs['Contract'].tolist())  # shape (L, m)
    utilities = np.array(logs['Principal Utility'].tolist())  # shape (L,)
    actions = np.array(logs['Agent Action'].tolist())  # shape (L,)

    # 1) Separate accepted and rejected logs
    accepted_idx = np.where(actions == 1)[0]
    rejected_idx = np.where(actions == -1)[0]

    # If no accepted logs, fallback trivial action: uniform outcomes, zero cost
    if len(accepted_idx) == 0:
        uniform_p = np.ones(m) / m
        cost_zero = 0.0
        return np.hstack([uniform_p, cost_zero])[np.newaxis, :]

    # 2) Infer candidate outcome distributions p for accepted logs by LP:
    # Solve for p >=0, sum p=1, maximizing agent expected utility p.w - cost >=0 => cost unknown, but cost = p.w - utility_agent
    # We don't observe agent utility u_agent directly, but:
    # Principal utility = v.p - p.w, agent utility = p.w - cost >= 0 if accepted.
    # So p.w = v.p - Principal_utility.
    # We want to recover p given w, u_p (principal utility), v
    # Formulate LP: Find p s.t sum p=1, p>=0, and v.p - w.p = Principal Utility
    # We have one equality: p.v - p.w = Principal Utility => p.(v - w) = Principal Utility

    # We'll solve LP for p: minimize 0, subject to sum p=1, p >=0, p.(v-w) = Principal Utility

    candidate_ps = []
    for i in accepted_idx:
        w = contracts[i]
        u_p = utilities[i]

        # Constraints:
        # Aeq p = b_eq
        # sum p =1
        # p.(v-w) = u_p
        # p >= 0
        A_eq = np.vstack([
            np.ones(m),
            v - w
        ])
        b_eq = np.array([1.0, u_p])
        bounds = [(0, 1) for _ in range(m)]
        # Objective zero vector (feasibility)
        c = np.zeros(m)

        res = linprog(c, A_eq=A_eq, b_eq=b_eq, bounds=bounds, method='highs')
        if res.success:
            p = res.x
            # Numerical fix: clip to zero, normalize
            p = np.clip(p, 0, 1)
            p /= p.sum()
            candidate_ps.append(p)
        else:
            # fallback: uniform distribution
            candidate_ps.append(np.ones(m) / m)

    candidate_ps = np.array(candidate_ps)  # shape (num_accepted, m)

    # 3) Cluster candidate_ps to extract representative actions:
    # Use Agglomerative Clustering to adaptively find number of clusters between 3 and 10
    # Pick number of clusters to balance explainability and compactness

    def cluster_and_evaluate(n_clusters: int) -> tuple[int, float, np.ndarray]:
        model = AgglomerativeClustering(n_clusters=n_clusters)
        labels = model.fit_predict(candidate_ps)
        centers = np.zeros((n_clusters, m))
        for cidx in range(n_clusters):
            members = candidate_ps[labels == cidx]
            if len(members) == 0:
                centers[cidx] = np.ones(m) / m
            else:
                cmean = members.mean(axis=0)
                centers[cidx] = cmean / cmean.sum()
        # Evaluate average within-cluster sum of squared distances
        ssd = 0.0
        for idx, pvec in enumerate(candidate_ps):
            center = centers[labels[idx]]
            ssd += np.sum((pvec - center) ** 2)
        return n_clusters, ssd / len(candidate_ps), centers

    best_n = 3
    best_ssd = np.inf
    best_centers = None
    for nc in range(3, 11):
        ncl, ssd, centers = cluster_and_evaluate(nc)
        if ssd < best_ssd:
            best_ssd = ssd
            best_n = ncl
            best_centers = centers

    n_actions = best_n
    p_actions = best_centers  # shape (n_actions, m), each sums to 1

    # 4) Assign each accepted log to closest action in L1 norm on p
    assigns = np.full(L, -1, dtype=int)
    for i in accepted_idx:
        pvec = candidate_ps[np.where(accepted_idx == i)[0][0]]
        dists = np.sum(np.abs(p_actions - pvec), axis=1)
        assigns[i] = np.argmin(dists)

    # 5) Determine cost for each action to satisfy IR and IC:
    # For each action a:
    #   For accepted logs assigned to a, cost_a <= p_a.w - agent utility >= 0
    #   For rejected logs, agent utility < 0 for all actions
    # Agent utility for action a on contract w: p_a.w - cost_a
    # IR for accepted: p_a.w - cost_a >= 0 => cost_a <= p_a.w
    # IC for rejected: max_a (p_a.w - cost_a) < 0 on rejected contracts.

    # Formulate LP to find minimal costs c_a >= 0 satisfying:
    # For accepted i assigned to a: cost_a <= p_a . w_i
    # For rejected j: max_a (p_a . w_j - cost_a) < 0 => for all a: p_a.w_j - cost_a < 0

    # We relax strict inequalities to <= -epsilon for numerical stability
    epsilon = 1e-6
    c_bounds = [(0, None) for _ in range(n_actions)]
    # Variables: costs c = (c0,..., c_{n_actions-1})

    # Constraints:
    # Gather constraints in form A_ub c <= b_ub
    A_ub = []
    b_ub = []

    # From accepted logs: for each i assigned to a: cost_a <= p_a . w_i
    # => cost_a - 0 <= p_a . w_i
    for i in accepted_idx:
        a = assigns[i]
        if a == -1:
            continue
        w_i = contracts[i]
        p_a = p_actions[a]
        rhs = p_a @ w_i  # scalar
        row = np.zeros(n_actions)
        row[a] = 1.0
        A_ub.append(row)
        b_ub.append(rhs)

    # From rejected logs: for each j and each a:
    # p_a . w_j - cost_a < 0 => cost_a > p_a . w_j (strict)
    # To fit LP, rewrite: -cost_a <= -p_a . w_j - epsilon
    # => cost_a >= p_a . w_j + epsilon
    # In terms of <=: -cost_a <= -p_a . w_j - epsilon

    # We write inequalities: -c_a <= -p_a.w_j - epsilon
    # => c_a >= p_a.w_j + epsilon
    # For LP standard form: -c_a <= rhs

    for j in rejected_idx:
        w_j = contracts[j]
        for a in range(n_actions):
            p_a = p_actions[a]
            rhs = - (p_a @ w_j) - epsilon
            row = np.zeros(n_actions)
            row[a] = -1.0
            A_ub.append(row)
            b_ub.append(rhs)

    A_ub = np.array(A_ub)
    b_ub = np.array(b_ub)

    # Objective: minimize sum costs (or max cost) for simplicity minimize sum costs
    c_obj = np.ones(n_actions)

    res_cost = linprog(c_obj, A_ub=A_ub, b_ub=b_ub, bounds=c_bounds, method='highs')

    if not res_cost.success:
        # fallback: set costs to max over accepted p_a.w (feasible but may violate rejection)
        c_fallback = np.zeros(n_actions)
        for a in range(n_actions):
            assigned_idx = np.where(assigns == a)[0]
            if len(assigned_idx) > 0:
                max_pw = max((p_actions[a] @ contracts[i]) for i in assigned_idx)
                c_fallback[a] = max_pw
            else:
                c_fallback[a] = 0.0
        costs = c_fallback
    else:
        costs = res_cost.x

    # 6) Final verification: Ensure costs >=0, p sum to 1
    costs = np.clip(costs, 0, None)
    for i in range(n_actions):
        p_actions[i] = np.clip(p_actions[i], 0, None)
        p_actions[i] /= p_actions[i].sum()

    agent_setting = np.hstack([p_actions, costs.reshape(-1, 1)])
    return agent_setting
```
