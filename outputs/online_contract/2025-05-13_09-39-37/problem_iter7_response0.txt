```python
import numpy as np
import pandas as pd
from scipy.optimize import linprog
from sklearn.cluster import AgglomerativeClustering
from sklearn.metrics.pairwise import cosine_distances, cosine_similarity

def agent_solver_v2(v: np.ndarray, content: list[dict]) -> np.ndarray:
    """
    Infer a valid agent setting (probability distributions over outcomes + costs)
    explaining the historical interaction logs between principal and agent,
    by hierarchical clustering (cosine similarity) of accepted logs' inferred outcome
    distributions and inferring costs to satisfy IR and IC constraints for accepted
    and rejected contracts.

    Args:
        v (np.ndarray): Principal's reward vector for 5 outcomes, shape (5,)
        content (list[dict]): Each dict contains:
            - 'Contract': 5-dim payment vector,
            - 'Principal Utility': principal utility under contract,
            - 'Agent Action': 1 for accept, -1 for reject.

    Returns:
        np.ndarray: n x 6 matrix: first 5 cols are outcome probabilities (sum=1),
                    last column is agent cost (â‰¥0).
    """
    m_outcomes = v.shape[0]
    logs_df = pd.DataFrame(content)
    accepted = logs_df[logs_df['Agent Action'] == 1].reset_index(drop=True)
    rejected = logs_df[logs_df['Agent Action'] == -1].reset_index(drop=True)

    # If no accepted contracts, return trivial agent with uniform dist and zero cost
    if accepted.empty:
        return np.hstack([np.ones((1, m_outcomes)) / m_outcomes, np.zeros((1, 1))])

    # Step 1: Infer p for each accepted contract by LP
    def infer_p_for_log(w, u_p):
        # Solve LP:
        # variables: p (length m_outcomes)
        # constraints:
        #   sum p = 1
        #   p @ (v - w) = u_p
        # bounds: p_i in [0,1]
        # objective: maximize p @ w (agent expected payment)
        c_obj = -np.array(w)
        A_eq = [np.ones(m_outcomes), v - np.array(w)]
        b_eq = [1.0, u_p]
        bounds = [(0, 1) for _ in range(m_outcomes)]
        res = linprog(c=c_obj, A_eq=A_eq, b_eq=b_eq, bounds=bounds, method='highs')
        if res.success:
            p = res.x
            # Numerical fix: clip and re-normalize
            p = np.clip(p, 0, None)
            s = p.sum()
            if s > 0:
                p /= s
            else:
                p = np.ones(m_outcomes) / m_outcomes
            return p
        else:
            # fallback: uniform distribution
            return np.ones(m_outcomes) / m_outcomes

    p_list = [infer_p_for_log(row['Contract'], row['Principal Utility']) for _, row in accepted.iterrows()]
    p_array = np.vstack(p_list)  # shape (n_accept, m_outcomes)

    # Step 2: Hierarchical clustering (Agglomerative) with cosine distance
    # We try different number of clusters (actions) from 1 up to min(10, n_accept)
    # and choose the smallest number of clusters that yields feasible agent costs.
    max_clusters = min(10, len(p_array))
    if max_clusters == 1:
        # Only one cluster possible
        labels = np.zeros(len(p_array), dtype=int)
        n_actions = 1
    else:
        # Precompute cosine distance matrix for efficiency
        dist_matrix = cosine_distances(p_array)
        feasible_labels = None
        feasible_costs = None
        feasible_centers = None

        # We'll try from 1 cluster up to max_clusters clusters
        for n_clusters in range(1, max_clusters + 1):
            clustering = AgglomerativeClustering(
                n_clusters=n_clusters,
                affinity='precomputed',
                linkage='average'
            )
            labels_try = clustering.fit_predict(dist_matrix)
            unique_labels = sorted(set(labels_try))
            n_actions_try = len(unique_labels)
            centers_try = np.zeros((n_actions_try, m_outcomes))
            for i, lab in enumerate(unique_labels):
                cluster_ps = p_array[labels_try == lab]
                center = cluster_ps.mean(axis=0)
                center = np.clip(center, 0, None)
                sum_center = center.sum()
                if sum_center > 0:
                    center /= sum_center
                else:
                    center = np.ones(m_outcomes) / m_outcomes
                centers_try[i] = center

            # Step 3: Infer minimal costs c_a satisfying IR and IC constraints
            eps_cost = 1e-8
            contract_acc = np.array(accepted['Contract'].tolist())
            contract_rej = np.array(rejected['Contract'].tolist()) if not rejected.empty else np.empty((0, m_outcomes))

            costs_try = np.zeros(n_actions_try)
            for a in range(n_actions_try):
                p_a = centers_try[a]
                assigned_acc_idx = np.where(labels_try == unique_labels[a])[0]
                if assigned_acc_idx.size > 0:
                    w_acc = contract_acc[assigned_acc_idx]
                    min_acc = np.min(w_acc @ p_a)
                else:
                    min_acc = 0.0

                if contract_rej.shape[0] > 0:
                    rej_vals = contract_rej @ p_a
                    max_rej = np.max(rej_vals)
                else:
                    max_rej = -np.inf

                cost_a = max(min_acc, max_rej + eps_cost)
                costs_try[a] = max(cost_a, 0.0)

            # Step 4: Validate IR and IC constraints strictly
            # Accepted logs: must have some action a with p_a @ w - c_a >= 0
            accept_utils = contract_acc @ centers_try.T - costs_try  # shape (n_accept, n_actions_try)
            accept_feasible = (accept_utils >= -eps_cost).any(axis=1)

            # Rejected logs: must have all actions a with p_a @ w - c_a < 0
            if contract_rej.shape[0] > 0:
                reject_utils = contract_rej @ centers_try.T - costs_try  # shape (n_reject, n_actions_try)
                reject_feasible = (reject_utils < eps_cost).all(axis=1)
            else:
                reject_feasible = np.array([True])

            if accept_feasible.all() and reject_feasible.all():
                feasible_labels = labels_try
                feasible_costs = costs_try
                feasible_centers = centers_try
                n_actions = n_actions_try
                break

        if feasible_labels is None:
            # If no feasible clustering found, fallback to one cluster with uniform p and zero cost
            return np.hstack([np.ones((1, m_outcomes)) / m_outcomes, np.zeros((1, 1))])

        labels = feasible_labels
        costs = feasible_costs
        centers = feasible_centers

    # Step 5: Assign rejected logs to nearest cluster center by cosine similarity (for completeness)
    # Not strictly necessary for output, but can be used for debugging or further refinement.
    # Here we only return centers and costs.

    # Final normalization and numerical stability
    centers = np.clip(centers, 0, None)
    centers /= centers.sum(axis=1, keepdims=True)
    costs = np.maximum(costs, 0.0)

    agent_setting = np.hstack([centers, costs[:, None]])
    return agent_setting
```
