```python
import numpy as np
import pandas as pd
from scipy.optimize import linprog
from sklearn.cluster import DBSCAN
from sklearn.metrics import silhouette_score
from sklearn.metrics.pairwise import cosine_distances

def agent_solver_v2(v: np.ndarray, content: list[dict]) -> np.ndarray:
    """
    Infer a valid agent setting (prob distributions over outcomes + costs)
    explaining the historical interaction logs between principal and agent,
    robustly incorporating both accepted and rejected contracts via proxy p
    inference, cosine-distance clustering with adaptive eps, and iterative
    cost refinement to satisfy IR and IC constraints.

    Args:
        v (np.ndarray): Principal's reward vector for 5 outcomes, shape (5,)
        content (list[dict]): Each dict contains
            - 'Contract': 5-dim payment vector,
            - 'Principal Utility': principal utility under contract,
            - 'Agent Action': 1 for accept, -1 for reject.

    Returns:
        np.ndarray: n x 6 matrix: first 5 cols are outcome probabilities (sum=1),
                    last column is agent cost (â‰¥0).
    """
    m_outcomes = v.shape[0]
    logs_df = pd.DataFrame(content)
    accepted = logs_df[logs_df['Agent Action'] == 1].reset_index(drop=True)
    rejected = logs_df[logs_df['Agent Action'] == -1].reset_index(drop=True)

    # If no acceptances, return trivial agent: uniform distribution, zero cost
    if accepted.empty:
        return np.hstack([np.ones((1, m_outcomes)) / m_outcomes, np.zeros((1, 1))])

    # --- Step 1: Infer agent outcome distributions p for accepted contracts ---
    # Solve LP for each accepted contract:
    #   maximize p @ w
    #   s.t. sum p = 1
    #        p @ (v - w) = principal utility u_p
    #        0 <= p <= 1
    def infer_p_for_accept(w, u_p):
        c = -np.array(w, dtype=np.float64)  # maximize p@w <=> minimize -p@w
        A_eq = np.vstack([np.ones(m_outcomes), v - w])
        b_eq = np.array([1.0, u_p], dtype=np.float64)
        bounds = [(0.0, 1.0)] * m_outcomes
        res = linprog(c, A_eq=A_eq, b_eq=b_eq, bounds=bounds, method='highs')
        if res.success:
            p = res.x
            p = np.clip(p, 0, None)
            s = p.sum()
            if s > 0:
                p /= s
            else:
                p = np.ones(m_outcomes) / m_outcomes
            return p
        else:
            return np.ones(m_outcomes) / m_outcomes

    p_accept_list = [infer_p_for_accept(row['Contract'], row['Principal Utility']) for _, row in accepted.iterrows()]
    p_accept = np.vstack(p_accept_list)

    # --- Step 2: Infer proxy p for rejected contracts ---
    # For rejected logs: minimize p@w s.t. sum p=1, 0<=p<=1
    # This approximates low agent expected payment explaining rejection.
    reject_contracts = np.array(rejected['Contract'].tolist()) if not rejected.empty else np.empty((0, m_outcomes))
    p_reject_list = []
    for w in reject_contracts:
        c = np.array(w, dtype=np.float64)
        A_eq = np.ones((1, m_outcomes))
        b_eq = np.array([1.0])
        bounds = [(0.0, 1.0)] * m_outcomes
        res = linprog(c, A_eq=A_eq, b_eq=b_eq, bounds=bounds, method='highs')
        if res.success:
            p = res.x
            p = np.clip(p, 0, None)
            s = p.sum()
            if s > 0:
                p /= s
            else:
                p = np.ones(m_outcomes) / m_outcomes
            p_reject_list.append(p)
        else:
            p_reject_list.append(np.ones(m_outcomes) / m_outcomes)
    p_reject = np.vstack(p_reject_list) if p_reject_list else np.empty((0, m_outcomes))

    # --- Step 3: Combine p's and cluster with DBSCAN using cosine distance ---
    combined_p = np.vstack([p_accept, p_reject]) if p_reject.shape[0] > 0 else p_accept.copy()
    n_accept = p_accept.shape[0]
    n_reject = p_reject.shape[0]

    # Adaptive eps selection by silhouette score over candidate epsilons
    eps_candidates = np.linspace(0.05, 0.3, 6)
    best_eps = None
    best_score = -np.inf
    best_labels = None

    for eps in eps_candidates:
        clustering = DBSCAN(eps=eps, min_samples=2, metric='cosine').fit(combined_p)
        labels = clustering.labels_
        # Ignore if all noise or single cluster
        if len(set(labels)) <= 1 or np.all(labels == -1):
            continue
        mask = labels != -1
        if np.sum(mask) < 2:
            continue
        try:
            score = silhouette_score(combined_p[mask], labels[mask], metric='cosine')
        except Exception:
            continue
        if score > best_score:
            best_score = score
            best_eps = eps
            best_labels = labels

    # Fallback if no good clustering
    if best_labels is None:
        # Assign all accepted to one cluster, rejected as noise (-1)
        best_labels = np.concatenate([np.zeros(n_accept, dtype=int), -np.ones(n_reject, dtype=int)])

    labels = best_labels
    clustered_mask = labels != -1
    clustered_p = combined_p[clustered_mask]
    clustered_labels = labels[clustered_mask]
    if clustered_labels.size == 0:
        # Fallback to single action uniform distribution zero cost
        return np.hstack([np.ones((1, m_outcomes)) / m_outcomes, np.zeros((1, 1))])

    n_actions = clustered_labels.max() + 1

    # --- Step 4: Compute cluster centers (mean p per cluster) ---
    centers = np.zeros((n_actions, m_outcomes), dtype=np.float64)
    for a in range(n_actions):
        cluster_ps = clustered_p[clustered_labels == a]
        if cluster_ps.shape[0] == 0:
            centers[a] = np.ones(m_outcomes) / m_outcomes
        else:
            mean_p = cluster_ps.mean(axis=0)
            mean_p = np.clip(mean_p, 0, None)
            s = mean_p.sum()
            if s > 0:
                mean_p /= s
            else:
                mean_p = np.ones(m_outcomes) / m_outcomes
            centers[a] = mean_p

    # --- Step 5: Assign accepted logs to closest cluster by cosine distance ---
    dist_acc = cosine_distances(p_accept, centers)
    accepted_assign = dist_acc.argmin(axis=1)

    contract_accept = np.array(accepted['Contract'].tolist(), dtype=np.float64)
    contract_reject = reject_contracts  # already np.array

    eps_cost = 1e-7
    costs = np.zeros(n_actions, dtype=np.float64)

    for a in range(n_actions):
        p_a = centers[a]

        # Accepted assigned to cluster a
        idx_acc = np.where(accepted_assign == a)[0]
        if idx_acc.size > 0:
            w_acc = contract_accept[idx_acc]
            max_acc = np.max(w_acc @ p_a)
        else:
            max_acc = 0.0

        # Rejected contracts
        if contract_reject.shape[0] > 0:
            rej_vals = contract_reject @ p_a
            max_rej = rej_vals.max()
        else:
            max_rej = -np.inf

        # Cost must satisfy IR and IC:
        # c_a >= max_acc (IR)
        # c_a > max_rej (IC)
        cost_a = max(max_acc, max_rej + eps_cost)
        costs[a] = max(cost_a, 0.0)

    # --- Step 6: Iterative refinement of costs to satisfy IR and IC constraints ---
    max_iters = 30
    for _ in range(max_iters):
        # Accepted utilities: shape (n_accept, n_actions)
        accept_utils = contract_accept @ centers.T - costs[None, :]
        accept_max_util = accept_utils.max(axis=1)
        violated_accept = np.where(accept_max_util < -eps_cost)[0]

        # Rejected utilities: shape (n_reject, n_actions)
        if contract_reject.shape[0] > 0:
            reject_utils = contract_reject @ centers.T - costs[None, :]
            reject_max_util = reject_utils.max(axis=1)
            violated_reject = np.where(reject_max_util >= -eps_cost)[0]
        else:
            violated_reject = np.array([], dtype=int)

        if violated_accept.size == 0 and violated_reject.size == 0:
            break  # all constraints satisfied

        # Fix accept violations by increasing cost of best action for that log to ensure utility >= 0
        for idx in violated_accept:
            w = contract_accept[idx]
            utilities = centers @ w - costs
            best_a = np.argmax(utilities)
            required_cost = centers[best_a] @ w
            if costs[best_a] < required_cost:
                costs[best_a] = required_cost

        # Fix reject violations by increasing costs of all violating actions
        for idx in violated_reject:
            w = contract_reject[idx]
            utilities = centers @ w - costs
            violating_actions = np.where(utilities >= -eps_cost)[0]
            for a in violating_actions:
                required_cost = centers[a] @ w + eps_cost
                if costs[a] < required_cost:
                    costs[a] = required_cost

    # --- Step 7: Final normalization and output ---
    centers = np.clip(centers, 0, None)
    centers /= centers.sum(axis=1, keepdims=True)
    costs = np.maximum(costs, 0.0)

    agent_setting = np.hstack([centers, costs[:, None]])
    return agent_setting
```
