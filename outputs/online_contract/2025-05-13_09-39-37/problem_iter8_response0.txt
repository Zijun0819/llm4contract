```python
import numpy as np
import pandas as pd
from scipy.optimize import linprog
from sklearn.cluster import AgglomerativeClustering

def agent_solver_v2(v: np.ndarray, content: list[dict]) -> np.ndarray:
    """
    Infer a valid agent setting (prob distributions over outcomes + costs)
    explaining the historical interaction logs between principal and agent,
    adaptively selecting number of actions and iteratively adjusting costs
    to satisfy IR and IC constraints with tighter tolerances and more stable clustering.

    Args:
        v (np.ndarray): Principal's reward vector for 5 outcomes, shape (5,)
        content (list[dict]): Each dict contains
            - 'Contract': 5-dim payment vector,
            - 'Principal Utility': principal utility under contract,
            - 'Agent Action': 1 for accept, -1 for reject.

    Returns:
        np.ndarray: n x 6 matrix: first 5 cols are outcome probabilities (sum=1),
                    last column is agent cost (â‰¥0).
    """
    m = v.shape[0]
    logs_df = pd.DataFrame(content)
    accepted = logs_df[logs_df['Agent Action'] == 1].reset_index(drop=True)
    rejected = logs_df[logs_df['Agent Action'] == -1].reset_index(drop=True)

    # If no accepted logs, return trivial agent: uniform dist + zero cost
    if accepted.empty:
        uniform_p = np.ones(m) / m
        return np.hstack([uniform_p.reshape(1, -1), np.zeros((1,1))])

    # LP to infer agent outcome distribution p for each accepted contract
    def infer_p_for_log(w, u_p):
        # maximize p @ w <=> minimize -p @ w
        c = -np.array(w, dtype=np.float64)
        A_eq = np.vstack([np.ones(m), v - w])
        b_eq = np.array([1.0, u_p], dtype=np.float64)
        bounds = [(0, 1) for _ in range(m)]
        res = linprog(c=c, A_eq=A_eq, b_eq=b_eq, bounds=bounds, method='highs')
        if res.success:
            p = res.x
            p = np.clip(p, 0, None)
            s = p.sum()
            if s > 0:
                p /= s
            else:
                p = np.ones(m) / m
            return p
        # fallback uniform if LP fails
        return np.ones(m) / m

    p_list = [infer_p_for_log(row['Contract'], row['Principal Utility']) for _, row in accepted.iterrows()]
    p_array = np.vstack(p_list)  # shape (n_accept, m)

    # Hierarchical clustering with tighter distance threshold for stable adaptive clusters
    clustering = AgglomerativeClustering(distance_threshold=0.12, n_clusters=None, linkage='average')
    labels = clustering.fit_predict(p_array)
    n_actions = labels.max() + 1

    # Compute cluster centers (mean p per cluster), normalize properly
    centers = np.zeros((n_actions, m), dtype=np.float64)
    for a in range(n_actions):
        cluster_ps = p_array[labels == a]
        c = cluster_ps.mean(axis=0)
        c = np.clip(c, 0, None)
        s = c.sum()
        if s > 0:
            c /= s
        else:
            c = np.ones(m) / m
        centers[a] = c

    accepted_contracts = np.array(accepted['Contract'].tolist(), dtype=np.float64)
    rejected_contracts = (np.array(rejected['Contract'].tolist(), dtype=np.float64)
                         if not rejected.empty else np.empty((0, m), dtype=np.float64))

    eps = 1e-10  # tighter epsilon for strict inequalities
    costs = np.zeros(n_actions, dtype=np.float64)

    # Initialize costs via LP per action to satisfy IR and IC constraints conservatively
    # We solve min cost subject to:
    #   For accepted contracts assigned to action a: cost >= expected payment p_a @ w_i
    #   For rejected contracts: cost > expected payment p_a @ w_j (strict + eps)
    # Use max of these constraints as initial cost
    for a in range(n_actions):
        p_a = centers[a]

        accepted_idx = np.where(labels == a)[0]
        if accepted_idx.size > 0:
            w_acc = accepted_contracts[accepted_idx]
            max_acc = np.max(w_acc @ p_a)
        else:
            max_acc = 0.0

        if rejected_contracts.shape[0] > 0:
            rej_vals = rejected_contracts @ p_a
            max_rej = rej_vals.max()
        else:
            max_rej = -np.inf

        cost_a = max(max_acc, max_rej + eps)
        costs[a] = max(cost_a, 0.0)

    max_iters = 40
    for _ in range(max_iters):
        prev_costs = costs.copy()

        # Agent utilities for accepted contracts: shape (n_accept, n_actions)
        accept_utils = accepted_contracts @ centers.T - costs
        accept_best_util = accept_utils.max(axis=1)
        accept_best_action = accept_utils.argmax(axis=1)

        # Check accepted contracts IR: utility >= 0 (allow small margin)
        accept_violations = accept_best_util < eps

        # Agent utilities for rejected contracts: shape (n_reject, n_actions)
        if rejected_contracts.shape[0] > 0:
            reject_utils = rejected_contracts @ centers.T - costs
            reject_max_util = reject_utils.max(axis=1)
            # IC requires all utilities < 0 (strict)
            reject_violations = reject_max_util >= -eps
        else:
            reject_violations = np.array([], dtype=bool)

        # If no violations, break early
        if not accept_violations.any() and not reject_violations.any():
            break

        # Fix accept violations: decrease costs of best action for violating accepted contracts
        if accept_violations.any():
            violating_idxs = np.where(accept_violations)[0]
            for idx in violating_idxs:
                best_a = accept_best_action[idx]
                # Decrease cost slightly but keep non-negative
                costs[best_a] = max(costs[best_a] - eps * 10, 0.0)

        # Fix reject violations: increase costs globally to restore IC strictly
        if reject_violations.any():
            costs += eps * 20
            costs = np.maximum(costs, 0.0)

        # If costs changed insignificantly, break
        if np.allclose(costs, prev_costs, atol=eps):
            break

    # Final normalization of centers to ensure valid distributions
    centers = np.clip(centers, 0, None)
    centers_sum = centers.sum(axis=1, keepdims=True)
    centers_sum[centers_sum == 0] = 1.0
    centers /= centers_sum

    costs = np.maximum(costs, 0.0)

    agent_setting = np.hstack([centers, costs[:, None]])
    return agent_setting
```
