```python
import numpy as np
import pandas as pd
from scipy.optimize import linprog
from sklearn.cluster import AgglomerativeClustering

def agent_solver_v2(v: np.ndarray, content: list[dict]) -> np.ndarray:
    """
    Infer a valid agent setting (prob distributions over outcomes + costs)
    explaining the historical interaction logs between principal and agent,
    incorporating both accepted and rejected logs jointly for robust inference.

    Args:
        v (np.ndarray): Principal's reward vector for 5 outcomes, shape (5,)
        content (list[dict]): Each dict contains
            - 'Contract': 5-dim payment vector,
            - 'Principal Utility': principal utility under contract,
            - 'Agent Action': 1 for accept, -1 for reject.

    Returns:
        np.ndarray: n x 6 matrix: first 5 cols are outcome probabilities (sum=1),
                    last column is agent cost (â‰¥0).
    """
    m_outcomes = v.shape[0]
    logs_df = pd.DataFrame(content)
    accepted = logs_df[logs_df['Agent Action'] == 1].reset_index(drop=True)
    rejected = logs_df[logs_df['Agent Action'] == -1].reset_index(drop=True)

    # If no accepted logs, return trivial agent: uniform dist + zero cost
    if accepted.empty:
        return np.hstack([np.ones((1, m_outcomes)) / m_outcomes, np.zeros((1, 1))])

    # LP to infer p for each accepted contract by maximizing agent expected wage p @ w
    def infer_p_for_log(w, u_p):
        c_obj = -np.array(w)  # maximize p @ w <=> minimize -p @ w
        A_eq = [np.ones(m_outcomes), v - w]
        b_eq = [1.0, u_p]
        bounds = [(0, 1) for _ in range(m_outcomes)]
        res = linprog(c=c_obj, A_eq=A_eq, b_eq=b_eq, bounds=bounds, method='highs')
        if res.success:
            p = res.x
            p = np.clip(p, 0, None)
            s = p.sum()
            if s > 0:
                p /= s
            else:
                p = np.ones(m_outcomes) / m_outcomes
            return p
        else:
            # fallback uniform
            return np.ones(m_outcomes) / m_outcomes

    # Infer p for accepted logs
    p_accept = np.vstack([infer_p_for_log(row['Contract'], row['Principal Utility']) for _, row in accepted.iterrows()])

    # For rejected logs, infer feasible p with agent utility < 0 (strictly negative)
    # Solve feasibility LP: sum p=1, p>=0, p@(v-w) <= -eps
    eps_rej = 1e-4
    reject_contracts = np.array(rejected['Contract'].tolist()) if not rejected.empty else np.empty((0, m_outcomes))
    p_reject = []
    for w in reject_contracts:
        c_obj = np.zeros(m_outcomes)
        A_eq = [np.ones(m_outcomes)]
        b_eq = [1.0]
        A_ub = [v - w]
        b_ub = [-eps_rej]
        bounds = [(0, 1) for _ in range(m_outcomes)]
        res = linprog(c=c_obj, A_eq=A_eq, b_eq=b_eq, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')
        if res.success:
            p = res.x
            p = np.clip(p, 0, None)
            s = p.sum()
            if s > 0:
                p /= s
            else:
                p = np.ones(m_outcomes) / m_outcomes
            p_reject.append(p)
        else:
            # fallback uniform distribution
            p_reject.append(np.ones(m_outcomes) / m_outcomes)
    p_reject = np.vstack(p_reject) if len(p_reject) > 0 else np.empty((0, m_outcomes))

    # Combine all inferred p's for clustering
    p_all = np.vstack([p_accept, p_reject]) if p_reject.size > 0 else p_accept.copy()

    # Adaptive hierarchical clustering on p_all with cosine distance and distance_threshold
    # to find distinct agent actions
    clustering = AgglomerativeClustering(n_clusters=None, distance_threshold=0.15, affinity='cosine', linkage='average')
    labels = clustering.fit_predict(p_all)
    n_actions = labels.max() + 1

    # Compute cluster centers (mean p per cluster), normalize to sum=1
    centers = np.zeros((n_actions, m_outcomes))
    for a in range(n_actions):
        cluster_ps = p_all[labels == a]
        c = cluster_ps.mean(axis=0)
        c = np.clip(c, 0, None)
        s = c.sum()
        if s > 0:
            c /= s
        else:
            c = np.ones(m_outcomes) / m_outcomes
        centers[a] = c

    accepted_contracts = np.array(accepted['Contract'].tolist())
    rejected_contracts = reject_contracts  # already np.array

    eps_cost = 1e-7
    max_iters = 30
    costs = np.zeros(n_actions)

    # Assign accepted logs to clusters by nearest center (cosine similarity)
    # cosine similarity = 1 - cosine distance
    from sklearn.metrics.pairwise import cosine_distances
    dist_accept = cosine_distances(p_accept, centers)  # shape (n_accept, n_actions)
    assigned_accept = dist_accept.argmin(axis=1)

    # Iteratively update costs to satisfy IR and IC constraints strictly
    for _ in range(max_iters):
        prev_costs = costs.copy()

        # IR: For each action, cost <= minimal expected payment over accepted logs assigned to that action
        for a in range(n_actions):
            idxs = np.where(assigned_accept == a)[0]
            if idxs.size > 0:
                vals = accepted_contracts[idxs] @ centers[a]
                min_val = vals.min()
                costs[a] = min(costs[a], min_val) if costs[a] > 0 else min_val
            else:
                # No accepted logs assigned: keep current or zero
                costs[a] = max(costs[a], 0.0)

        # IC: For each action, cost > maximal expected payment over all rejected logs
        if rejected_contracts.shape[0] > 0:
            for a in range(n_actions):
                rej_vals = rejected_contracts @ centers[a]
                max_rej = rej_vals.max()
                if costs[a] <= max_rej:
                    costs[a] = max_rej + eps_cost

        # Enforce non-negativity
        costs = np.clip(costs, 0, None)

        if np.allclose(costs, prev_costs, atol=eps_cost):
            break

    # Final validation and slight relaxation if needed

    # Accepted logs feasibility: at least one action with expected utility >= 0
    accept_utils = accepted_contracts @ centers.T - costs  # shape (n_accept, n_actions)
    accept_feasible = (accept_utils >= -eps_cost).any(axis=1)
    if not accept_feasible.all():
        # Relax costs slightly upwards to fix
        costs += eps_cost * 10
        costs = np.clip(costs, 0, None)

    # Rejected logs feasibility: all actions have expected utility < 0
    if rejected_contracts.shape[0] > 0:
        reject_utils = rejected_contracts @ centers.T - costs  # shape (n_reject, n_actions)
        reject_feasible = (reject_utils < eps_cost).all(axis=1)
        if not reject_feasible.all():
            # Increase costs to enforce IC strictly
            costs += eps_cost * 50
            costs = np.clip(costs, 0, None)

    # Normalize centers again for numerical stability
    centers = np.clip(centers, 0, None)
    centers /= centers.sum(axis=1, keepdims=True)

    agent_setting = np.hstack([centers, costs[:, None]])

    return agent_setting
```
