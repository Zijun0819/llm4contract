```python
import numpy as np
import pandas as pd
from scipy.optimize import linprog
from sklearn.cluster import AgglomerativeClustering


def agent_solver_v2(v: np.ndarray, content: list[dict]) -> np.ndarray:
    """
    Infer a valid agent setting matrix (actions x [5 outcome probs + cost])
    from historical logs of contracts, principal utilities, and agent actions.

    Parameters:
    - v: np.ndarray, principal's reward vector for 5 outcomes (shape (5,))
    - content: list of dicts with keys 'Contract' (list of 5 payments),
               'Principal Utility' (float), and 'Agent Action' (1 or -1).

    Returns:
    - agent_setting: np.ndarray with shape (n_actions, 6),
                     columns 0-4 are outcome distributions (sum to 1),
                     column 5 is agent cost (non-negative).
    """
    m = v.shape[0]  # number of outcomes, expected 5
    L = len(content)

    # Extract data arrays for easier manipulation
    contracts = np.array([log['Contract'] for log in content])  # (L,5)
    p_utils = np.array([log['Principal Utility'] for log in content])  # (L,)
    agent_actions = np.array([log['Agent Action'] for log in content])  # (L,)

    # Separate accepted and rejected contracts
    accept_mask = agent_actions == 1
    reject_mask = agent_actions == -1
    c_accept = contracts[accept_mask]   # accepted contracts (n_acc,5)
    u_accept = p_utils[accept_mask]     # principal utilities for accepted (n_acc,)
    c_reject = contracts[reject_mask]   # rejected contracts (n_rej,5)

    # Step 1: Infer candidate outcome distributions p for accepted contracts
    # For each accepted contract: p @ w = principal utility + agent cost >= 0,
    # but agent cost unknown. We'll approximate p by solving LP:
    # maximize alignment with wages subject to sum p=1, p>=0, and p @ w >= 0
    # Instead, here we find a "plausible" p vector for each accepted contract
    # that fits contract payments and principal utility.

    def infer_p_for_contract(w, u):
        # Solve LP: find p >=0, sum p=1, s.t p @ w = u + c, for some c >=0
        # Since c unknown, we try to find p minimizing c = p @ w - u >= 0
        # minimize c => minimize p @ w subject to sum p=1, p>=0, p @ w >= u
        # But p @ w >= u must hold, so we set constraint p @ w >= u
        # To avoid infeasibility with u possibly > max(w), relax by minimizing ||p-w||^2 with sum=1 and p>=0
        # Here we do a quadratic projection to simplex with additional linear constraint p@w >= u
        # To keep code simple, we do linprog to minimize p@w (min c), with sum p=1, p>=0, p@w >= u
        # If infeasible, relax constraint p@w >= u to p@w >= u - tol

        tol = 1e-8
        c_obj = w  # minimize p@w to get minimal cost c = p@w - u
        A_eq = [np.ones(m)]
        b_eq = [1.0]
        A_ub = [-w]
        b_ub = [-u + tol]

        res = linprog(c=c_obj, A_eq=A_eq, b_eq=b_eq, A_ub=A_ub, b_ub=b_ub, bounds=[(0,1)]*m, method='highs')
        if res.success:
            p = res.x
            # Clip negatives due to numerical errors
            p = np.clip(p, 0, 1)
            p /= p.sum()
            return p
        else:
            # fallback: uniform distribution
            return np.ones(m) / m

    p_candidates = []
    costs_lower_bound = []
    for w, u in zip(c_accept, u_accept):
        p = infer_p_for_contract(w, u)
        c = max(np.dot(p, w) - u, 0)
        p_candidates.append(p)
        costs_lower_bound.append(c)
    p_candidates = np.array(p_candidates)
    costs_lower_bound = np.array(costs_lower_bound)

    # Step 2: Cluster these inferred p vectors to find representative agent actions
    # Use Agglomerative clustering to adaptively select number of clusters based on distance threshold
    clustering = AgglomerativeClustering(n_clusters=None, distance_threshold=0.15, linkage='ward')
    labels = clustering.fit_predict(p_candidates)
    n_actions = labels.max() + 1

    # Compute cluster centers as mean of p's in cluster
    p_centers = np.zeros((n_actions, m))
    for a in range(n_actions):
        cluster_ps = p_candidates[labels == a]
        p_centers[a] = cluster_ps.mean(axis=0)
        # Normalize to ensure sum=1 (numerical safety)
        p_centers[a] = np.clip(p_centers[a], 0, None)
        p_centers[a] /= p_centers[a].sum()

    # Step 3: Infer agent costs per action respecting IR and IC constraints
    # IR: accepted contracts with assigned action have agent utility >=0
    # IC: no accepted contract is better for another action
    # Also rejected contracts utility < 0 for all actions

    # Assign each accepted contract to closest cluster center by L2 distance on p
    assign_accept = np.zeros(len(c_accept), dtype=int)
    for i, p in enumerate(p_candidates):
        dists = np.linalg.norm(p_centers - p, axis=1)
        assign_accept[i] = dists.argmin()

    # Prepare constraints for costs c_a >= 0
    # We want to find c vector (length n_actions), non-negative

    # For each accepted contract i:
    # Agent utility for assigned action a_i: p_centers[a_i] @ w_i - c[a_i] >= 0  (IR)
    # For all other actions a != a_i: p_centers[a] @ w_i - c[a] <= p_centers[a_i] @ w_i - c[a_i]  (IC)
    # For each rejected contract j:
    # For all actions a: p_centers[a] @ w_j - c[a] < 0  (Rejection)

    # We rearrange these inequalities into standard LP form:
    # Variables: c = [c_0, ..., c_{n_actions-1}], shape (n_actions,)
    # Constraints:

    # IR per accepted contract i:
    # c[a_i] <= p_centers[a_i] @ w_i
    # IC per accepted contract i, action a != a_i:
    # p_centers[a] @ w_i - c[a] <= p_centers[a_i] @ w_i - c[a_i]
    # => c[a] - c[a_i] >= p_centers[a]@w_i - p_centers[a_i]@w_i
    # Rejection per rejected contract j, action a:
    # p_centers[a] @ w_j - c[a] < 0
    # => c[a] > p_centers[a] @ w_j

    # We will solve for c minimizing sum(c) (to keep costs minimal) subject to these constraints.

    from scipy.optimize import linprog

    num_vars = n_actions
    A_ub = []
    b_ub = []

    # IR constraints: c[a_i] <= p_centers[a_i]@w_i
    for i, w_i in enumerate(c_accept):
        a_i = assign_accept[i]
        ub_row = np.zeros(num_vars)
        ub_row[a_i] = 1.0
        A_ub.append(ub_row)
        b_ub.append(np.dot(p_centers[a_i], w_i))

    # IC constraints: for each accepted contract i, for all a != a_i:
    # c[a] - c[a_i] >= delta => -c[a] + c[a_i] <= -delta
    # where delta = p_centers[a]@w_i - p_centers[a_i]@w_i
    for i, w_i in enumerate(c_accept):
        a_i = assign_accept[i]
        for a in range(n_actions):
            if a == a_i:
                continue
            delta = np.dot(p_centers[a], w_i) - np.dot(p_centers[a_i], w_i)
            row = np.zeros(num_vars)
            row[a] = -1.0
            row[a_i] = 1.0
            A_ub.append(row)
            b_ub.append(-delta)

    # Rejection constraints: for each rejected contract j and action a:
    # c[a] > p_centers[a] @ w_j => -c[a] < -p_centers[a] @ w_j
    # convert strict to non-strict with small epsilon
    eps = 1e-6
    for w_j in c_reject:
        for a in range(n_actions):
            row = np.zeros(num_vars)
            row[a] = -1.0
            A_ub.append(row)
            b_ub.append(-np.dot(p_centers[a], w_j) - eps)

    # Non-negativity bounds for costs
    bounds = [(0, None)] * num_vars

    A_ub = np.array(A_ub)
    b_ub = np.array(b_ub)

    # Objective: minimize sum of costs (to get minimal consistent cost vector)
    c_obj = np.ones(num_vars)

    res = linprog(c=c_obj, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')

    if res.success:
        costs = res.x
    else:
        # If infeasible, fallback to maximal IR lower bound from accepted contracts
        costs = np.zeros(num_vars)
        for a in range(num_vars):
            mask = assign_accept == a
            if np.any(mask):
                costs[a] = np.max([np.dot(p_centers[a], c_accept[i]) - u_accept[i] for i in np.where(mask)[0]])
            else:
                costs[a] = 0.0
        costs = np.clip(costs, 0, None)

    # Final output: concatenate p_centers and costs column
    agent_setting = np.hstack([p_centers, costs.reshape(-1, 1)])

    return agent_setting
```
