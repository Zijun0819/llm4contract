```python
import numpy as np
import pandas as pd
from scipy.optimize import linprog
from sklearn.cluster import DBSCAN


def agent_solver(v: np.ndarray, content: pd.DataFrame) -> np.ndarray:
    """
    Infer a valid agent setting (actions as outcome distributions + costs) that explains historical contracts.
    Args:
        v (np.ndarray): Principal's reward vector of length 5.
        content (pd.DataFrame): Interaction logs with columns 'Contract', 'Principal Utility', 'Agent Action'.
                                'Contract' is a list/np.array of length 5 payment vector.
                                'Principal Utility' is float.
                                'Agent Action' is int: 1 (accept) or -1 (reject).
    Returns:
        np.ndarray: n x 6 matrix where each row is [p_1,...,p_5, cost], p_j >=0, sum p_j=1, cost >=0.
    """

    m = v.shape[0]  # number of outcomes, m=5
    logs = content.copy()
    L = len(logs)

    # Preprocess: extract arrays for convenience
    contracts = np.array(logs['Contract'].tolist())  # shape (L,5)
    principal_utils = np.array(logs['Principal Utility'].tolist())  # (L,)
    agent_actions = np.array(logs['Agent Action'].tolist())  # (L,)

    # Step 1: Separate accepted and rejected contracts
    accepted_idx = np.where(agent_actions == 1)[0]
    rejected_idx = np.where(agent_actions == -1)[0]

    # Step 2: Infer candidate outcome distributions p for accepted contracts
    # Use LP to find p s.t. p @ w = principal utility + agent cost (unknown)
    # Since cost unknown, approximate p by solving for p s.t. p@w approx = principal utility + cost
    # We try to find p satisfying p @ w close to principal utility + some cost >=0
    # But cost unknown, so for each accepted contract, find p that maximizes p @ w subject to sum p=1, p >=0
    # We try to get p that maximizes p @ w approx principal utility + c, but unknown c.
    # Instead, find p that maximizes p @ w, then cluster these p's to find representative actions.

    # For each accepted contract, find p maximizing p @ w (since utility >=0)
    candidate_ps = []
    for i in accepted_idx:
        w = contracts[i]
        # Solve LP: max_p p @ w s.t sum p=1, p>=0
        # Equivalent to max of linear function over simplex => put all mass on max w_j
        # But to get a smoother p, solve LP with entropy regularization is complex,
        # here just assign prob 1 to max w_j
        p = np.zeros(m)
        p[np.argmax(w)] = 1.0
        candidate_ps.append(p)

    candidate_ps = np.array(candidate_ps)
    if len(candidate_ps) == 0:
        # No accepted contracts, return trivial single action uniform with zero cost
        uniform_p = np.ones(m) / m
        return np.hstack([uniform_p.reshape(1, -1), np.array([[0]])])

    # Step 3: Cluster candidate p vectors to find distinct actions
    # Use DBSCAN clustering on candidate_ps - robust to number of clusters, can find noise
    clustering = DBSCAN(eps=0.05, min_samples=1).fit(candidate_ps)
    labels = clustering.labels_
    unique_labels = np.unique(labels)
    n_actions = len(unique_labels)

    # Compute cluster centers (mean p of each cluster)
    p_centers = np.zeros((n_actions, m))
    for i, label in enumerate(unique_labels):
        mask = labels == label
        cluster_ps = candidate_ps[mask]
        mean_p = cluster_ps.mean(axis=0)
        mean_p = np.clip(mean_p, 0, None)
        mean_p /= mean_p.sum()
        p_centers[i] = mean_p

    # Step 4: For each accepted contract, assign best action (max p @ w)
    assigns = -np.ones(L, dtype=int)
    for i in accepted_idx:
        w = contracts[i]
        values = p_centers @ w
        assigns[i] = int(np.argmax(values))

    # Step 5: Infer cost for each action to satisfy IR and IC constraints

    # Define variables: costs c_a >= 0 for each action a

    # Constraints:
    # For accepted contracts:
    # For contract i assigned to action a: p_centers[a] @ w_i - c_a >= 0 (IR)
    # For rejected contracts i:
    # For all actions a: p_centers[a] @ w_i - c_a < 0 (reject means no action yields nonnegative utility)

    # Set up LP to find costs c_a minimizing sum c_a (or zero, just feasibility)
    # Use linprog to solve feasibility:
    # Constraints as inequalities of form A_ub x <= b_ub with x = c vector

    from scipy.optimize import linprog

    c_var = np.zeros(n_actions)  # costs variable vector to solve for

    # For accepted logs constraints:
    # -p_centers[a] @ w_i + c_a <= 0  => for each accepted i
    A_ub_list = []
    b_ub_list = []

    for i in accepted_idx:
        a = assigns[i]
        w = contracts[i]
        row = np.zeros(n_actions)
        row[a] = 1  # c_a coefficient +1
        val = p_centers[a] @ w
        A_ub_list.append(-row)  # -c_a <= -val  => c_a >= val
        b_ub_list.append(-val)

    # For rejected logs constraints:
    # For each rejected i and each action a: p_centers[a] @ w_i - c_a < 0
    # i.e. c_a > p_centers[a] @ w_i  => -c_a < -p_centers[a]@w_i
    # In LP form: -c_a <= -p_centers[a]@w_i - epsilon (strict < replaced by slack epsilon)
    epsilon = 1e-5
    for i in rejected_idx:
        w = contracts[i]
        for a in range(n_actions):
            row = np.zeros(n_actions)
            row[a] = -1
            val = p_centers[a] @ w - epsilon
            A_ub_list.append(row)
            b_ub_list.append(-val)

    A_ub = np.vstack(A_ub_list) if A_ub_list else None
    b_ub = np.array(b_ub_list) if b_ub_list else None

    bounds = [(0, None)] * n_actions  # costs non-negative

    # Objective: minimize sum costs (or zeros just find feasible)
    obj = np.ones(n_actions)

    # Solve LP
    res = linprog(obj, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')

    if res.success:
        costs = res.x
    else:
        # If no feasible solution, relax rejected constraints by removing them once
        if A_ub is not None and b_ub is not None and len(rejected_idx) > 0:
            # Remove rejected constraints and solve again
            # Keep only accepted constraints
            A_ub_acc = np.vstack(A_ub_list[:len(accepted_idx)])
            b_ub_acc = np.array(b_ub_list[:len(accepted_idx)])
            res2 = linprog(obj, A_ub=A_ub_acc, b_ub=b_ub_acc, bounds=bounds, method='highs')
            if res2.success:
                costs = res2.x
            else:
                # Last resort: zero costs (may violate IR/IC slightly)
                costs = np.zeros(n_actions)
        else:
            costs = np.zeros(n_actions)

    # Step 6: Return agent setting matrix [p_centers, costs]

    agent_setting = np.hstack([p_centers, costs.reshape(-1, 1)])

    return agent_setting
```
