```python
import numpy as np
import pandas as pd
from sklearn.cluster import AgglomerativeClustering
from sklearn.metrics import silhouette_score
from scipy.optimize import linprog
from sklearn.metrics.pairwise import cosine_similarity

def agent_solver(v: np.ndarray, content: list[dict]) -> np.ndarray:
    """
    Infer a valid agent setting (probability distributions over outcomes + costs)
    explaining the historical interaction logs between principal and agent,
    by jointly clustering accepted and rejected logs' inferred outcome distributions,
    and inferring costs to satisfy IR and IC constraints.

    Args:
        v (np.ndarray): Principal's reward vector for 5 outcomes, shape (5,)
        content (list[dict]): Each dict contains:
            - 'Contract': 5-dim payment vector,
            - 'Principal Utility': principal utility under contract,
            - 'Agent Action': 1 for accept, -1 for reject.

    Returns:
        np.ndarray: n x 6 matrix: first 5 cols are outcome probabilities (sum=1),
                    last column is agent cost (â‰¥0).
    """
    m_outcomes = v.shape[0]
    logs_df = pd.DataFrame(content)
    accepted = logs_df[logs_df['Agent Action'] == 1].reset_index(drop=True)
    rejected = logs_df[logs_df['Agent Action'] == -1].reset_index(drop=True)

    # If no accepted contracts, return trivial agent with uniform dist and zero cost
    if accepted.empty:
        return np.hstack([np.ones((1, m_outcomes)) / m_outcomes, np.zeros((1, 1))])

    # Step 1: Infer p for each accepted and rejected contract by LP
    # For accepted: p s.t. sum p=1, p@(v-w)=Principal Utility, maximize p@w (agent expected payment)
    # For rejected: p s.t. sum p=1, p@(v-w) < 0 (agent utility < 0), maximize p@w

    def infer_p_for_log(w, u_p, accept):
        # Variables: p (length m_outcomes)
        # Constraints:
        #   sum p = 1
        #   if accept: p@(v - w) = u_p  (agent utility >=0)
        #   if reject: p@(v - w) <= u_p (u_p < 0; use inequality)
        # Bounds: p_i in [0,1]
        # Objective: maximize p @ w (agent expected payment)
        c_obj = -np.array(w)
        A_eq = [np.ones(m_outcomes)]
        b_eq = [1.0]
        A_ub = []
        b_ub = []

        if accept:
            # equality constraint for agent utility = u_p
            A_eq.append(v - np.array(w))
            b_eq.append(u_p)
        else:
            # inequality constraint for agent utility < 0 (agent utility < 0)
            A_ub.append(v - np.array(w))
            b_ub.append(u_p)  # u_p < 0

        bounds = [(0, 1) for _ in range(m_outcomes)]

        try:
            if accept:
                res = linprog(c=c_obj, A_eq=A_eq, b_eq=b_eq, bounds=bounds, method='highs')
            else:
                res = linprog(c=c_obj, A_eq=A_eq, b_eq=b_eq, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')
            if res.success:
                p = res.x
                p = np.clip(p, 0, None)
                s = p.sum()
                if s > 0:
                    p /= s
                else:
                    p = np.ones(m_outcomes) / m_outcomes
                return p
        except Exception:
            pass
        # fallback uniform
        return np.ones(m_outcomes) / m_outcomes

    p_accept = [infer_p_for_log(row['Contract'], row['Principal Utility'], True) for _, row in accepted.iterrows()]
    p_reject = [infer_p_for_log(row['Contract'], row['Principal Utility'], False) for _, row in rejected.iterrows()] if not rejected.empty else []

    # Combine all p's and label accepted=1, rejected=0 for clustering
    p_all = np.vstack(p_accept + p_reject) if p_reject else np.vstack(p_accept)
    labels_true = np.array([1]*len(p_accept) + [0]*len(p_reject)) if p_reject else np.array([1]*len(p_accept))

    # Step 2: Hierarchical clustering with cosine affinity and ward linkage (ward requires euclidean, so use average linkage)
    # We want to find stable clusters explaining both accepted and rejected logs
    # Try cluster numbers from 2 to min(10, n_samples)
    n_samples = p_all.shape[0]
    max_clusters = min(10, n_samples)
    best_score = -1
    best_n_clusters = 1
    best_labels = np.zeros(n_samples, dtype=int)

    if n_samples < 2:
        # Not enough samples to cluster, fallback single cluster
        best_n_clusters = 1
        best_labels = np.zeros(n_samples, dtype=int)
    else:
        for k in range(2, max_clusters + 1):
            try:
                clustering = AgglomerativeClustering(n_clusters=k, affinity='cosine', linkage='average')
                cluster_labels = clustering.fit_predict(p_all)
                # silhouette_score requires at least 2 clusters and no all same labels
                sil = silhouette_score(p_all, cluster_labels, metric='cosine')
                if sil > best_score:
                    best_score = sil
                    best_n_clusters = k
                    best_labels = cluster_labels
            except Exception:
                continue

    # Step 3: Compute cluster centers (mean p per cluster), normalize and clip
    centers = np.zeros((best_n_clusters, m_outcomes))
    for i in range(best_n_clusters):
        cluster_points = p_all[best_labels == i]
        if cluster_points.shape[0] > 0:
            center = cluster_points.mean(axis=0)
            center = np.clip(center, 0, None)
            s = center.sum()
            if s > 0:
                center /= s
            else:
                center = np.ones(m_outcomes) / m_outcomes
            centers[i] = center
        else:
            centers[i] = np.ones(m_outcomes) / m_outcomes

    # Step 4: Infer minimal costs c_a satisfying IR and IC constraints
    # IR: For accepted contracts assigned to cluster a: p_a @ w - c_a >= 0 => c_a <= min p_a @ w
    # IC: For rejected contracts: for all a: p_a @ w - c_a < 0 => c_a > max p_a @ w among rejects

    contract_acc = np.array(accepted['Contract'].tolist())
    contract_rej = np.array(rejected['Contract'].tolist()) if not rejected.empty else np.empty((0, m_outcomes))

    # Assign accepted logs to clusters by nearest center (cosine similarity)
    sim_acc = cosine_similarity(np.vstack(p_accept), centers)
    assigned_acc = sim_acc.argmax(axis=1) if len(p_accept) > 0 else np.array([], dtype=int)

    costs = np.zeros(best_n_clusters)
    eps_cost = 1e-8

    for a in range(best_n_clusters):
        p_a = centers[a]
        # Accepted contracts assigned to cluster a
        idx_acc = np.where(assigned_acc == a)[0]
        if idx_acc.size > 0:
            w_acc = contract_acc[idx_acc]
            min_acc = np.min(w_acc @ p_a)
        else:
            min_acc = 0.0

        if contract_rej.shape[0] > 0:
            rej_vals = contract_rej @ p_a
            max_rej = np.max(rej_vals)
        else:
            max_rej = -np.inf

        cost_a = max(min_acc, max_rej + eps_cost)
        costs[a] = max(cost_a, 0.0)

    # Step 5: Validate and refine costs iteratively to ensure IR and IC hold
    max_iter = 30
    for _ in range(max_iter):
        # Accepted logs: must have some action a with p_a @ w - c_a >= 0
        accept_utils = contract_acc @ centers.T - costs  # shape (n_accept, n_actions)
        accept_feasible = (accept_utils >= -eps_cost).any(axis=1)

        # Rejected logs: must have all actions a with p_a @ w - c_a < 0
        if contract_rej.shape[0] > 0:
            reject_utils = contract_rej @ centers.T - costs  # shape (n_reject, n_actions)
            reject_feasible = (reject_utils < eps_cost).all(axis=1)
        else:
            reject_feasible = np.array([True])

        if accept_feasible.all() and reject_feasible.all():
            break

        # Increase costs slightly to enforce constraints
        costs += eps_cost * 10
        costs = np.maximum(costs, 0.0)

    # Final normalization for numerical stability
    centers = np.clip(centers, 0, None)
    centers /= centers.sum(axis=1, keepdims=True)
    costs = np.maximum(costs, 0.0)

    agent_setting = np.hstack([centers, costs[:, None]])
    return agent_setting
```
