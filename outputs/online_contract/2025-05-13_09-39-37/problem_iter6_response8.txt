```python
import numpy as np
import pandas as pd
from scipy.optimize import linprog
from sklearn.cluster import DBSCAN
from sklearn.metrics import silhouette_score
from scipy.spatial.distance import cdist

def agent_solver_v2(v: np.ndarray, content: list[dict]) -> np.ndarray:
    """
    Infer a valid agent setting (prob distributions over outcomes + costs)
    explaining the historical interaction logs between principal and agent,
    robustly incorporating both accepted and rejected contracts via agent
    utility constraints, Euclidean clustering with adaptive eps, and
    iterative, fine-grained cost refinement to satisfy IR and IC constraints.

    Args:
        v (np.ndarray): Principal's reward vector for 5 outcomes, shape (5,)
        content (list[dict]): Each dict contains
            - 'Contract': 5-dim payment vector,
            - 'Principal Utility': principal utility under contract,
            - 'Agent Action': 1 for accept, -1 for reject.

    Returns:
        np.ndarray: n x 6 matrix: first 5 cols are outcome probabilities (sum=1),
                    last column is agent cost (â‰¥0).
    """
    m_outcomes = v.shape[0]
    logs_df = pd.DataFrame(content)
    accepted = logs_df[logs_df['Agent Action'] == 1].reset_index(drop=True)
    rejected = logs_df[logs_df['Agent Action'] == -1].reset_index(drop=True)

    # If no accepted contracts, return trivial agent: uniform dist and zero cost
    if accepted.empty:
        uniform_p = np.ones(m_outcomes) / m_outcomes
        return np.hstack([uniform_p.reshape(1, -1), np.zeros((1, 1))])

    # --- Step 1: Infer p for accepted contracts via LP ---
    def infer_p_for_accept(w, u_p):
        # maximize p @ w s.t. sum p=1, p @ (v - w) = u_p, 0 <= p <= 1
        c = -np.array(w, dtype=np.float64)
        A_eq = np.vstack([np.ones(m_outcomes), v - w])
        b_eq = np.array([1.0, u_p], dtype=np.float64)
        bounds = [(0.0, 1.0)] * m_outcomes
        res = linprog(c=c, A_eq=A_eq, b_eq=b_eq, bounds=bounds, method='highs')
        if res.success:
            p = np.clip(res.x, 0, None)
            s = p.sum()
            if s > 0:
                p /= s
            else:
                p = np.ones(m_outcomes) / m_outcomes
            return p
        else:
            return np.ones(m_outcomes) / m_outcomes

    p_accept_list = [infer_p_for_accept(row['Contract'], row['Principal Utility']) for _, row in accepted.iterrows()]
    p_accept = np.vstack(p_accept_list)  # shape (n_accept, m_outcomes)

    # --- Step 2: Infer p for rejected contracts ensuring agent utility < 0 ---
    def infer_p_for_reject(w):
        # maximize p @ w s.t. sum p=1, p @ (v - w) <= -delta, 0 <= p <= 1
        delta = 1e-6
        c = -np.array(w, dtype=np.float64)
        A_eq = np.ones((1, m_outcomes))
        b_eq = np.array([1.0])
        A_ub = np.array([-(v - w)])
        b_ub = np.array([-delta])
        bounds = [(0.0, 1.0)] * m_outcomes
        res = linprog(c=c, A_eq=A_eq, b_eq=b_eq, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')
        if res.success:
            p = np.clip(res.x, 0, None)
            s = p.sum()
            if s > 0:
                p /= s
            else:
                p = np.ones(m_outcomes) / m_outcomes
            return p
        else:
            return np.ones(m_outcomes) / m_outcomes

    p_reject_list = [infer_p_for_reject(row['Contract']) for _, row in rejected.iterrows()]
    p_reject = np.vstack(p_reject_list) if p_reject_list else np.empty((0, m_outcomes))

    # --- Step 3: Combine and cluster p vectors using DBSCAN with Euclidean distance ---
    combined_p = np.vstack([p_accept, p_reject]) if p_reject.size else p_accept.copy()

    eps_candidates = np.linspace(0.05, 0.3, 7)
    best_eps = None
    best_score = -1
    best_labels = None
    for eps in eps_candidates:
        clustering = DBSCAN(eps=eps, min_samples=2, metric='euclidean').fit(combined_p)
        labels = clustering.labels_
        n_clusters = len(set(labels)) - (1 if -1 in labels else 0)
        if n_clusters < 2:
            continue
        try:
            score = silhouette_score(combined_p[labels != -1], labels[labels != -1])
            if score > best_score:
                best_score = score
                best_eps = eps
                best_labels = labels
        except Exception:
            continue

    if best_eps is None or best_labels is None:
        # fallback: single cluster (mean of accepted p)
        centers = np.mean(p_accept, axis=0, keepdims=True)
        centers = np.clip(centers, 0, None)
        s = centers.sum(axis=1, keepdims=True)
        s[s == 0] = 1.0
        centers /= s
        n_actions = 1
        costs = np.zeros(1)
    else:
        labels = best_labels
        valid_mask = labels != -1
        filtered_p = combined_p[valid_mask]
        filtered_labels = labels[valid_mask]
        unique_labels = np.unique(filtered_labels)
        n_actions = len(unique_labels)
        centers = np.zeros((n_actions, m_outcomes), dtype=np.float64)
        for i, a in enumerate(unique_labels):
            cluster_ps = filtered_p[filtered_labels == a]
            c = cluster_ps.mean(axis=0)
            c = np.clip(c, 0, None)
            s = c.sum()
            if s > 0:
                c /= s
            else:
                c = np.ones(m_outcomes) / m_outcomes
            centers[i] = c

        # --- Step 4: Assign accepted logs to closest cluster by Euclidean distance ---
        dist_acc = cdist(p_accept, centers, metric='euclidean')
        assigned_clusters = dist_acc.argmin(axis=1)

        accepted_contracts = np.array(accepted['Contract'].tolist(), dtype=np.float64)
        rejected_contracts = np.array(rejected['Contract'].tolist(), dtype=np.float64) if not rejected.empty else np.empty((0, m_outcomes))

        # --- Step 5: Initialize costs satisfying IR and IC constraints ---
        eps_cost = 1e-7
        costs = np.zeros(n_actions, dtype=np.float64)
        for i in range(n_actions):
            p_i = centers[i]

            # IR: cost >= max accepted contract expected payment for assigned accepted logs
            idx_acc = np.where(assigned_clusters == i)[0]
            max_acc = accepted_contracts[idx_acc] @ p_i if idx_acc.size > 0 else np.array([0.0])
            max_acc_val = max_acc.max() if idx_acc.size > 0 else 0.0

            # IC: cost > max rejected contract expected payment
            if rejected_contracts.shape[0] > 0:
                rej_vals = rejected_contracts @ p_i
                max_rej_val = rej_vals.max()
            else:
                max_rej_val = -np.inf

            costs[i] = max(max_acc_val, max_rej_val + eps_cost, 0.0)

        # --- Step 6: Iteratively refine costs with fine steps to satisfy IR and IC ---
        max_iters = 50
        step = 1e-7
        for _ in range(max_iters):
            # Accepted utilities: contracts @ centers.T - costs, shape (n_accept, n_actions)
            accept_utils = accepted_contracts @ centers.T - costs[None, :]
            max_accept_util = accept_utils.max(axis=1)
            violated_accept = np.where(max_accept_util < -step)[0]

            # Rejected utilities
            if rejected_contracts.shape[0] > 0:
                reject_utils = rejected_contracts @ centers.T - costs[None, :]
                max_reject_util = reject_utils.max(axis=1)
                violated_reject = np.where(max_reject_util >= -step)[0]
            else:
                violated_reject = np.array([], dtype=int)

            if violated_accept.size == 0 and violated_reject.size == 0:
                break  # all constraints satisfied

            # Fix accept violations by increasing cost of best action for that log
            for idx in violated_accept:
                utilities = accept_utils[idx]
                best_a = np.argmax(utilities)
                w = accepted_contracts[idx]
                required_cost = centers[best_a] @ w
                if costs[best_a] < required_cost:
                    costs[best_a] = required_cost

            # Fix reject violations by increasing costs of all violating actions
            for idx in violated_reject:
                utilities = reject_utils[idx]
                violating_actions = np.where(utilities >= -step)[0]
                w = rejected_contracts[idx]
                for a in violating_actions:
                    required_cost = centers[a] @ w + step
                    if costs[a] < required_cost:
                        costs[a] = required_cost

        # Normalize centers and ensure costs non-negative
        centers = np.clip(centers, 0, None)
        s = centers.sum(axis=1, keepdims=True)
        s[s == 0] = 1.0
        centers /= s
        costs = np.maximum(costs, 0.0)

    agent_setting = np.hstack([centers, costs[:, None]])
    return agent_setting
```
