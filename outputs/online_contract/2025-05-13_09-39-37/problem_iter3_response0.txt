```python
import numpy as np
import pandas as pd
from sklearn.cluster import DBSCAN
from scipy.optimize import linprog

def agent_solver_v2(v: np.ndarray, content: list[dict]) -> np.ndarray:
    """
    Infer a valid agent setting (prob distributions over outcomes + costs)
    explaining the historical interaction logs between principal and agent.

    Args:
        v (np.ndarray): Principal's reward vector for 5 outcomes, shape (5,)
        content (list[dict]): Each dict contains
            - 'Contract': 5-dim payment vector,
            - 'Principal Utility': principal utility under contract,
            - 'Agent Action': 1 for accept, -1 for reject.

    Returns:
        np.ndarray: n x 6 matrix: first 5 cols are outcome probabilities (sum=1),
                    last column is agent cost (≥0).
    """
    m_outcomes = v.shape[0]
    logs_df = pd.DataFrame(content)
    accepted = logs_df[logs_df['Agent Action'] == 1].reset_index(drop=True)
    rejected = logs_df[logs_df['Agent Action'] == -1].reset_index(drop=True)

    # If no acceptances, trivial agent with one action: uniform dist and zero cost
    if accepted.empty:
        return np.hstack([np.ones((1, m_outcomes)) / m_outcomes, np.zeros((1, 1))])

    # Step 1: Infer outcome distributions p for accepted contracts
    # Solve LP: find p s.t. sum p=1, p@(v - w) = principal utility u_p, p≥0
    # Objective: maximize p@w (agent expected payment)
    def infer_p_for_log(w, u_p):
        c_obj = -np.array(w, dtype=np.float64)  # maximize p@w <=> minimize -p@w
        A_eq = np.vstack([np.ones(m_outcomes), v - w])
        b_eq = np.array([1.0, u_p], dtype=np.float64)
        bounds = [(0.0, 1.0) for _ in range(m_outcomes)]
        res = linprog(c=c_obj, A_eq=A_eq, b_eq=b_eq, bounds=bounds, method='highs')
        if res.success:
            p = res.x
            # Numerical fix: clip and renormalize
            p = np.clip(p, 0, None)
            s = p.sum()
            if s > 0:
                p /= s
            else:
                p = np.ones(m_outcomes) / m_outcomes
            return p
        else:
            # fallback: uniform distribution
            return np.ones(m_outcomes) / m_outcomes

    p_list = [infer_p_for_log(row['Contract'], row['Principal Utility']) for _, row in accepted.iterrows()]
    p_array = np.vstack(p_list)

    # Step 2: Use DBSCAN clustering (with eps chosen adaptively) on p_array to identify distinct agent actions
    # Incorporate rejected logs by clustering their inferred p approximations with negative weights
    # For rejected logs, we cannot infer p directly, but we can cluster accepted p's first,
    # then validate IC constraints against rejected contracts.
    # To incorporate rejected logs in clustering, we do adaptive DBSCAN on accepted p's only,
    # then validate and refine costs.

    # Adaptive eps selection for DBSCAN using elbow method on k-distances
    def select_eps(data, k=5):
        from sklearn.neighbors import NearestNeighbors
        nbrs = NearestNeighbors(n_neighbors=k).fit(data)
        distances, _ = nbrs.kneighbors(data)
        k_distances = np.sort(distances[:, k-1])
        # Heuristic: eps at 90th percentile of k-distances
        eps = np.percentile(k_distances, 90)
        return max(eps, 1e-3)

    eps = select_eps(p_array)
    clustering = DBSCAN(eps=eps, min_samples=3, metric='euclidean').fit(p_array)
    labels = clustering.labels_

    # If all points are noise (-1), fallback to single cluster
    if np.all(labels == -1):
        labels = np.zeros(len(p_array), dtype=int)
    else:
        # Assign noise points to nearest cluster center
        noise_idx = np.where(labels == -1)[0]
        assigned_idx = np.where(labels != -1)[0]
        if len(assigned_idx) > 0 and len(noise_idx) > 0:
            centers_tmp = []
            for lbl in np.unique(labels[assigned_idx]):
                centers_tmp.append(p_array[labels == lbl].mean(axis=0))
            centers_tmp = np.vstack(centers_tmp)
            from sklearn.metrics import pairwise_distances_argmin_min
            nearest_cluster, _ = pairwise_distances_argmin_min(p_array[noise_idx], centers_tmp)
            for i, ni in enumerate(noise_idx):
                labels[ni] = nearest_cluster[i]
        else:
            # If no assigned points, assign all to cluster 0
            labels[:] = 0

    unique_labels = np.unique(labels)
    n_actions = len(unique_labels)

    # Step 3: Compute cluster centers (mean p per cluster), normalize
    centers = np.zeros((n_actions, m_outcomes), dtype=np.float64)
    for i, lbl in enumerate(unique_labels):
        pts = p_array[labels == lbl]
        mean_p = pts.mean(axis=0)
        mean_p = np.clip(mean_p, 0, None)
        s = mean_p.sum()
        if s > 0:
            mean_p /= s
        else:
            mean_p = np.ones(m_outcomes) / m_outcomes
        centers[i] = mean_p

    # Map old labels to 0..n_actions-1
    label_map = {old_lbl: new_idx for new_idx, old_lbl in enumerate(unique_labels)}
    labels = np.array([label_map[lbl] for lbl in labels])

    # Step 4: Infer minimal costs c_a for each action satisfying IR and IC constraints
    # IR (accepted): for accepted contracts assigned to action a,
    # p_a @ w - c_a >= 0 => c_a <= min_{accepted} p_a @ w
    # IC (rejected): for all rejected contracts,
    # p_a @ w - c_a < 0 => c_a > max_{rejected} p_a @ w
    # To satisfy both, set c_a = max(
    #   max_{accepted assigned a} p_a @ w,
    #   max_{rejected} p_a @ w + epsilon
    # )
    # If no accepted assigned to a, use 0 for max accepted utility
    # If no rejected contracts, ignore that term

    eps = 1e-7
    contract_acc = np.array(accepted['Contract'].tolist(), dtype=np.float64)
    contract_rej = np.array(rejected['Contract'].tolist(), dtype=np.float64) if not rejected.empty else np.empty((0, m_outcomes), dtype=np.float64)

    costs = np.zeros(n_actions, dtype=np.float64)
    for a in range(n_actions):
        p_a = centers[a]

        # Accepted contracts assigned to cluster a
        idx_acc = np.where(labels == a)[0]
        if idx_acc.size > 0:
            w_acc = contract_acc[idx_acc]
            acc_vals = w_acc @ p_a
            max_acc = acc_vals.max()
        else:
            max_acc = 0.0

        # Rejected contracts
        if contract_rej.shape[0] > 0:
            rej_vals = contract_rej @ p_a
            max_rej = rej_vals.max()
        else:
            max_rej = -np.inf

        cost_a = max(max_acc, max_rej + eps)
        costs[a] = max(cost_a, 0.0)

    # Step 5: Validate IR and IC constraints on all logs and refine costs if needed
    # Accepted logs: must have ∃a s.t. p_a @ w - c_a >= 0
    # Rejected logs: must have ∀a, p_a @ w - c_a < 0
    # If violated, increase costs minimally to fix

    def validate_and_refine(costs_in):
        costs_new = costs_in.copy()
        max_iters = 20
        for _ in range(max_iters):
            # Accepted logs
            accept_utils = contract_acc @ centers.T - costs_new[None, :]
            accept_max = accept_utils.max(axis=1)
            violated_accept = np.where(accept_max < -eps)[0]

            # Rejected logs
            if contract_rej.shape[0] > 0:
                reject_utils = contract_rej @ centers.T - costs_new[None, :]
                reject_max = reject_utils.max(axis=1)
                violated_reject = np.where(reject_max >= -eps)[0]
            else:
                violated_reject = np.array([], dtype=int)

            if len(violated_accept) == 0 and len(violated_reject) == 0:
                break  # all constraints satisfied

            # Fix accept violations by lowering costs of best action for that log
            for idx in violated_accept:
                w = contract_acc[idx]
                utilities = centers @ w - costs_new
                best_a = np.argmax(utilities)
                # Increase cost so that utility >= 0
                required_cost = centers[best_a] @ w
                if costs_new[best_a] > required_cost:
                    # costs already too high, no fix possible here, skip
                    continue
                costs_new[best_a] = max(costs_new[best_a], required_cost)

            # Fix reject violations by increasing costs of all actions that violate
            for idx in violated_reject:
                w = contract_rej[idx]
                utilities = centers @ w - costs_new
                violating_actions = np.where(utilities >= -eps)[0]
                for a in violating_actions:
                    required_cost = centers[a] @ w + eps
                    if costs_new[a] < required_cost:
                        costs_new[a] = required_cost

        return costs_new

    costs = validate_and_refine(costs)

    # Final normalization and output
    agent_setting = np.hstack([centers, costs[:, None]])
    return agent_setting
```
