```python
import numpy as np
import pandas as pd
from scipy.optimize import linprog, minimize
from sklearn.cluster import AgglomerativeClustering


def agent_solver_v2(v: np.ndarray, content: pd.DataFrame) -> np.ndarray:
    """
    Infer a valid agent setting matrix (actions x [probabilities + cost]) that explains the historical logs.

    Parameters:
    - v: np.ndarray of shape (5,), principal's reward vector per outcome.
    - content: pd.DataFrame with columns ['Contract', 'Principal Utility', 'Agent Action'].
      Contract is a list of 5 payments; Agent Action in {1, -1}.

    Returns:
    - agent_setting: np.ndarray shape (n_actions, 6), last column is cost.
    """

    m = len(v)  # outcomes count
    logs = content.copy()
    L = len(logs)

    # Extract arrays for convenience
    contracts = np.vstack(logs['Contract'].to_numpy())  # (L,5)
    putils = logs['Principal Utility'].to_numpy()       # (L,)
    actions = logs['Agent Action'].to_numpy()           # (L,)

    # Step 1: Separate accepted and rejected logs
    acc_idx = np.where(actions == 1)[0]
    rej_idx = np.where(actions == -1)[0]

    # If no accepted contracts, fallback trivial agent: uniform, zero cost
    if len(acc_idx) == 0:
        uniform_p = np.ones(m) / m
        return np.hstack([uniform_p.reshape(1, -1), np.zeros((1, 1))])

    # Step 2: Infer candidate outcome distributions per accepted log via LP:
    # Solve for p: max p·w subject to p·1=1, p·v = principal_util, p >= 0
    # Because agent utility >= 0 means p·w - cost >= 0, and principal util = p·(v - w)
    # We want to solve for p that satisfy p·(v - w) = principal_util, sum p=1, p>=0
    # but p·w unknown; instead, we approximate p that satisfies p·(v - w) = principal_util and p·1=1 closest.

    # We do a quadratic program per accepted log to find p_i minimizing ||p_i - p_mean||^2 s.t constraints
    # But first we get an initial guess by solving linear eqn with linprog for each accepted log.

    candidate_ps = []
    for i in acc_idx:
        w = contracts[i]
        u_p = putils[i]

        # Constraints:
        # p·1=1
        # p·(v - w) = u_p
        # p >= 0

        # Form equality constraints matrix and vector
        A_eq = np.array([np.ones(m), v - w])
        b_eq = np.array([1.0, u_p])

        # Objective: minimize ||p - uniform||^2 to get a smooth p
        # We'll do QP: min (p - 1/m)^T I (p - 1/m) s.t A_eq p = b_eq, p >=0

        # Use 'SLSQP' nonlinear solver since scipy linprog doesn't support QP
        def objective(p):
            return np.sum((p - (1.0 / m)) ** 2)

        constraints = [
            {'type': 'eq', 'fun': lambda p, A=A_eq, b=b_eq: np.dot(A, p) - b},
            {'type': 'ineq', 'fun': lambda p: p}  # p >= 0
        ]

        res = minimize(objective, x0=np.ones(m) / m, constraints=constraints, method='SLSQP', options={'ftol':1e-9})
        if res.success:
            p_i = res.x
            # Numerical projection to simplex
            p_i[p_i < 0] = 0
            p_i /= p_i.sum()
            candidate_ps.append(p_i)
        else:
            # fallback to uniform if optimization fails
            candidate_ps.append(np.ones(m) / m)

    candidate_ps = np.vstack(candidate_ps)  # shape (num_acc, m)

    # Step 3: Cluster candidate_ps into adaptive number n_actions by hierarchical clustering with distance cutoff
    # Choose cutoff to limit n_actions between 3 and 10
    max_clusters = 10
    min_clusters = 3

    for n_clusters in range(min_clusters, max_clusters + 1):
        clustering = AgglomerativeClustering(n_clusters=n_clusters).fit(candidate_ps)
        labels = clustering.labels_
        # Check if clusters have reasonable sizes
        sizes = np.bincount(labels)
        if np.all(sizes >= 2):
            break

    n_actions = n_clusters

    # Compute cluster centers as the mean p of each cluster
    p0 = np.zeros((n_actions, m))
    for a in range(n_actions):
        cluster_ps = candidate_ps[labels == a]
        p0[a] = cluster_ps.mean(axis=0)
        p0[a] /= p0[a].sum()  # ensure normalized

    # Step 4: Infer cost vector c for each action to satisfy IR and IC constraints
    # Variables: c in R^{n_actions}, c >= 0
    # Constraints:
    #   For each accepted log i:
    #     p_{a_i}·w_i - c_a_i >= 0  (IR)
    #     a_i := best action explaining log i (assign accepted log i to cluster label)
    #   For each rejected log j:
    #     max_a (p_a · w_j - c_a) < 0  (rejection)
    # We encode max constraints as multiple linear constraints:
    # For each rejected j and each a: p_a·w_j - c_a < 0

    # Build constraint matrices
    c_dim = n_actions
    A_ub = []
    b_ub = []

    # IR constraints: p_a·w_i - c_a >= 0 -> -c_a >= -p_a·w_i
    # Put as -c_a <= -p_a·w_i

    # For each accepted log i, a_i = labels[i]
    # Let x = c vector
    for i, log_i in enumerate(acc_idx):
        a_i = labels[i]
        p_a = p0[a_i]
        w_i = contracts[log_i]
        val = np.dot(p_a, w_i)
        A_row = np.zeros(c_dim)
        A_row[a_i] = -1  # -c_a <= -val
        A_ub.append(A_row)
        b_ub.append(-val)

    # Rejection constraints:
    # For each rejected log j and each action a:
    # p_a·w_j - c_a < 0  =>  -c_a < -p_a·w_j
    # We translate to -c_a <= -p_a·w_j - epsilon (epsilon > 0 for strict)
    epsilon = 1e-5
    for j in rej_idx:
        w_j = contracts[j]
        for a in range(n_actions):
            p_a = p0[a]
            val = np.dot(p_a, w_j) - epsilon
            A_row = np.zeros(c_dim)
            A_row[a] = -1
            A_ub.append(A_row)
            b_ub.append(-val)

    A_ub = np.vstack(A_ub) if A_ub else np.zeros((0, c_dim))
    b_ub = np.array(b_ub) if b_ub else np.array([])

    # Cost non-negative: c >= 0
    bounds = [(0, None)] * c_dim

    # Objective: minimize sum(c) to get minimal costs satisfying constraints
    c_obj = np.ones(c_dim)

    # Use linprog to solve
    res = linprog(c=c_obj, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')

    if not res.success:
        # If LP fails, fallback: costs zero (possibly violating constraints)
        costs = np.zeros(n_actions)
    else:
        costs = res.x

    # Step 5: Post-process to ensure costs are consistent with IR constraints per action
    # For each action a, cost <= min_i (p_a·w_i) over accepted logs assigned to a.
    for a in range(n_actions):
        idxs = [acc_idx[i] for i in range(len(acc_idx)) if labels[i] == a]
        if idxs:
            vals = [np.dot(p0[a], contracts[i]) for i in idxs]
            min_val = min(vals)
            if costs[a] > min_val:
                costs[a] = min_val

    # Step 6: Return agent setting matrix: n_actions x (5+1)
    agent_setting = np.hstack([p0, costs.reshape(-1, 1)])

    return agent_setting
```
