```python
import numpy as np
import pandas as pd
from scipy.optimize import linprog
from sklearn.cluster import AgglomerativeClustering

def agent_solver_v2(v: np.ndarray, content: list[dict]) -> np.ndarray:
    """
    Infer a valid agent setting (prob distributions over outcomes + costs)
    explaining the historical interaction logs between principal and agent.

    Args:
        v (np.ndarray): Principal's reward vector for 5 outcomes, shape (5,)
        content (list[dict]): Each dict contains
            - 'Contract': 5-dim payment vector,
            - 'Principal Utility': principal utility under contract,
            - 'Agent Action': 1 for accept, -1 for reject.

    Returns:
        np.ndarray: n x 6 matrix: first 5 cols are outcome probabilities (sum=1),
                    last column is agent cost (â‰¥0).
    """
    m_outcomes = v.shape[0]
    logs_df = pd.DataFrame(content)
    accepted = logs_df[logs_df['Agent Action'] == 1].reset_index(drop=True)
    rejected = logs_df[logs_df['Agent Action'] == -1].reset_index(drop=True)

    # If no accepted logs, return trivial agent: uniform dist + zero cost
    if accepted.empty:
        uniform_p = np.ones(m_outcomes) / m_outcomes
        return np.hstack([uniform_p.reshape(1, -1), np.zeros((1, 1))])

    # LP to infer the agent's outcome distribution p for each accepted contract
    def infer_p_for_log(w, u_p):
        # variables: p (length m_outcomes)
        # constraints:
        #   sum p = 1
        #   p @ (v - w) = u_p (principal utility observed)
        # bounds: p_i in [0,1]
        # objective: maximize p @ w (agent expected payment)
        c_obj = -np.array(w, dtype=np.float64)  # maximize p @ w <=> minimize -p @ w
        A_eq = np.vstack([np.ones(m_outcomes), v - w])
        b_eq = np.array([1.0, u_p], dtype=np.float64)
        bounds = [(0, 1) for _ in range(m_outcomes)]
        res = linprog(c=c_obj, A_eq=A_eq, b_eq=b_eq, bounds=bounds, method='highs')
        if res.success:
            p = res.x
            p = np.clip(p, 0, None)
            s = p.sum()
            if s > 0:
                p /= s
            else:
                p = np.ones(m_outcomes) / m_outcomes
            return p
        else:
            # fallback uniform distribution
            return np.ones(m_outcomes) / m_outcomes

    # Infer p for all accepted logs
    p_array = np.vstack([infer_p_for_log(row['Contract'], row['Principal Utility']) for _, row in accepted.iterrows()])

    # Cluster these p's into groups representing distinct agent actions
    # Use hierarchical clustering with distance threshold for adaptive number of clusters
    clustering = AgglomerativeClustering(n_clusters=None, distance_threshold=0.15, linkage='average')
    labels = clustering.fit_predict(p_array)
    n_actions = labels.max() + 1

    # Compute cluster centers (mean p per cluster)
    centers = np.zeros((n_actions, m_outcomes), dtype=np.float64)
    for a in range(n_actions):
        cluster_ps = p_array[labels == a]
        c = cluster_ps.mean(axis=0)
        c = np.clip(c, 0, None)
        s = c.sum()
        if s > 0:
            c /= s
        else:
            c = np.ones(m_outcomes) / m_outcomes
        centers[a] = c

    accepted_contracts = np.array(accepted['Contract'].tolist(), dtype=np.float64)
    rejected_contracts = np.array(rejected['Contract'].tolist(), dtype=np.float64) if not rejected.empty else np.empty((0, m_outcomes), dtype=np.float64)

    eps = 1e-7
    costs = np.zeros(n_actions, dtype=np.float64)

    # Assign each accepted log to its cluster (action)
    assigned_clusters = labels

    # Compute minimal costs satisfying IR and IC with strict margin eps
    for a in range(n_actions):
        p_a = centers[a]

        # IR: For accepted contracts assigned to action a, utility >= 0 => cost <= expected payment
        accepted_idx = np.where(assigned_clusters == a)[0]
        if accepted_idx.size > 0:
            w_acc = accepted_contracts[accepted_idx]
            max_acc = np.max(w_acc @ p_a)
        else:
            max_acc = 0.0

        # IC: For all rejected contracts, utility < 0 => cost > expected payment
        if rejected_contracts.shape[0] > 0:
            rej_vals = rejected_contracts @ p_a
            max_rej = rej_vals.max()
        else:
            max_rej = -np.inf

        # cost must satisfy: cost >= max_acc (IR) and cost > max_rej (IC)
        cost_a = max(max_acc, max_rej + eps)
        costs[a] = max(cost_a, 0.0)

    # Iteratively refine costs to ensure IR and IC hold strictly with margin eps
    max_iters = 30
    for _ in range(max_iters):
        prev_costs = costs.copy()

        # Accepted logs: must have some action with utility >= 0
        accept_utils = accepted_contracts @ centers.T - costs  # shape (n_accept, n_actions)
        max_accept_utils = accept_utils.max(axis=1)
        accept_violations = max_accept_utils < eps  # allow small margin

        # Rejected logs: must have all actions with utility < 0
        if rejected_contracts.shape[0] > 0:
            reject_utils = rejected_contracts @ centers.T - costs  # shape (n_reject, n_actions)
            max_reject_utils = reject_utils.max(axis=1)
            reject_violations = max_reject_utils >= -eps
        else:
            reject_violations = np.array([], dtype=bool)

        if not accept_violations.any() and not reject_violations.any():
            break  # feasible solution found

        # Fix accept violations: decrease costs of best action per violating accepted log
        if accept_violations.any():
            violating_idxs = np.where(accept_violations)[0]
            for idx in violating_idxs:
                # best action for this accepted log
                best_action = accept_utils[idx].argmax()
                costs[best_action] = max(costs[best_action] - eps * 5, 0.0)

        # Fix reject violations: increase all costs to maintain IC strictly
        if reject_violations.any():
            costs += eps * 10

        costs = np.maximum(costs, 0.0)

        if np.allclose(costs, prev_costs, atol=eps):
            break  # no significant change

    # Normalize centers again for safety
    centers = np.clip(centers, 0, None)
    s = centers.sum(axis=1, keepdims=True)
    centers /= np.where(s == 0, 1, s)

    agent_setting = np.hstack([centers, costs[:, None]])
    return agent_setting
```
